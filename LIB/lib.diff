--- e:\uupc1.12s\source\lib\ARBMATH.H	Sat Jan  7 11:15:22 1995
+++ ARBMATH.H	Fri Jul 25 21:19:28 1997
@@ -1,15 +1,15 @@
 
 void mult(unsigned char *number,
-      const unsigned range,
-      const unsigned digits);
+		const unsigned range,
+		const unsigned digits);
 
 void add(unsigned char *number,
-      const unsigned range,
-      const unsigned digits);
+		const unsigned range,
+		const unsigned digits);
 
 KWBoolean adiv( unsigned char *number,
-             const unsigned divisor,
-                   unsigned *remain,
-             const unsigned digits);
+				 const unsigned divisor,
+						 size_t *remain,
+				 const unsigned digits);
 
-#define MAX_DIGITS 20         /* Number of digits for arb math */
+#define MAX_DIGITS 20			/* Number of digits for arb math */
--- e:\uupc1.12s\source\lib\LIB.H	Sat May 10 23:28:52 1997
+++ LIB.H	Sun Aug 10 21:02:46 1997
@@ -1,17 +1,17 @@
 /*--------------------------------------------------------------------*/
-/*       l i b . h                                                    */
+/*       l i b . h																	 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*       Changes Copyright (c) 1989-1997 by Kendra Electronic         */
-/*       Wonderworks.                                                 */
+/*       Changes Copyright (c) 1989-1997 by Kendra Electronic			 */
+/*       Wonderworks.																 */
 /*                                                                    */
-/*       All rights reserved except those explicitly granted by       */
-/*       the UUPC/extended license agreement.                         */
+/*       All rights reserved except those explicitly granted by		 */
+/*       the UUPC/extended license agreement.								 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                          RCS Information                           */
+/*                          RCS Information									 */
 /*--------------------------------------------------------------------*/
 
 /*
@@ -19,57 +19,57 @@
  *
  *    Revision history:
  *    $Log: lib.h $
- *    Revision 1.39  1997/05/11 04:28:53  ahd
+ *    Revision 1.39	1997/05/11 04:28:53	ahd
  *    SMTP client support for RMAIL/UUXQT
  *
- *    Revision 1.38  1997/03/31 07:00:15  ahd
+ *    Revision 1.38	1997/03/31 07:00:15	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.37  1996/11/19 00:25:20  ahd
+ *    Revision 1.37	1996/11/19 00:25:20	ahd
  *    Correct C++ scoping
  *
- *    Revision 1.36  1996/03/18 03:48:14  ahd
+ *    Revision 1.36	1996/03/18 03:48:14	ahd
  *    Allow compilation under C++ compilers
  *
- *    Revision 1.35  1996/01/07 14:18:18  ahd
+ *    Revision 1.35	1996/01/07 14:18:18	ahd
  *    Provide external references to configuration functions and routines
  *    needed by regsetup.
  *
- *    Revision 1.34  1996/01/04 04:01:44  ahd
+ *    Revision 1.34	1996/01/04 04:01:44	ahd
  *    Use sorted table for boolean options with binary search
  *
- *    Revision 1.33  1996/01/02 00:02:08  ahd
+ *    Revision 1.33	1996/01/02 00:02:08	ahd
  *    Use sorted confifugration file tables with predefined sizes
  *    to allow binary search, rather than previous linear search.
  *
- *    Revision 1.32  1995/07/21 13:28:20  ahd
+ *    Revision 1.32	1995/07/21 13:28:20	ahd
  *    Correct compiler warnings
  *
- *    Revision 1.31  1995/02/12 23:39:45  ahd
+ *    Revision 1.31	1995/02/12 23:39:45	ahd
  *    compiler cleanup, NNS C/news support, optimize dir processing
  *
- *    Revision 1.30  1995/01/30 04:05:39  ahd
+ *    Revision 1.30	1995/01/30 04:05:39	ahd
  *    Additional compiler warning fixes, optimize path normalizing
  *
- *    Revision 1.29  1995/01/29 14:09:13  ahd
+ *    Revision 1.29	1995/01/29 14:09:13	ahd
  *    IBM C/Set++ warnings cleanup
  *
- *    Revision 1.28  1995/01/28 23:13:37  ahd
+ *    Revision 1.28	1995/01/28 23:13:37	ahd
  *    Delete GNU C reference
  *
- *    Revision 1.27  1995/01/07 16:16:05  ahd
+ *    Revision 1.27	1995/01/07 16:16:05	ahd
  *    Change KWBoolean to KWBoolean to avoid VC++ 2.0 conflict
  *
- *    Revision 1.26  1994/12/31 03:51:25  ahd
+ *    Revision 1.26	1994/12/31 03:51:25	ahd
  *    First pass of integrating Mike McLagan's news SYS file suuport
  *
- *    Revision 1.25  1994/12/27 20:50:28  ahd
+ *    Revision 1.25	1994/12/27 20:50:28	ahd
  *    Smoother call grading
  *
- *    Revision 1.24  1994/12/22 00:13:16  ahd
+ *    Revision 1.24	1994/12/22 00:13:16	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.23  1994/11/27 17:34:39  ahd
+ *    Revision 1.23	1994/11/27 17:34:39	ahd
  *    Ooops, B_GENERIC needs to be added to B_ALL to work.
  *
  *     Revision 1.22  1994/11/27  17:31:34  ahd
@@ -114,33 +114,33 @@
  *     Revision 1.10  1993/07/22  23:26:19  ahd
  *     First pass of changes for Robert Denny's Windows 3.1 support
  *
- *     Revision 1.9  1993/07/19  02:53:32  ahd
+ *     Revision 1.9	1993/07/19	02:53:32  ahd
  *     Update copyright year'
  *
- *     Revision 1.8  1993/06/13  14:12:29  ahd
+ *     Revision 1.8	1993/06/13	14:12:29  ahd
  *     Changes per Mike McLagan for outbound batched news support
  *
- *     Revision 1.7  1993/05/30  15:27:22  ahd
+ *     Revision 1.7	1993/05/30	15:27:22  ahd
  *     Drop PASSWD, SYSTEMS definitions
  *
- *     Revision 1.6  1993/05/30  00:11:03  ahd
+ *     Revision 1.6	1993/05/30	00:11:03  ahd
  *     Drop free() macro
  *     Drop hardcoded PASSWD and SYSTEM file names
  *     Add RCSID macro
  *
- *     Revision 1.5  1993/04/04  21:51:00  ahd
+ *     Revision 1.5	1993/04/04	21:51:00  ahd
  *     Update copyright
  *
- *     Revision 1.4  1993/03/06  23:09:50  ahd
+ *     Revision 1.4	1993/03/06	23:09:50  ahd
  *     Break variable names out of master lib.h
  *
- *     Revision 1.3  1992/12/01  04:39:34  ahd
+ *     Revision 1.3	1992/12/01	04:39:34  ahd
  *     Add SpeedOverMemory
  *
- * Revision 1.2  1992/11/22  21:31:22  ahd
+ * Revision 1.2  1992/11/22  21:31:22	ahd
  * Allow strpool() to allocate memory for const strings
  *
- * Revision 1.1  1992/11/16  05:00:26  ahd
+ * Revision 1.1  1992/11/16  05:00:26	ahd
  * Initial revision
  *
  */
@@ -155,16 +155,16 @@
 #define UU_USER "UU_USER"
 #define UU_MACHINE "UU_MACHINE"
 #define LOGNAME "LOGNAME"
-#define RMAIL   "rmail"
-#define RNEWS   "rnews"
+#define RMAIL	 "rmail"
+#define RNEWS	 "rnews"
 
 /*--------------------------------------------------------------------*/
-/*                   Global configuration variables                   */
+/*                   Global configuration variables						 */
 /*--------------------------------------------------------------------*/
 
 #define SYSRCSYM "UUPCSYSRC"
-#define USRRCSYM  "UUPCUSRRC"
-#define SYSDEBUG  "UUPCDEBUG"    /* Initialize debug level ahd        */
+#define USRRCSYM	"UUPCUSRRC"
+#define SYSDEBUG	"UUPCDEBUG"    /* Initialize debug level ahd        */
 
 #if defined(WIN32)
 #define REGISTRYHIVE  "Software\\Kendra Electronic Wonderworks\\UUPC/extended"
@@ -187,84 +187,85 @@
 #define panic()  bugout( cfnptr, __LINE__)
 
 /*--------------------------------------------------------------------*/
-/*                 Macro for generic error messages from DOS          */
+/*                 Macro for generic error messages from DOS			 */
 /*--------------------------------------------------------------------*/
 
 #define printerr( x )  prterror( __LINE__, cfnptr, x)
 
 /*--------------------------------------------------------------------*/
-/*                  Convert hours/minutes to seconds                  */
+/*                  Convert hours/minutes to seconds						 */
 /*--------------------------------------------------------------------*/
 
-#define hhmm2sec(HHMM)    ((time_t)(((HHMM / 100) * 60L) + \
-                           (time_t)(HHMM % 100)) * 60L)
+#define hhmm2sec(HHMM)	  ((time_t)(((HHMM / 100) * 60L) + \
+									(time_t)(HHMM % 100)) * 60L)
 
 #define RCSID(x) static const char UUFAR _rcsId[] = x
 
 /*--------------------------------------------------------------------*/
-/*                     Configuration file defines                     */
+/*                     Configuration file defines							 */
 /*--------------------------------------------------------------------*/
 
 
-#define B_EXPIRE   0x00000001L
+#define B_EXPIRE	 0x00000001L
 #define B_GENERIC  0x00000002L /* Generic utilties with no spec vars  */
 #define B_GENHIST  B_EXPIRE
-#define B_INEWS    0x00000004L
+#define B_INEWS	 0x00000004L
 #define B_INSTALL  0x00000008L /* Used by install program only        */
-#define B_MTA      0x00000010L /* Used by Mail Delivery (RMAIL)       */
-#define B_MUA      0x00000020L /* Used by Mail User Agent (MAIL)      */
+#define B_MTA		 0x00000010L /* Used by Mail Delivery (RMAIL)		 */
+#define B_MUA		 0x00000020L /* Used by Mail User Agent (MAIL)		 */
 #define B_MUSH     0x00000040L /* Used by MUSH - Not used by UUPC     */
 #define B_NEWSRUN  0x00000080L
-#define B_RNEWS    0x00000100L
+#define B_RNEWS	 0x00000100L
 #define B_SENDBATS 0x00000200L /* Used by news batching program - GMM */
-#define B_UUCICO   0x00000400L /* Used by transport program UUCICO    */
-#define B_UUCP     0x00000800L /* Used by UUCP command                */
-#define B_UUPOLL   0x00001000L /* UUPOLL program                      */
-#define B_UUSTAT   0x00002000L /* UUSTAT, UUSUB, UUNAME programs      */
-#define B_UUNAME   B_UUSTAT
-#define B_UUSUB    B_UUSTAT
-#define B_UUXQT    0x00004000L /* Used by queue processor UUXQT       */
+#define B_UUCICO	 0x00000400L /* Used by transport program UUCICO	 */
+#define B_UUCP     0x00000800L /* Used by UUCP command					 */
+#define B_UUPOLL	 0x00001000L /* UUPOLL program							 */
+#define B_UUSTAT	 0x00002000L /* UUSTAT, UUSUB, UUNAME programs		 */
+#define B_UUNAME	 B_UUSTAT
+#define B_UUSUB	 B_UUSTAT
+#define B_UUXQT	 0x00004000L /* Used by queue processor UUXQT		 */
 
 #define B_NEWS     (B_RNEWS | B_SENDBATS | B_NEWSRUN | B_EXPIRE | B_INEWS )
+#define B_DBZ		 (B_RNEWS | B_NEWSRUN | B_EXPIRE | B_INEWS)
 #define B_MAIL     (B_MUA | B_MTA | B_MUSH)
-#define B_SPOOL    (B_MTA | B_UUCICO | B_UUXQT | B_UUCP | B_UUSTAT)
-#define B_ALL      (B_MAIL | B_SPOOL | B_NEWS | B_UUPOLL | B_GENERIC | B_INSTALL)
+#define B_SPOOL	 (B_MTA | B_UUCICO | B_UUXQT | B_UUCP | B_UUSTAT)
+#define B_ALL		 (B_MAIL | B_SPOOL | B_NEWS | B_UUPOLL | B_GENERIC | B_INSTALL)
 
 /*--------------------------------------------------------------------*/
-/*               Flags in configuration table flag word               */
+/*               Flags in configuration table flag word					 */
 /*--------------------------------------------------------------------*/
 
-#define B_REQUIRED 0x00000001L /* Line must appear in configuration   */
-#define B_FOUND    0x00000002L /* We found the token                  */
+#define B_REQUIRED 0x00000001L /* Line must appear in configuration	 */
+#define B_FOUND	 0x00000002L /* We found the token						 */
 
-#define B_GLOBAL   0x00000004L /* Must not appear in PERSONAL.RC      */
-#define B_LOCAL    0x00000008L /* The opposite of B_GLOBAL, sort of   */
-#define B_SHORT    0x00000010L /* Pointer is to short int, not string */
-#define B_TOKEN    0x00000020L /* Pointer is one word, ignore blanks  */
-#define B_BOOLEAN  0x00000040L /* Pointer is to KWBoolean keywords     */
-#define B_LIST     0x00000080L /* Pointer to array of char pointers   */
-#define B_CLIST    0x00000100L /* Pointer to array of char pointers,
-                                  using colon delimiter               */
+#define B_GLOBAL	 0x00000004L /* Must not appear in PERSONAL.RC		 */
+#define B_LOCAL	 0x00000008L /* The opposite of B_GLOBAL, sort of	 */
+#define B_SHORT	 0x00000010L /* Pointer is to short int, not string */
+#define B_TOKEN	 0x00000020L /* Pointer is one word, ignore blanks  */
+#define B_BOOLEAN  0x00000040L /* Pointer is to KWBoolean keywords	  */
+#define B_LIST     0x00000080L /* Pointer to array of char pointers	 */
+#define B_CLIST	 0x00000100L /* Pointer to array of char pointers,
+											 using colon delimiter					 */
 #define B_CHAR     0x00000200L /* Single character                    */
-#define B_STRING   0x00000400L /* String value (same as original UUPC
-                                  configuration processor)            */
-#define B_NORMAL   0x00000800L /* Normalize backslashes to slashes in
-                                  in this variable                    */
+#define B_STRING	 0x00000400L /* String value (same as original UUPC
+											 configuration processor)				 */
+#define B_NORMAL	 0x00000800L /* Normalize backslashes to slashes in
+											 in this variable                    */
 #define B_OBSOLETE 0x00001000L /* Option is obsolete, should be
-                                  deleted                             */
-#define B_MALLOC   0x00002000L  /* Use malloc(), not newstr()         */
+											 deleted                             */
+#define B_MALLOC	 0x00002000L  /* Use malloc(), not newstr()			 */
 #define B_LONG     0x00004000L  /* Pointer is to long, not string     */
 #define B_PATH     (B_TOKEN | B_NORMAL)
-                               /* DOS Path name                       */
+										 /* DOS Path name                       */
 
 /*--------------------------------------------------------------------*/
-/*                     General defines and macros                     */
+/*                     General defines and macros							 */
 /*--------------------------------------------------------------------*/
 
-#define  MESSAGESEP "\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\n"
+#define	MESSAGESEP "\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\n"
 
-#define DCSTATUS    "hostatus"
-#define PATHS       "hostpath"
+#define DCSTATUS	  "hostatus"
+#define PATHS		  "hostpath"
 #define PERMISSIONS "permissn"
 #define SYSLOG      "syslog"
 #define ACTIVE      "active"
@@ -272,58 +273,58 @@
 #define WHITESPACE " \t\n\r"
 
 /*--------------------------------------------------------------------*/
-/*    Equality macros                                                 */
+/*    Equality macros																 */
 /*--------------------------------------------------------------------*/
 
-#define equal(a,b)               ((KWBoolean) !strcmp(a,b))
-#define equali(a,b)              ((KWBoolean) !stricmp(a,b))
-#define equalni(a,b,n)           ((KWBoolean) !strnicmp(a,b,n))
-#define equaln(a,b,n)            ((KWBoolean) !strncmp(a,b,n))
+#define equal(a,b)					((KWBoolean) !strcmp(a,b))
+#define equali(a,b)					((KWBoolean) !stricmp(a,b))
+#define equalni(a,b,n)				((KWBoolean) !strnicmp(a,b,n))
+#define equaln(a,b,n)				((KWBoolean) !strncmp(a,b,n))
 
 #ifndef __FILE__
 #error __FILE__ must be defined!!!
 #endif
 
-#define currentfile()            static char *cfnptr = __FILE__
-#define checkref(a)              { if (!a) checkptr(cfnptr,__LINE__); }
+#define currentfile()				static char *cfnptr = __FILE__
+#define checkref(a)					{ if (!a) checkptr(cfnptr,__LINE__); }
 
 #define newstr(a)                (strpool(a, cfnptr ,__LINE__))
 
 #ifdef SAFEFREE
-#define free(a)                  (safefree(a, cfnptr ,__LINE__))
+#define free(a)						(safefree(a, cfnptr ,__LINE__))
 #endif
 
 #define nil(type)               ((type *)NULL)
 
 /*--------------------------------------------------------------------*/
-/*                     Configuration table layout                     */
+/*                     Configuration table layout							 */
 /*--------------------------------------------------------------------*/
 
 typedef struct ConfigTable
-   {
-      char *sym;
-      void *loc;
-      CONFIGBITS program;
-      CONFIGBITS flag;
-   } CONFIGTABLE;
+	{
+		char *sym;
+		void *loc;
+		CONFIGBITS program;
+		CONFIGBITS flag;
+	} CONFIGTABLE;
 
 /*--------------------------------------------------------------------*/
 /*                    Boolean options table layout                    */
 /*--------------------------------------------------------------------*/
 
 typedef struct FlagTable
-   {
-      char *sym;
-      int position;
-      CONFIGBITS bits;
-   } FLAGTABLE;
+	{
+		char *sym;
+		int position;
+		CONFIGBITS bits;
+	} FLAGTABLE;
 
 /*--------------------------------------------------------------------*/
 /*                          Global variables                          */
 /*--------------------------------------------------------------------*/
 
 #ifdef __cplusplus
-   extern "C" {
+	extern "C" {
 #endif
 
 #ifdef SAFEFREE
@@ -341,7 +342,7 @@
 extern size_t rcTableSize;
 
 /*--------------------------------------------------------------------*/
-/*                        Function prototypes                         */
+/*                        Function prototypes								 */
 /*--------------------------------------------------------------------*/
 
 #ifdef SAFEFREE
@@ -351,32 +352,32 @@
 void prterror(const size_t lineno, const char *fname, const char *prefix);
 
 extern void checkptr(const char *file,
-                     const size_t line);
+							const size_t line);
 
 extern int MKDIR(const char *path);
-                              /* Make a directory              ahd */
+										/* Make a directory					ahd */
 
 extern int CHDIR(const char *path);
-                              /* Change to a directory          ahd */
+										/* Change to a directory			 ahd */
 
 int RENAME(const char *oldname, const char *newname );
 
 extern FILE *FSOPEN(const char *name,
-                   const char *mode );
+						 const char *mode );
 
 #define FOPEN( name, mode, ftype ) FSOPEN( name, mode ftype )
-                              /* Since the last two are literals,
-                                 we just concat them together for
-                                 the call                         */
+										/* Since the last two are literals,
+											we just concat them together for
+											the call                         */
 
 extern void options(char *s,
-                    SYSMODE sysmode ,
-                    FLAGTABLE *flags,
-                    KWBoolean *xflag,
-                    const size_t flagsSize );
+						  SYSMODE sysmode ,
+						  FLAGTABLE *flags,
+						  KWBoolean *xflag,
+						  const size_t flagsSize );
 
 int getargs(char *line,
-            char **flds);                                   /* ahd */
+				char **flds);												/* ahd */
 
 void printmsg(int level, char *fmt, ...);
 
@@ -389,23 +390,23 @@
 KWBoolean configure( CONFIGBITS program );
 
 KWBoolean getconfig(FILE *fp,
-                  SYSMODE sysmode,
-                  CONFIGBITS program,
-                  CONFIGTABLE *table,
-                  const size_t TableSize,
-                  FLAGTABLE *btable,
-                  const size_t btableSize);
+						SYSMODE sysmode,
+						CONFIGBITS program,
+						CONFIGTABLE *table,
+						const size_t TableSize,
+						FLAGTABLE *btable,
+						const size_t btableSize);
 
 KWBoolean processconfig(char *buff,
-                  SYSMODE sysmode,
-                  CONFIGBITS program,
-                  CONFIGTABLE *table,
-                  const size_t TableSize,
-                  FLAGTABLE *bTable,
-                  const size_t bTableSize );
+						SYSMODE sysmode,
+						CONFIGBITS program,
+						CONFIGTABLE *table,
+						const size_t TableSize,
+						FLAGTABLE *bTable,
+						const size_t bTableSize );
 
 /*--------------------------------------------------------------------*/
-/*                           Abort function                           */
+/*                           Abort function									 */
 /*--------------------------------------------------------------------*/
 
 void bugout(  const char *fname, const size_t lineno);
@@ -428,23 +429,23 @@
 /*--------------------------------------------------------------------*/
 
 #if defined(__CORE__)
-extern   char *copyright;
-extern   char *copywrong;
-extern   long *lowcore;
-#endif   /* defined(__CORE__)   */
+extern	char *copyright;
+extern	char *copywrong;
+extern	long *lowcore;
+#endif	/* defined(__CORE__)   */
 
 /*--------------------------------------------------------------------*/
-/*     This triggers a "nice" break into the debugger under BC++      */
+/*     This triggers a "nice" break into the debugger under BC++		 */
 /*--------------------------------------------------------------------*/
 
 #ifdef __TURBOC__
-#define BREAKPOINT   _asm INT 3
+#define BREAKPOINT	_asm INT 3
 #endif
 
 #ifdef __cplusplus
-   }
+	}
 #endif
 
 #else
 #error "lib.h" was already included once!
-#endif   /* ifndef __LIB */
+#endif	/* ifndef __LIB */
--- e:\uupc1.12s\source\lib\WIN32VER.H	Tue May 13 22:41:48 1997
+++ WIN32VER.H	Wed Jul 30 22:26:18 1997
@@ -1,5 +1,5 @@
 /*--------------------------------------------------------------------*/
-/*         DO NOT EDIT -- AUTOMATICALLY GENERATED BY MAKEFILE         */
+/*         DO NOT EDIT -- AUTOMATICALLY GENERATED BY MAKEFILE			 */
 /*--------------------------------------------------------------------*/
 
-#define UUPCV "1.12s"         /* UUPC/extended version number */
+#define UUPCV "1.12s.jdc"			 /* UUPC/extended version number */
--- e:\uupc1.12s\source\lib\ABSPATH.C	Sun Mar 30 22:57:48 1997
+++ ABSPATH.C	Sat Jul 26 13:25:30 1997
@@ -1,19 +1,19 @@
 /*--------------------------------------------------------------------*/
 /*       a b s p a t h . c                                            */
 /*                                                                    */
-/*       Determine if a path is absolute                              */
+/*       Determine if a path is absolute										 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*       Changes Copyright (c) 1989-1997 by Kendra Electronic         */
-/*       Wonderworks.                                                 */
+/*       Changes Copyright (c) 1989-1997 by Kendra Electronic			 */
+/*       Wonderworks.																 */
 /*                                                                    */
-/*       All rights reserved except those explicitly granted by       */
-/*       the UUPC/extended license agreement.                         */
+/*       All rights reserved except those explicitly granted by		 */
+/*       the UUPC/extended license agreement.								 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                          RCS Information                           */
+/*                          RCS Information									 */
 /*--------------------------------------------------------------------*/
 
 /*
@@ -32,36 +32,36 @@
  *
  */
 
-#include <uupcmoah.h>
+#include "uupcmoah.h"
 #include <ctype.h>
 
 /*--------------------------------------------------------------------*/
-/*       i s A b s o l u t e P a t h                                  */
+/*       i s A b s o l u t e P a t h											 */
 /*                                                                    */
-/*       Report if the argument is an absolute path                   */
+/*       Report if the argument is an absolute path						 */
 /*--------------------------------------------------------------------*/
 
 KWBoolean isAbsolutePath( const char *path)
 {
 
 /*--------------------------------------------------------------------*/
-/*     Path on current drive or network drive is always absolute      */
+/*     Path on current drive or network drive is always absolute		 */
 /*--------------------------------------------------------------------*/
 
-   if (( path[0] == '/' ) || ( path[0] == '\\' ))
-      return KWTrue;
+	if (( path[0] == '/' ) || ( path[0] == '\\' ))
+		return KWTrue;
 
 /*--------------------------------------------------------------------*/
 /*       Otherwise, must be begin with a letter colon (x:),           */
-/*       followed by a directory separator.                           */
+/*       followed by a directory separator.									 */
 /*--------------------------------------------------------------------*/
 
-   if ( ! isalpha( path[0] ) || (path[1] != ':'))
-      return KWFalse;
+	if ( ! isalpha( path[0] ) || (path[1] != ':'))
+		return KWFalse;
 
-   if (( path[2] == '/' ) || ( path[2] == '\\' ))
-      return KWTrue;
+	if (( path[2] == '/' ) || ( path[2] == '\\' ))
+		return KWTrue;
 
-   return KWFalse;
+	return KWFalse;
 
 } /* isAbsolutePath */
--- e:\uupc1.12s\source\lib\ARBMATH.C	Sun Mar 30 22:57:52 1997
+++ ARBMATH.C	Fri Jul 25 21:19:02 1997
@@ -5,15 +5,15 @@
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*       Changes Copyright (c) 1989-1997 by Kendra Electronic         */
-/*       Wonderworks.                                                 */
+/*       Changes Copyright (c) 1989-1997 by Kendra Electronic			 */
+/*       Wonderworks.																 */
 /*                                                                    */
-/*       All rights reserved except those explicitly granted by       */
-/*       the UUPC/extended license agreement.                         */
+/*       All rights reserved except those explicitly granted by		 */
+/*       the UUPC/extended license agreement.								 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                          RCS Information                           */
+/*                          RCS Information									 */
 /*--------------------------------------------------------------------*/
 
 /*
@@ -21,7 +21,7 @@
  *
  *    Revision history:
  *    $Log: arbmath.c $
- *    Revision 1.10  1997/03/31 06:58:00  ahd
+ *    Revision 1.10	1997/03/31 06:58:00	ahd
  *    Annual Copyright Update
  *
  *    Revision 1.9  1996/01/01 20:55:12  ahd
@@ -39,20 +39,20 @@
  *    Revision 1.5  1994/02/20 19:11:18  ahd
  *    IBM C/Set 2 Conversion, memory leak cleanup
  *
- *     Revision 1.3  1994/01/01  19:00:01  ahd
+ *     Revision 1.3	1994/01/01	19:00:01  ahd
  *     Annual Copyright Update
  *
- *     Revision 1.2  1993/10/09  15:46:15  rhg
+ *     Revision 1.2	1993/10/09	15:46:15  rhg
  *     ANSIify the source
  *
  */
 
 /*--------------------------------------------------------------------*/
-/*                     Standard library includes                      */
+/*                     Standard library includes							 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                    UUPC/extended include files                     */
+/*                    UUPC/extended include files							 */
 /*--------------------------------------------------------------------*/
 
 #include "uupcmoah.h"
@@ -66,7 +66,7 @@
 currentfile();
 
 /*--------------------------------------------------------------------*/
-/*    a d i v                                                         */
+/*    a d i v																			 */
 /*                                                                    */
 /*    Perform arbitary length division                                */
 /*                                                                    */
@@ -74,70 +74,70 @@
 /*--------------------------------------------------------------------*/
 
 KWBoolean adiv( unsigned char *number,
-             const unsigned divisor,
-             unsigned *remain,
-             const unsigned digits)
+				 const unsigned divisor,
+				 size_t *remain,
+				 const unsigned digits)
 {
-   unsigned subscript;
-   KWBoolean nonzero = KWFalse;
-   *remain = 0;
-
-   for ( subscript = 0; subscript < digits; subscript++)
-   {
-      unsigned digit =  *remain * 0x100 + number[subscript];
-      if ( number[subscript] )
-         nonzero = KWTrue;
-      *remain = digit % divisor;
-      number[subscript] =  (unsigned char) (digit / divisor);
-   } /* for */
-   return nonzero;
+	unsigned subscript;
+	KWBoolean nonzero = KWFalse;
+	*remain = 0;
+
+	for ( subscript = 0; subscript < digits; subscript++)
+	{
+		unsigned digit =	*remain * 0x100 + number[subscript];
+		if ( number[subscript] )
+			nonzero = KWTrue;
+		*remain = digit % divisor;
+		number[subscript] =	(unsigned char) (digit / divisor);
+	} /* for */
+	return nonzero;
 } /* div */
 
 /*--------------------------------------------------------------------*/
-/*    m u l t                                                         */
+/*    m u l t																			 */
 /*                                                                    */
 /*    Perform arbitary length multiplication                          */
 /*--------------------------------------------------------------------*/
 
 void mult(unsigned char *number,
-      const unsigned range,
-      const unsigned digits)
+		const unsigned range,
+		const unsigned digits)
 {
-   unsigned subscript = digits;
-   unsigned carry = 0;
+	unsigned subscript = digits;
+	unsigned carry = 0;
 
-   while( subscript-- > 0)
-   {
-      unsigned digit = number[subscript] * range + carry;
-      number[subscript] = (unsigned char) (digit % 0x100);
-      carry = digit / 0x100;
-   } /* while */
+	while( subscript-- > 0)
+	{
+		unsigned digit = number[subscript] * range + carry;
+		number[subscript] = (unsigned char) (digit % 0x100);
+		carry = digit / 0x100;
+	} /* while */
 
-   if ( carry != 0 )     /* Big trouble if overflow occurs   */
-      panic();
+	if ( carry != 0 )     /* Big trouble if overflow occurs	 */
+		panic();
 } /* mult */
 
 /*--------------------------------------------------------------------*/
 /*    a d d                                                           */
 /*                                                                    */
-/*    Perform arbitiary length addition                               */
+/*    Perform arbitiary length addition										 */
 /*--------------------------------------------------------------------*/
 
 void add(unsigned char *number,
-      const unsigned range,
-      const unsigned digits)
+		const unsigned range,
+		const unsigned digits)
 {
-   unsigned subscript = digits;
-   unsigned carry = range;
+	unsigned subscript = digits;
+	unsigned carry = range;
 
-   while(( carry > 0) && ( subscript-- > 0))
-   {
-      unsigned digit = number[subscript] + carry;
-      number[subscript] = (unsigned char) (digit % 0x100);
-      carry = digit / 0x100;
-   } /* while */
+	while(( carry > 0) && ( subscript-- > 0))
+	{
+		unsigned digit = number[subscript] + carry;
+		number[subscript] = (unsigned char) (digit % 0x100);
+		carry = digit / 0x100;
+	} /* while */
 
-   if ( carry != 0 )     /* Big trouble if overflow occurs   */
-      panic();
+	if ( carry != 0 )     /* Big trouble if overflow occurs	 */
+		panic();
 
 } /* add */
--- e:\uupc1.12s\source\lib\CHDIR.C	Sun Mar 30 22:58:12 1997
+++ CHDIR.C	Sun Jul 27 17:34:38 1997
@@ -1,21 +1,21 @@
 /*--------------------------------------------------------------------*/
-/*       c h d i r . c                                                */
+/*       c h d i r . c																 */
 /*                                                                    */
-/*       Change directory for UUPC/extended; builds directory tree    */
-/*       if needed and saves the nane of the new directory in         */
-/*       E_cwd at no extra charge.                                    */
+/*       Change directory for UUPC/extended; builds directory tree	 */
+/*       if needed and saves the nane of the new directory in			 */
+/*       E_cwd at no extra charge.												 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*       Changes Copyright (c) 1989-1997 by Kendra Electronic         */
-/*       Wonderworks.                                                 */
+/*       Changes Copyright (c) 1989-1997 by Kendra Electronic			 */
+/*       Wonderworks.																 */
 /*                                                                    */
-/*       All rights reserved except those explicitly granted by       */
-/*       the UUPC/extended license agreement.                         */
+/*       All rights reserved except those explicitly granted by		 */
+/*       the UUPC/extended license agreement.								 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                          RCS Information                           */
+/*                          RCS Information									 */
 /*--------------------------------------------------------------------*/
 
 /*
@@ -23,16 +23,16 @@
  *
  *    Revision history:
  *    $Log: chdir.c $
- *    Revision 1.13  1997/03/31 06:58:20  ahd
+ *    Revision 1.13	1997/03/31 06:58:20	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.12  1996/01/01 20:50:06  ahd
+ *    Revision 1.12	1996/01/01 20:50:06	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.11  1995/02/14 04:38:42  ahd
+ *    Revision 1.11	1995/02/14 04:38:42	ahd
  *    Correct problems with directory processing under NT
  *
- *    Revision 1.10  1995/02/12 23:35:59  ahd
+ *    Revision 1.10	1995/02/12 23:35:59	ahd
  *    'compiler
  *
  *    Revision 1.9  1995/01/30 04:03:57  dmwatt
@@ -49,7 +49,11 @@
 #include "uupcmoah.h"
 
 #include <ctype.h>
+#ifdef __GCC__
+#include <stdlib.h>
+#else
 #include <direct.h>
+#endif
 
 #ifdef WIN32
 #include <windows.h>
@@ -68,7 +72,7 @@
 currentfile();
 
 /*--------------------------------------------------------------------*/
-/*       C H D I R                                                    */
+/*       C H D I R																	 */
 /*                                                                    */
 /*       Like chdir() but also change drives and create the           */
 /*       directory if necessary.                                      */
@@ -77,97 +81,101 @@
 int CHDIR(const char *path)
 {
 
-   int result;
-   int originalDrive = getDrive( NULL );  /* Remember should CD fail */
-   int newDrive = originalDrive;
+	int result;
+	int originalDrive = getDrive( NULL );	/* Remember should CD fail */
+	int newDrive = originalDrive;
 
-   if (*path == '\0')
-      return 0;
+	if (*path == '\0')
+		return 0;
 
 /*--------------------------------------------------------------------*/
 /*       Change to the new drive, except under NT (which can swap     */
-/*       drives when it changes directories in changedir()            */
+/*       drives when it changes directories in changedir()				 */
 /*--------------------------------------------------------------------*/
 
-   if (path[1] == ':')
-   {
-      if (isalpha(*path))
-      {
-         newDrive = toupper(*path) - 'A' + 1;
+	if (path[1] == ':')
+	{
+		if (isalpha(*path))
+		{
+			newDrive = toupper(*path) - 'A' + 1;
 
-         if (_chdrive( newDrive ))
-            return -1;                 /* Return if failure          */
+			if (_chdrive( newDrive ))
+				return -1;						/* Return if failure          */
 
-      } /* if */
-      else {
+		} /* if */
+		else {
 
-         printmsg(0,"changedir: Drive letter is not alphabetic: %s",
-                     path );
+			printmsg(0,"changedir: Drive letter is not alphabetic: %s",
+							path );
 
-         return -1;
+			return -1;
 
-      } /* else */
+		} /* else */
 
-   } /* if */
+	} /* if */
 
 /*--------------------------------------------------------------------*/
-/*        Try to change directories, returning if successful          */
+/*        Try to change directories, returning if successful			 */
 /*--------------------------------------------------------------------*/
 
-   if (!changedir( path, newDrive ))
-      return 0;
+	if (!changedir( path, newDrive ))
+		return 0;
 
 /*--------------------------------------------------------------------*/
-/*                      Try making the directory                      */
+/*                      Try making the directory							 */
 /*--------------------------------------------------------------------*/
 
-   MKDIR(path);
+	MKDIR(path);
 
 /*--------------------------------------------------------------------*/
 /*                   Change to the directory again                    */
 /*--------------------------------------------------------------------*/
 
-   result = changedir(path, newDrive );
+	result = changedir(path, newDrive );
 
-   if ( result )
-   {
-      printerr("chdir");         /* Report the error, real problem   */
+	if ( result )
+	{
+		printerr("chdir");			/* Report the error, real problem	*/
 
-      _chdrive( originalDrive - 'A' + 1); /* Return to original drive   */
+		_chdrive( originalDrive - 'A' + 1); /* Return to original drive	*/
 
-   }
+	}
 
-   return result;
+	return result;
 
 } /* CHDIR */
 
 /*--------------------------------------------------------------------*/
 /*       c h a n g e d i r                                            */
 /*                                                                    */
-/*       Like chdir() but also saves the path we changed into         */
+/*       Like chdir() but also saves the path we changed into			 */
 /*--------------------------------------------------------------------*/
 
 static int changedir(const char *path, const int drive)
 {
 
-   int result = chdir((char *) path);     /* Perform the change      */
+	int result = chdir((char *) path);		/* Perform the change		*/
 
-   if ( ! result )                  /* Did it work?                  */
-   {                                /* Yes --> Save directory name   */
+	if ( ! result )						/* Did it work?						*/
+	{											/* Yes --> Save directory name	*/
 
-      static char savePath[FILENAME_MAX];
+		static char savePath[FILENAME_MAX];
 
-      _getdcwd(drive, savePath, sizeof savePath);
+#ifdef __GCC__
+		_getcwd2(savePath, sizeof savePath);
+#else
+		_getdcwd(drive, savePath, sizeof savePath);
+#endif
 
-      E_cwd = savePath;             /* Yes --> Save directory        */
+		E_cwd = savePath;             /* Yes --> Save directory			*/
 
-      if ( isalpha( *E_cwd ) && islower( *E_cwd ))
-         *E_cwd = (char) toupper( *E_cwd );
-                                    /* Insure driver letter is upper
-                                       case                          */
+		if ( isalpha( *E_cwd ) && islower( *E_cwd ))
+			*E_cwd = (char) toupper( *E_cwd );
+												/* Insure driver letter is upper
+													case									*/
 
-   }
+	}
 
-   return result;
+	return result;
 
 } /* changedir */
--- e:\uupc1.12s\source\lib\CONFIGUR.C	Sun May 11 13:15:50 1997
+++ CONFIGUR.C	Sun Aug 10 20:58:08 1997
@@ -1,19 +1,19 @@
 /*--------------------------------------------------------------------*/
-/*    c o n f i g u r . c                                             */
+/*    c o n f i g u r . c															 */
 /*                                                                    */
-/*    Support routines for UUPC/extended                              */
+/*    Support routines for UUPC/extended										 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*    Changes Copyright (c) 1989-1997 by Kendra Electronic            */
-/*    Wonderworks.                                                    */
+/*    Changes Copyright (c) 1989-1997 by Kendra Electronic				 */
+/*    Wonderworks.																	 */
 /*                                                                    */
-/*    All rights reserved except those explicitly granted by the      */
+/*    All rights reserved except those explicitly granted by the		 */
 /*    UUPC/extended license agreement.                                */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                          RCS Information                           */
+/*                          RCS Information									 */
 /*--------------------------------------------------------------------*/
 
 /*
@@ -21,107 +21,107 @@
  *
  *    Revision history:
  *    $Log: configur.c $
- *    Revision 1.78  1997/05/11 18:15:50  ahd
+ *    Revision 1.78	1997/05/11 18:15:50	ahd
  *    Allow faster SMTP delivery via fastsmtp flag
  *    Move TCP/IP dependent code from rmail.c to deliver.c
  *    Allow building rmail without SMTP or TCP/IP support
  *
- *    Revision 1.77  1997/05/11 04:27:40  ahd
+ *    Revision 1.77	1997/05/11 04:27:40	ahd
  *    SMTP client support for RMAIL/UUXQT
  *
- *    Revision 1.76  1997/03/31 06:58:28  ahd
+ *    Revision 1.76	1997/03/31 06:58:28	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.75  1996/09/24 15:22:22  ahd
+ *    Revision 1.75	1996/09/24 15:22:22	ahd
  *    *** empty log message ***
  *
- *    Revision 1.74  1996/01/07 14:14:40  ahd
+ *    Revision 1.74	1996/01/07 14:14:40	ahd
  *    Support for external access to configuration table data by NT regsetup
  *
- *    Revision 1.73  1996/01/04 04:00:46  ahd
+ *    Revision 1.73	1996/01/04 04:00:46	ahd
  *    Use sorted list of boolean options with binary search and computed
  *    table size.
  *
- *    Revision 1.72  1996/01/02 00:00:24  ahd
+ *    Revision 1.72	1996/01/02 00:00:24	ahd
  *    Break out search loop for configuration file keywords from
  *    processing of them.
  *    Use proper binary search for configuration file keywords rather
  *    than lineaer search.  Also includes pre-computing size of configuration
  *    tables.
  *
- *    Revision 1.71  1995/08/27 23:30:21  ahd
+ *    Revision 1.71	1995/08/27 23:30:21	ahd
  *    Change variable case
  *
- *    Revision 1.70  1995/04/02 00:01:39  ahd
+ *    Revision 1.70	1995/04/02 00:01:39	ahd
  *    Add option for Kai Uwe Rommel to suppress display of UUPC/extended
  *    version, system name, etc. at remote login time.
  *
- *    Revision 1.69  1995/03/23 01:30:34  ahd
+ *    Revision 1.69	1995/03/23 01:30:34	ahd
  *    Load the mailserv variable for any news program which could generate
  *    a SYSTEMS file.
  *
- *    Revision 1.68  1995/03/08 02:58:08  ahd
+ *    Revision 1.68	1995/03/08 02:58:08	ahd
  *    Delete redundant boolean options
  *
- *    Revision 1.67  1995/02/25 18:21:44  ahd
+ *    Revision 1.67	1995/02/25 18:21:44	ahd
  *    Correct selected flags for config variables
  *
- *    Revision 1.66  1995/02/24 00:37:28  ahd
+ *    Revision 1.66	1995/02/24 00:37:28	ahd
  *    Optimize which variables are included where
  *
- *    Revision 1.65  1995/02/21 03:30:52  ahd
+ *    Revision 1.65	1995/02/21 03:30:52	ahd
  *    More compiler warning cleanup, drop selected messages at compile
  *    time if not debugging.
  *
- *    Revision 1.64  1995/02/20 18:54:08  ahd
+ *    Revision 1.64	1995/02/20 18:54:08	ahd
  *    news panic support
  *
- *    Revision 1.63  1995/02/20 17:28:43  ahd
+ *    Revision 1.63	1995/02/20 17:28:43	ahd
  *    Add rnewspanic option
  *    Various compiler warning clean up
  *
- *    Revision 1.62  1995/02/20 00:38:04  ahd
+ *    Revision 1.62	1995/02/20 00:38:04	ahd
  *    news index caching support
  *
- *    Revision 1.61  1995/02/12 23:35:59  ahd
+ *    Revision 1.61	1995/02/12 23:35:59	ahd
  *    'compiler
  *
- *    Revision 1.60  1995/01/29 16:43:03  ahd
+ *    Revision 1.60	1995/01/29 16:43:03	ahd
  *    IBM C/Set compiler warnings
  *
- *    Revision 1.59  1995/01/29 14:07:59  ahd
+ *    Revision 1.59	1995/01/29 14:07:59	ahd
  *    Clean up most IBM C/Set Compiler Warnings
  *
- *    Revision 1.58  1995/01/28 22:08:10  ahd
+ *    Revision 1.58	1995/01/28 22:08:10	ahd
  *    Correct use of TZ variable from within UUPC configuration file
  *
- *    Revision 1.57  1995/01/15 19:48:35  ahd
+ *    Revision 1.57	1995/01/15 19:48:35	ahd
  *    Allow active file to be optional
  *    Delete fullbatch global option
  *    Add "local" and "batch" flags to SYS structure for news
  *
- *    Revision 1.56  1995/01/07 16:12:03  ahd
+ *    Revision 1.56	1995/01/07 16:12:03	ahd
  *    Change KWBoolean to KWBoolean to avoid VC++ 2.0 conflict
  *
- *    Revision 1.55  1995/01/07 15:43:07  ahd
+ *    Revision 1.55	1995/01/07 15:43:07	ahd
  *    Add in-memory file flag
  *
- *    Revision 1.54  1995/01/02 05:03:27  ahd
+ *    Revision 1.54	1995/01/02 05:03:27	ahd
  *    Pass 2 of integrating SYS file support from Mike McLagan
  *
- *    Revision 1.53  1994/12/31 03:51:01  ahd
+ *    Revision 1.53	1994/12/31 03:51:01	ahd
  *    First pass of integrating Mike McLagan's news SYS file suuport
  *
- *    Revision 1.52  1994/12/31 03:41:08  ahd
+ *    Revision 1.52	1994/12/31 03:41:08	ahd
  *    First pass of integrating Mike McLagan's news SYS file suuport
  *
- *    Revision 1.51  1994/12/27 20:47:55  ahd
+ *    Revision 1.51	1994/12/27 20:47:55	ahd
  *    Smoother call grading'
  *
- *    Revision 1.50  1994/12/22 00:07:46  ahd
+ *    Revision 1.50	1994/12/22 00:07:46	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.49  1994/12/09 03:42:09  ahd
+ *    Revision 1.49	1994/12/09 03:42:09	ahd
  *    All suppressbeep support to allow NOT making any sound
  *
  *     Revision 1.48  1994/05/24  03:44:04  ahd
@@ -239,33 +239,33 @@
  *     Revision 1.10  1993/04/15  03:17:21  ahd
  *     Add bounce system option
  *
- *     Revision 1.9  1993/04/11  00:31:31  dmwatt
+ *     Revision 1.9	1993/04/11	00:31:31  dmwatt
  *     Global edits for year, TEXT, etc.
  *
- *     Revision 1.8  1993/04/05  04:32:19  ahd
+ *     Revision 1.8	1993/04/05	04:32:19  ahd
  *     Set timezone, windows input mode in common routine
  *
- *     Revision 1.7  1993/04/04  04:57:01  ahd
+ *     Revision 1.7	1993/04/04	04:57:01  ahd
  *     Default configuration directory from UUPCSYSRC
  *     Default system directories from Configuration directory
  *
- *     Revision 1.6  1993/03/06  22:48:23  ahd
+ *     Revision 1.6	1993/03/06	22:48:23  ahd
  *     Don't fall off end of shorter tables
  *
- *     Revision 1.5  1993/01/23  19:08:09  ahd
+ *     Revision 1.5	1993/01/23	19:08:09  ahd
  *     Add Windows/NT to allowed environments
  *
- * Revision 1.4  1992/12/01  04:37:03  ahd
+ * Revision 1.4  1992/12/01  04:37:03	ahd
  * Add SpeedOverMemory
  *
- * Revision 1.3  1992/11/22  20:58:55  ahd
+ * Revision 1.3  1992/11/22  20:58:55	ahd
  * Normalize directories as read
  * Use strpool to allocate const strings
  *
- * Revision 1.2  1992/11/19  02:56:47  ahd
+ * Revision 1.2  1992/11/19  02:56:47	ahd
  * drop rcsid
  *
- * Revision 1.1  1992/11/16  05:00:26  ahd
+ * Revision 1.1  1992/11/16  05:00:26	ahd
  * Initial revision
  *
  */
@@ -277,7 +277,7 @@
 #include <io.h>
 
 /*--------------------------------------------------------------------*/
-/*                    UUPC/extended include files                     */
+/*                    UUPC/extended include files							 */
 /*--------------------------------------------------------------------*/
 
 #include "timestmp.h"
@@ -295,7 +295,7 @@
 
 currentfile();
 
-KWBoolean bflag[F_LAST];       /* Initialized to zero by compiler      */
+KWBoolean bflag[F_LAST];		 /* Initialized to zero by compiler      */
 
 char **E_internal = NULL;
 char *E_nickname = NULL;
@@ -341,25 +341,25 @@
 char *E_xqtRootDir = NULL;
 char *E_vmsQueueDir = NULL;
 char *E_vmail = NULL;
-char **E_ignoreList;           /* Headers not displayed by print      */
-char **E_replyToList;          /* Primary Addr used to reply to mail  */
-char E_firstGrade = 'C';       /* First class (and above) UUCICO
-                                  searches for                        */
+char **E_ignoreList;           /* Headers not displayed by print		 */
+char **E_replyToList;			 /* Primary Addr used to reply to mail  */
+char E_firstGrade = 'C';		 /* First class (and above) UUCICO
+											 searches for								 */
 
 char E_mailGrade = 'C';        /* Class mail is transferred at        */
 char E_newsGrade = 'n';        /* Class news is transferred at        */
 
-KEWSHORT E_timeoutSMTP = 60;   /* SMTP read timeout for rmail         */
+KEWSHORT E_timeoutSMTP = 60;	 /* SMTP read timeout for rmail			 */
 KEWSHORT E_maxhops = 20;
-KEWSHORT E_maxuuxqt = 0;      /* Max length of remote command line   */
+KEWSHORT E_maxuuxqt = 0;		/* Max length of remote command line	*/
 
 #ifdef BIT32ENV
-KEWSHORT E_newsCache = 128;   /* Pages of news index to cache        */
+KEWSHORT E_newsCache = 128;	/* Pages of news index to cache			*/
 #else
-KEWSHORT E_newsCache = 4;     /* Pages of news index to cache        */
+KEWSHORT E_newsCache = 4;		/* Pages of news index to cache			*/
 #endif
 
-long     E_batchsize = 65536L;
+long		E_batchsize = 65536L;
 
 char *E_tz = NULL;
 
@@ -368,17 +368,17 @@
 /*--------------------------------------------------------------------*/
 
 typedef enum {
-      ENV_UNKNOWN    = 0x0001,
-      ENV_DOS        = 0x0002,
-      ENV_BIT32      = 0x0004,
-      ENV_BIT16      = 0x0008,
-      ENV_OS2        = 0x0010,
-      ENV_OS2_32BIT  = 0x0020,
-      ENV_OS2_16BIT  = 0x0040,
-      ENV_WIN        = 0x0080,
-      ENV_WIN_32BIT  = 0x0100,
-      ENV_WIN_16BIT  = 0x0200
-      } ENV_TYPE;
+		ENV_UNKNOWN    = 0x0001,
+		ENV_DOS			= 0x0002,
+		ENV_BIT32		= 0x0004,
+		ENV_BIT16		= 0x0008,
+		ENV_OS2			= 0x0010,
+		ENV_OS2_32BIT	= 0x0020,
+		ENV_OS2_16BIT	= 0x0040,
+		ENV_WIN			= 0x0080,
+		ENV_WIN_32BIT	= 0x0100,
+		ENV_WIN_16BIT	= 0x0200
+		} ENV_TYPE;
 
 #ifdef WIN32
 static ENV_TYPE active_env = ENV_WIN_32BIT | ENV_WIN | ENV_BIT32;
@@ -400,127 +400,127 @@
 
 /*--------------------------------------------------------------------*/
 /*       UUPC.RC/personal.RC configuration variables.  This table     */
-/*       MUST be kept sorted to allow a binary search.                */
+/*       MUST be kept sorted to allow a binary search.					 */
 /*--------------------------------------------------------------------*/
 
 CONFIGTABLE rcTable[] = {
-   {"aliases",      &E_nickname,     B_MUA,     B_TOKEN },
-   {"altsignature", &E_altsignature, B_MUA,     B_TOKEN },
-   {"anonymouslogin", &E_anonymous,  (B_ALL & ~ B_MAIL), B_GLOBAL|B_TOKEN },
-   {"archivedir",   &E_archivedir,   B_OBSOLETE,B_GLOBAL|B_PATH },
-   {"backupext",    &E_backup,       B_MUA | B_NEWS,     B_TOKEN },
-   {"banner",       &E_banner,       B_UUCICO,  B_GLOBAL|B_PATH },
-   {"batchsize",    &E_batchsize,    B_SENDBATS,B_GLOBAL|B_LONG },
-   {"charset",      &E_charset,      B_SPOOL,   B_TOKEN|B_GLOBAL },
-   {"compress",     &E_compress,     B_SENDBATS,B_GLOBAL|B_STRING },
-   {"confdir",      &E_confdir,      B_ALL,     B_GLOBAL|B_PATH },
-   {"domain",       &E_domain,       B_ALL,     B_REQUIRED|B_GLOBAL|B_TOKEN },
-   {"editor",       &E_editor,       B_MUA,     B_STRING },
-   {"filesent",     &E_filesent,     B_MUA,     B_TOKEN },
-   {"firstGrade",   &E_firstGrade,   B_UUCICO,  B_CHAR },
-   {"folders",      0     ,          B_MUSH,    B_PATH  },
-   {"fromdomain",   &E_fdomain,      B_ALL,     B_GLOBAL|B_TOKEN },
-   {"home",         &E_homedir,      B_ALL,     B_PATH|B_REQUIRED },
-   {"ignore",       &E_ignoreList,   B_MUA,     B_LIST },
-   {"inmodem",      &E_inmodem,      B_UUCICO,  B_GLOBAL|B_TOKEN },
-   {"internalcommands", &E_internal, B_ALL,     B_GLOBAL|B_LIST },
-   {"localdomain",  &E_localdomain,  B_MAIL,    B_GLOBAL|B_TOKEN   },
-   {"mailbox",      &E_mailbox,      B_ALL,     B_REQUIRED|B_TOKEN },
-   {"maildir",      &E_maildir,      B_MAIL,    B_GLOBAL|B_PATH },
-   {"mailext",      &E_mailext,      B_MAIL,    B_TOKEN },
-   {"mailgrade",    &E_mailGrade,    B_MTA,     B_CHAR },
-   {"mailserv",     &E_mailserv,     B_MAIL|B_NEWS,    B_REQUIRED|B_GLOBAL|B_TOKEN },
-   {"maximumhops",  &E_maxhops,      B_MTA,     B_SHORT | B_GLOBAL },
-   {"maximumuuxqt", &E_maxuuxqt,     B_MTA,     B_SHORT | B_GLOBAL },
-   {"motd",         &E_motd,         B_UUCICO,  B_GLOBAL|B_PATH },
-   {"mushdir",      0,               B_MUSH,    B_GLOBAL|B_PATH },
-   {"name",         &E_name,         B_INEWS|B_MAIL, B_REQUIRED|B_STRING },
-   {"newscache",    &E_newsCache,    B_NEWS,    B_SHORT },
-   {"newsdir",      &E_newsdir,      B_NEWS,    B_GLOBAL|B_PATH },
-   {"newsgrade",    &E_newsGrade,    B_NEWS,    B_CHAR },
-   {"newsserv",     &E_newsserv,     B_NEWS,    B_GLOBAL|B_TOKEN },
-   {"nickname",     &E_nickname,     B_MUA,     B_TOKEN },
-   {"nodename",     &E_nodename,     B_ALL,     B_REQUIRED|B_GLOBAL|B_TOKEN },
-   {"options",      bflag,           B_ALL,     B_BOOLEAN },
-   {"organization", &E_organization, B_INEWS|B_MAIL, B_STRING },
-   {"pager",        &E_pager,        B_MUA, B_STRING },
-   {"passwd",       &E_passwd,       B_ALL,     B_GLOBAL|B_PATH },
-   {"path",         &E_uuxqtpath,    B_UUXQT,   B_STRING|B_GLOBAL },
-   {"permissions",  &E_permissions,  B_UUCICO|B_UUXQT,   B_GLOBAL|B_PATH },
-   {"postmaster",   &E_postmaster,   B_ALL,     B_REQUIRED|B_GLOBAL|B_TOKEN },
-   {"priority",     0,               B_OBSOLETE  },
-   {"prioritydelta",0,               B_OBSOLETE  },
-   {"pubdir",       &E_pubdir,       B_UUCICO|B_UUXQT,   B_GLOBAL|B_PATH },
-   {"replyto",      &E_replyto,      B_NEWS|B_MAIL, B_TOKEN },
-   {"replytolist",  &E_replyToList,  B_MUA,     B_LIST },
-   {"rmail",        0,               B_OBSOLETE  },
-   {"rnews",        0,               B_OBSOLETE  },
-   {"signature",    &E_signature,    B_NEWS|B_MUA, B_TOKEN },
-   {"spooldir",     &E_spooldir,     B_ALL,     B_GLOBAL|B_PATH },
-   {"systems",      &E_systems,      B_ALL,     B_GLOBAL|B_PATH },
-   {"tempdir",      &E_tempdir,      B_ALL,     B_GLOBAL|B_PATH },
-   {"timeoutsmtp",  &E_timeoutSMTP,  B_MTA,     B_SHORT },
-   {"tz",           &E_tz,           B_ALL,     B_TOKEN },
-   {"uncompress",   &E_uncompress,   B_RNEWS,   B_GLOBAL|B_STRING  },
-   {"version",      &E_version,      B_INSTALL, B_TOKEN },
-   {"vmail",        &E_vmail,        B_MTA,     B_PATH },
-   {"vmsqueuedir",  &E_vmsQueueDir,  B_MTA,     B_PATH },
-   {"xqtrootdir",   &E_xqtRootDir,   B_UUXQT,   B_PATH }
+	{"aliases",      &E_nickname,     B_MUA,		B_TOKEN },
+	{"altsignature", &E_altsignature, B_MUA,		B_TOKEN },
+	{"anonymouslogin", &E_anonymous,  (B_ALL & ~ B_MAIL), B_GLOBAL|B_TOKEN },
+	{"archivedir",   &E_archivedir,	 B_OBSOLETE,B_GLOBAL|B_PATH },
+	{"backupext",	  &E_backup,		 B_MUA|B_NEWS|B_DBZ,     B_TOKEN },
+	{"banner",		  &E_banner,		 B_UUCICO,	B_GLOBAL|B_PATH },
+	{"batchsize",	  &E_batchsize,	 B_SENDBATS,B_GLOBAL|B_LONG },
+	{"charset",      &E_charset,		 B_SPOOL,	B_TOKEN|B_GLOBAL },
+	{"compress",	  &E_compress,     B_SENDBATS,B_GLOBAL|B_STRING },
+	{"confdir",      &E_confdir,		 B_ALL,		B_GLOBAL|B_PATH },
+	{"domain",		  &E_domain,		 B_ALL,		B_REQUIRED|B_GLOBAL|B_TOKEN },
+	{"editor",		  &E_editor,		 B_MUA,		B_STRING },
+	{"filesent",	  &E_filesent,     B_MUA,		B_TOKEN },
+	{"firstGrade",   &E_firstGrade,	 B_UUCICO,	B_CHAR },
+	{"folders",      0	  ,			 B_MUSH,    B_PATH  },
+	{"fromdomain",   &E_fdomain,		 B_ALL,		B_GLOBAL|B_TOKEN },
+	{"home",         &E_homedir,		 B_ALL,		B_PATH|B_REQUIRED },
+	{"ignore",		  &E_ignoreList,	 B_MUA,		B_LIST },
+	{"inmodem",      &E_inmodem,		 B_UUCICO,	B_GLOBAL|B_TOKEN },
+	{"internalcommands", &E_internal, B_ALL,		B_GLOBAL|B_LIST },
+	{"localdomain",  &E_localdomain,  B_MAIL,    B_GLOBAL|B_TOKEN	 },
+	{"mailbox",      &E_mailbox,		 B_ALL,		B_REQUIRED|B_TOKEN },
+	{"maildir",      &E_maildir,		 B_MAIL,    B_GLOBAL|B_PATH },
+	{"mailext",      &E_mailext,		 B_MAIL,    B_TOKEN },
+	{"mailgrade",	  &E_mailGrade,	 B_MTA,		B_CHAR },
+	{"mailserv",	  &E_mailserv,     B_MAIL|B_NEWS|B_DBZ,	 B_REQUIRED|B_GLOBAL|B_TOKEN },
+	{"maximumhops",  &E_maxhops,		 B_MTA,		B_SHORT | B_GLOBAL },
+	{"maximumuuxqt", &E_maxuuxqt,     B_MTA,		B_SHORT | B_GLOBAL },
+	{"motd",         &E_motd,			 B_UUCICO,	B_GLOBAL|B_PATH },
+	{"mushdir",      0,					 B_MUSH,    B_GLOBAL|B_PATH },
+	{"name",         &E_name,			 B_INEWS|B_MAIL, B_REQUIRED|B_STRING },
+	{"newscache",	  &E_newsCache,	 B_NEWS|B_DBZ,    B_SHORT },
+	{"newsdir",      &E_newsdir,		 B_NEWS|B_DBZ,    B_GLOBAL|B_PATH },
+	{"newsgrade",	  &E_newsGrade,	 B_NEWS|B_DBZ,    B_CHAR },
+	{"newsserv",	  &E_newsserv,     B_NEWS|B_DBZ,    B_GLOBAL|B_TOKEN },
+	{"nickname",	  &E_nickname,     B_MUA,		B_TOKEN },
+	{"nodename",	  &E_nodename,     B_ALL,		B_REQUIRED|B_GLOBAL|B_TOKEN },
+	{"options",      bflag,           B_ALL,		B_BOOLEAN },
+	{"organization", &E_organization, B_INEWS|B_MAIL, B_STRING },
+	{"pager",		  &E_pager,        B_MUA, B_STRING },
+	{"passwd",		  &E_passwd,		 B_ALL,		B_GLOBAL|B_PATH },
+	{"path",         &E_uuxqtpath,	 B_UUXQT,	B_STRING|B_GLOBAL },
+	{"permissions",  &E_permissions,  B_UUCICO|B_UUXQT,	B_GLOBAL|B_PATH },
+	{"postmaster",   &E_postmaster,	 B_ALL,		B_REQUIRED|B_GLOBAL|B_TOKEN },
+	{"priority",	  0,					 B_OBSOLETE  },
+	{"prioritydelta",0,					 B_OBSOLETE  },
+	{"pubdir",		  &E_pubdir,		 B_UUCICO|B_UUXQT,	B_GLOBAL|B_PATH },
+	{"replyto",      &E_replyto,		 B_NEWS|B_DBZ|B_MAIL, B_TOKEN },
+	{"replytolist",  &E_replyToList,  B_MUA,		B_LIST },
+	{"rmail",		  0,					 B_OBSOLETE  },
+	{"rnews",		  0,					 B_OBSOLETE  },
+	{"signature",	  &E_signature,	 B_NEWS|B_DBZ|B_MUA, B_TOKEN },
+	{"spooldir",	  &E_spooldir,     B_ALL,		B_GLOBAL|B_PATH },
+	{"systems",      &E_systems,		 B_ALL,		B_GLOBAL|B_PATH },
+	{"tempdir",      &E_tempdir,		 B_ALL,		B_GLOBAL|B_PATH },
+	{"timeoutsmtp",  &E_timeoutSMTP,  B_MTA,		B_SHORT },
+	{"tz",			  &E_tz,           B_ALL,		B_TOKEN },
+	{"uncompress",   &E_uncompress,	 B_RNEWS,	B_GLOBAL|B_STRING  },
+	{"version",      &E_version,		 B_INSTALL, B_TOKEN },
+	{"vmail",		  &E_vmail,        B_MTA,		B_PATH },
+	{"vmsqueuedir",  &E_vmsQueueDir,  B_MTA,		B_PATH },
+	{"xqtrootdir",   &E_xqtRootDir,	 B_UUXQT,	B_PATH }
 }; /* table */
 
 size_t rcTableSize = (sizeof rcTable / sizeof (CONFIGTABLE));
 
 /*--------------------------------------------------------------------*/
-/*               Boolean options shared by all programs               */
+/*               Boolean options shared by all programs					 */
 /*--------------------------------------------------------------------*/
 
 FLAGTABLE configFlags[] = {
  { "askcc",                   F_ASKCC,                 B_LOCAL},
  { "autoedit",                F_AUTOEDIT,              B_LOCAL},
  { "autoinclude",             F_AUTOINCLUDE,           B_LOCAL},
- { "autoprint",               F_AUTOPRINT,             B_LOCAL},
+ { "autoprint",					F_AUTOPRINT,				 B_LOCAL},
  { "autosign",                F_AUTOSIGN,              B_LOCAL},
- { "backup",                  F_BACKUP,                B_LOCAL},
- { "bang",                    F_BANG,                  B_GLOBAL},
- { "bounce",                  F_BOUNCE,                B_GLOBAL},
- { "collect",                 F_COLLECTSTATS,          B_GLOBAL},
- { "directory",               F_DIRECT,                B_GLOBAL},
- { "doskey",                  F_DOSKEY,                B_LOCAL},
- { "dot",                     F_DOT,                   B_LOCAL},
- { "escape",                  F_ESCAPE,                B_GLOBAL},
- { "expert",                  F_EXPERT,                B_LOCAL},
- { "fastnews",                F_NEWSRUN,               B_GLOBAL},
+ { "backup",						F_BACKUP,					 B_LOCAL},
+ { "bang",							F_BANG,						 B_GLOBAL},
+ { "bounce",						F_BOUNCE,					 B_GLOBAL},
+ { "collect",						F_COLLECTSTATS,			 B_GLOBAL},
+ { "directory",					F_DIRECT,					 B_GLOBAL},
+ { "doskey",						F_DOSKEY,					 B_LOCAL},
+ { "dot",							F_DOT,						 B_LOCAL},
+ { "escape",						F_ESCAPE,					 B_GLOBAL},
+ { "expert",						F_EXPERT,					 B_LOCAL},
+ { "fastnews",                F_NEWSRUN,					 B_GLOBAL},
  { "fastsmtp",                F_FASTSMTP,              B_LOCAL},
- { "forwardsave",             F_SAVERESENT,            B_LOCAL},
- { "fromsep",                 F_FROMSEP,               B_LOCAL},
- { "honorcontrol",            F_HONORCTRL,             B_GLOBAL},
- { "honordebug",              F_HONORDEBUG,            B_GLOBAL},
- { "imfile",                  F_IMFILE,                B_LOCAL},
+ { "forwardsave",             F_SAVERESENT,				 B_LOCAL},
+ { "fromsep",						F_FROMSEP,					 B_LOCAL},
+ { "honorcontrol",				F_HONORCTRL,				 B_GLOBAL},
+ { "honordebug",					F_HONORDEBUG,				 B_GLOBAL},
+ { "imfile",						F_IMFILE,					 B_LOCAL},
  { "kanji",                   F_KANJI,                 B_GLOBAL},
  { "longname",                F_LONGNAME,              B_GLOBAL},
- { "monocase",                F_ONECASE,               B_GLOBAL},
- { "multiqueue",              F_MULTI,                 B_GLOBAL},
- { "multitask",               F_MULTITASK,             B_GLOBAL},
- { "newspanic",               F_NEWSPANIC,             B_GLOBAL},
- { "nns",                     F_NNS,                   B_GLOBAL},
+ { "monocase",                F_ONECASE,					 B_GLOBAL},
+ { "multiqueue",					F_MULTI,                 B_GLOBAL},
+ { "multitask",					F_MULTITASK,				 B_GLOBAL},
+ { "newspanic",					F_NEWSPANIC,				 B_GLOBAL},
+ { "nns",							F_NNS,						 B_GLOBAL},
  { "pager",                   F_PAGER,                 B_LOCAL},
  { "purge",                   F_PURGE,                 B_LOCAL},
- { "save",                    F_SAVE,                  B_LOCAL},
- { "senddebug",               F_SENDDEBUG,             B_GLOBAL},
- { "shortfrom",               F_SHORTFROM,             B_GLOBAL},
- { "showspool",               F_SHOWSPOOL,             B_GLOBAL},
+ { "save",							F_SAVE,						 B_LOCAL},
+ { "senddebug",					F_SENDDEBUG,				 B_GLOBAL},
+ { "shortfrom",					F_SHORTFROM,				 B_GLOBAL},
+ { "showspool",					F_SHOWSPOOL,				 B_GLOBAL},
  { "snews",                   F_SNEWS,                 B_GLOBAL},
- { "speedovermemory",         F_SPEEDOVERMEMORY,       B_LOCAL},
- { "suppressbeep",            F_SUPPRESSBEEP,          B_LOCAL},
+ { "speedovermemory",			F_SPEEDOVERMEMORY,		 B_LOCAL},
+ { "suppressbeep",				F_SUPPRESSBEEP,			 B_LOCAL},
  { "suppresscopyright",       F_SUPPRESSCOPYRIGHT,     B_LOCAL},
- { "suppressemptypassword",   F_SUPPRESSEMPTYPASSWORD, B_GLOBAL},
- { "suppressfrom",            F_SUPPRESSFROM,          B_GLOBAL},
+ { "suppressemptypassword",	F_SUPPRESSEMPTYPASSWORD, B_GLOBAL},
+ { "suppressfrom",				F_SUPPRESSFROM,			 B_GLOBAL},
  { "suppresslogininfo",       F_SUPPRESSLOGININFO,     B_GLOBAL},
- { "symmetricgrades",         F_SYMMETRICGRADES,       B_GLOBAL},
- { "syslog",                  F_SYSLOG,                B_GLOBAL},
+ { "symmetricgrades",			F_SYMMETRICGRADES,		 B_GLOBAL},
+ { "syslog",						F_SYSLOG,					 B_GLOBAL},
  { "undelete",                F_UNDELETE,              B_LOCAL},
- { "verbose",                 F_VERBOSE,               B_LOCAL},
- { "windows",                 F_WINDOWS,               B_LOCAL}
+ { "verbose",						F_VERBOSE,					 B_LOCAL},
+ { "windows",						F_WINDOWS,					 B_LOCAL}
 };
 
 
@@ -532,155 +532,155 @@
 
 typedef struct _ENVLIST
 {
-   char *name;
-   ENV_TYPE value;
+	char *name;
+	ENV_TYPE value;
 } ENVLIST;
 
 static ENVLIST osEnvTable[] =
 {
-   { "dos",      ENV_DOS      },
-   { "16bit",    ENV_BIT16    },
-   { "32bit",    ENV_BIT32    },
-   { "32bitos2", ENV_OS2_16BIT},
-   { "16bitos2", ENV_OS2_32BIT},
-   { "os2",      ENV_OS2      },
-   { "win32",    ENV_WIN_32BIT},
-   { "win16",    ENV_WIN_16BIT},
-   { "32bitwin", ENV_WIN_32BIT},
-   { "16bitwin", ENV_WIN_16BIT},
-   { "win",      ENV_WIN      },
-   { NULL,       ENV_UNKNOWN  }
+	{ "dos",      ENV_DOS		},
+	{ "16bit",	  ENV_BIT16    },
+	{ "32bit",	  ENV_BIT32    },
+	{ "32bitos2", ENV_OS2_16BIT},
+	{ "16bitos2", ENV_OS2_32BIT},
+	{ "os2",      ENV_OS2		},
+	{ "win32",	  ENV_WIN_32BIT},
+	{ "win16",	  ENV_WIN_16BIT},
+	{ "32bitwin", ENV_WIN_32BIT},
+	{ "16bitwin", ENV_WIN_16BIT},
+	{ "win",      ENV_WIN		},
+	{ NULL,		  ENV_UNKNOWN	}
 };
 
 /*--------------------------------------------------------------------*/
-/*       Configuration variables extracted from environment, and      */
+/*       Configuration variables extracted from environment, and		 */
 /*       their names                                                  */
 /*--------------------------------------------------------------------*/
 
 typedef struct _ENV_VARS
 {
-   char *envName;
-   char *confName;
+	char *envName;
+	char *confName;
 } ENV_VARS;
 
 static ENV_VARS envVarList[] =
 {
-   { "EDITOR",   "EDITOR"   },
-   { "HOME",     "HOME"     },
-   { "NAME",     "NAME"     },
-   { "HOSTNAME", "NODENAME" },   /* Useful for OS/2 TCP/IP        */
-   { "MAILBOX",  "MAILBOX"  },
-   { "LOGNAME",  "MAILBOX"  },   /* Same as RCS                   */
-   { "USER",     "MAILBOX"  },   /* Useful for OS/2 TCP/IP        */
-   { "USERNAME", "MAILBOX"  },   /* Useful for NT                 */
-   { "TEMP",     "TEMPDIR"  },
-   { "TMP",      "TEMPDIR"  },
-   { "TZ",       "TZ"       },
-   { NULL,       NULL       }
+	{ "EDITOR",   "EDITOR"	 },
+	{ "HOME",	  "HOME"     },
+	{ "NAME",	  "NAME"     },
+	{ "HOSTNAME", "NODENAME" },	/* Useful for OS/2 TCP/IP			*/
+	{ "MAILBOX",  "MAILBOX"  },
+	{ "LOGNAME",  "MAILBOX"  },	/* Same as RCS                   */
+	{ "USER",	  "MAILBOX"  },	/* Useful for OS/2 TCP/IP			*/
+	{ "USERNAME", "MAILBOX"  },	/* Useful for NT						*/
+	{ "TEMP",	  "TEMPDIR"  },
+	{ "TMP",      "TEMPDIR"  },
+	{ "TZ",		  "TZ"		 },
+	{ NULL,		  NULL		 }
 } ;
 
 typedef struct _DEFAULTS
 {
-   char **value;
-   char *literal;
-   KWBoolean path;
+	char **value;
+	char *literal;
+	KWBoolean path;
 } DEFAULTS;
 
 /*--------------------------------------------------------------------*/
-/*       List of directories automatically initialized to be off      */
-/*       root configuration directory, if needed.                     */
+/*       List of directories automatically initialized to be off		 */
+/*       root configuration directory, if needed.							 */
 /*--------------------------------------------------------------------*/
 
 static DEFAULTS directoryList[] =
 {
-   {&E_maildir,      "mail"    , KWTrue },
-   {&E_newsdir,      "news"    , KWTrue },
-   {&E_pubdir,       "public"  , KWTrue },
-   {&E_spooldir,     "spool"   , KWTrue },
-   {&E_tempdir,      "tmp"     , KWTrue },
-   {&E_systems,      "systems" , KWTrue },
-   {&E_passwd,       "passwd"  , KWTrue },
-   {&E_permissions,  "permissn", KWTrue },
-   { NULL  }
+	{&E_maildir,		"mail"	 , KWTrue },
+	{&E_newsdir,		"news"	 , KWTrue },
+	{&E_pubdir,       "public"  , KWTrue },
+	{&E_spooldir,		"spool"	 , KWTrue },
+	{&E_tempdir,		"tmp"     , KWTrue },
+	{&E_systems,		"systems" , KWTrue },
+	{&E_passwd,       "passwd"  , KWTrue },
+	{&E_permissions,	"permissn", KWTrue },
+	{ NULL  }
 } ;
 
 /*--------------------------------------------------------------------*/
-/*    p r o c e s s K e y w o r d                                     */
+/*    p r o c e s s K e y w o r d												 */
 /*                                                                    */
-/*    Given a keyword in the configuration, process it                */
+/*    Given a keyword in the configuration, process it					 */
 /*--------------------------------------------------------------------*/
 
 static KWBoolean
 processKeyword( CONFIGTABLE *tptr,
-                char *cp )
+					 char *cp )
 {
-   char **varPtr = tptr->loc;
+	char **varPtr = tptr->loc;
 
 /*--------------------------------------------------------------------*/
 /*                      Handle obsolete options                       */
 /*--------------------------------------------------------------------*/
 
-   if (tptr->flag & B_OBSOLETE)
-   {
-      printmsg(2,"Obsolete keyword \"%s\" ignored.", tptr->sym );
-      return KWFalse;
-   }
+	if (tptr->flag & B_OBSOLETE)
+	{
+		printmsg(2,"Obsolete keyword \"%s\" ignored.", tptr->sym );
+		return KWFalse;
+	}
 
 /*--------------------------------------------------------------------*/
-/*          Handle options for which no storage is allocated          */
+/*          Handle options for which no storage is allocated			 */
 /*--------------------------------------------------------------------*/
 
-   if ( tptr->loc == 0 )
-   {
+	if ( tptr->loc == 0 )
+	{
 
 #ifdef UDEBUG
-      printmsg(10,"Dummy entry %s ignored.", tptr->sym );
+		printmsg(10,"Dummy entry %s ignored.", tptr->sym );
 #endif
-      return KWFalse;
+		return KWFalse;
 
-   }
+	}
 
 /*--------------------------------------------------------------------*/
-/*                       Handle integer values                        */
+/*                       Handle integer values								 */
 /*--------------------------------------------------------------------*/
 
-   if (tptr->flag & (B_SHORT|B_LONG))
-   {
-      long foo;
-      cp = strtok(cp,WHITESPACE);
+	if (tptr->flag & (B_SHORT|B_LONG))
+	{
+		long foo;
+		cp = strtok(cp,WHITESPACE);
 
-      if ( equal(cp,"0"))
-         foo = 0;
-      else {
+		if ( equal(cp,"0"))
+			foo = 0;
+		else {
 
-         foo = atol(cp);
+			foo = atol(cp);
 
-         if ( foo == 0)
-         {
-            printmsg(0,
-               "Unable to convert \"%s\" value \"%s\" to integer",
-               tptr->sym, cp);
+			if ( foo == 0)
+			{
+				printmsg(0,
+					"Unable to convert \"%s\" value \"%s\" to integer",
+					tptr->sym, cp);
 
-            return KWFalse;
+				return KWFalse;
 
-         } /* if */
+			} /* if */
 
-      } /* else */
+		} /* else */
 
 #ifdef UDEBUG
-      printmsg(10,"Assigning keyword %s numeric value %ld",
-                   tptr->sym,
-                   foo );
+		printmsg(10,"Assigning keyword %s numeric value %ld",
+						 tptr->sym,
+						 foo );
 #endif
 
-      if (tptr->flag & B_LONG)
-         *((long *) tptr->loc) = foo;
-      else
-         *((KEWSHORT *) tptr->loc) = (KEWSHORT) foo;
+		if (tptr->flag & B_LONG)
+			*((long *) tptr->loc) = foo;
+		else
+			*((KEWSHORT *) tptr->loc) = (KEWSHORT) foo;
 
-      return KWTrue;
+		return KWTrue;
 
-   } /* if (tptr->flag & (B_SHORT|B_LONG)) */
+	} /* if (tptr->flag & (B_SHORT|B_LONG)) */
 
 /*--------------------------------------------------------------------*/
 /*       Begin processing character types:  lists, strings,           */
@@ -688,275 +688,275 @@
 /*--------------------------------------------------------------------*/
 
 #ifdef UDEBUG
-      printmsg(10,"Assigning keyword %s string value \"%s\"",
-                   tptr->sym,
-                   cp );
+		printmsg(10,"Assigning keyword %s string value \"%s\"",
+						 tptr->sym,
+						 cp );
 #endif
 
 /*--------------------------------------------------------------------*/
 /*                       Handle lists of tokens                       */
 /*--------------------------------------------------------------------*/
 
-   if (tptr->flag & (B_LIST | B_CLIST))
-   {
-      char **list = malloc( (MAXLIST+1) * sizeof (*list));
-      char *colon;
-      int words;
+	if (tptr->flag & (B_LIST | B_CLIST))
+	{
+		char **list = malloc( (MAXLIST+1) * sizeof (*list));
+		char *colon;
+		int words;
 
-      checkref( list );
+		checkref( list );
 
-      if (tptr->flag & B_CLIST)  /* Use colon as delimiter?  */
-      {
-         while ( (colon = strchr( cp , ':')) != NULL)
-            *colon = ' ';     /* Make colons spaces ...      */
-      }
+		if (tptr->flag & B_CLIST)	/* Use colon as delimiter?  */
+		{
+			while ( (colon = strchr( cp , ':')) != NULL)
+				*colon = ' ';		/* Make colons spaces ...		 */
+		}
 
-      words = getargs(cp, list);
+		words = getargs(cp, list);
 
-      if( words > MAXLIST)
-         panic();
+		if( words > MAXLIST)
+			panic();
 
-      if (words > 0)
-      {
-         if ( *(varPtr) )
-            free( *(varPtr) );
+		if (words > 0)
+		{
+			if ( *(varPtr) )
+				free( *(varPtr) );
 
-         list = realloc( list, (size_t) (words+1) * sizeof(*list));
-         checkref( list );
-         *(varPtr) = (char *) list;
-         list[words] = NULL;
+			list = realloc( list, (size_t) (words+1) * sizeof(*list));
+			checkref( list );
+			*(varPtr) = (char *) list;
+			list[words] = NULL;
 
-         while( *list != NULL)
-         {
+			while( *list != NULL)
+			{
 
-            if (strlen(*list))
-            {
-               *list = newstr(*list);
-               checkref( *list++ );
-            }
-            else
-               *list++ = "";
+				if (strlen(*list))
+				{
+					*list = newstr(*list);
+					checkref( *list++ );
+				}
+				else
+					*list++ = "";
 
-         } /* while */
+			} /* while */
 
-      } /* if (words > 0) */
-      else {
+		} /* if (words > 0) */
+		else {
 
-         printmsg(0,"No parameters given for keyword \"%s\"",
-                  tptr->sym);
+			printmsg(0,"No parameters given for keyword \"%s\"",
+						tptr->sym);
 
-         return KWFalse;
+			return KWFalse;
 
-      } /* else */
+		} /* else */
 
-      return KWTrue;
+		return KWTrue;
 
-   } /* if */
+	} /* if */
 
 /*--------------------------------------------------------------------*/
-/*                  Handle single tokens and strings                  */
+/*                  Handle single tokens and strings						 */
 /*--------------------------------------------------------------------*/
 
-   while( *cp == ' ' )     /* Trim leading whitespace     */
-      cp++;
+	while( *cp == ' ' )		/* Trim leading whitespace     */
+		cp++;
 
-   if (*cp == '\0')
-   {
-      printmsg(0,"No parameter given for keyword \"%s\""
-               ", ignored.",
-               tptr->sym);
+	if (*cp == '\0')
+	{
+		printmsg(0,"No parameter given for keyword \"%s\""
+					", ignored.",
+					tptr->sym);
 
-      return KWFalse;
-   } /* if */
+		return KWFalse;
+	} /* if */
 
-   if (tptr->flag & (B_TOKEN|B_CHAR))  /* One word value?   */
-      cp = strtok(cp,WHITESPACE); /* Yes --> Tokenize */
+	if (tptr->flag & (B_TOKEN|B_CHAR))	/* One word value?	*/
+		cp = strtok(cp,WHITESPACE); /* Yes --> Tokenize */
 
-   if (tptr->flag & B_NORMAL)  /* Normalize path?     */
-      cp = normalize( cp );
+	if (tptr->flag & B_NORMAL)  /* Normalize path?		*/
+		cp = normalize( cp );
 
-   if (tptr->flag & B_CHAR )   /* Simple character?   */
-   {
-      if ( strlen( cp ) > 1 )
-      {
-         printmsg(0,"Keyword %s value \"%s\" "
-                    "length exceeds one character",
-                    tptr->sym,
-                    cp );
-         return KWFalse;
-      }
-      else
-         *((char *) tptr->loc) = *cp;
+	if (tptr->flag & B_CHAR )	 /* Simple character?	*/
+	{
+		if ( strlen( cp ) > 1 )
+		{
+			printmsg(0,"Keyword %s value \"%s\" "
+						  "length exceeds one character",
+						  tptr->sym,
+						  cp );
+			return KWFalse;
+		}
+		else
+			*((char *) tptr->loc) = *cp;
 
-   } /* if (tptr->flag & B_CHAR ) */
-   else if (tptr->flag & B_MALLOC)  /* Allocate normally?  */
-   {
-      *(varPtr) = strdup(cp);    /* Save string           */
+	} /* if (tptr->flag & B_CHAR ) */
+	else if (tptr->flag & B_MALLOC)	/* Allocate normally?  */
+	{
+		*(varPtr) = strdup(cp);    /* Save string           */
 
-      checkref( *(varPtr) );     /* Verify malloc()       */
-   }
-   else
-      *(varPtr) = newstr(cp);    /* Save string           */
+		checkref( *(varPtr) );		/* Verify malloc()		 */
+	}
+	else
+		*(varPtr) = newstr(cp);    /* Save string           */
 
-   return KWTrue;
+	return KWTrue;
 
-}  /* processKeyword */
+}	/* processKeyword */
 
 /*--------------------------------------------------------------------*/
-/*    p r o c e s s c o n f i g                                       */
+/*    p r o c e s s c o n f i g													 */
 /*                                                                    */
 /*    Handle a single line of a configuration file                    */
 /*--------------------------------------------------------------------*/
 
 KWBoolean
 processconfig( char *buff,
-               SYSMODE sysmode,
-               CONFIGBITS program,
-               CONFIGTABLE *table,
-               const size_t tableSize,
-               FLAGTABLE *bTable,
-               const size_t bTableSize)
+					SYSMODE sysmode,
+					CONFIGBITS program,
+					CONFIGTABLE *table,
+					const size_t tableSize,
+					FLAGTABLE *bTable,
+					const size_t bTableSize)
 {
-   CONFIGTABLE *tptr = NULL;
-   char *cp;
-   char *period;
-   char *keyword;
-   ENV_TYPE target_env;
+	CONFIGTABLE *tptr = NULL;
+	char *cp;
+	char *period;
+	char *keyword;
+	ENV_TYPE target_env;
 
-   int lower = 0;
-   int upper = (int) tableSize - 1;
+	int lower = 0;
+	int upper = (int) tableSize - 1;
 
 /*--------------------------------------------------------------------*/
-/*                break out the keyword from its value                */
+/*                break out the keyword from its value					 */
 /*--------------------------------------------------------------------*/
 
-   if ((cp = strchr(buff, '=')) == nil(char))
-   {
-      printmsg(0,"Missing equals sign after keyword \"%s\", ignored",
-                  buff);
-      return KWFalse;
-   }
+	if ((cp = strchr(buff, '=')) == nil(char))
+	{
+		printmsg(0,"Missing equals sign after keyword \"%s\", ignored",
+						buff);
+		return KWFalse;
+	}
 
-   *cp++ = '\0';
+	*cp++ = '\0';
 
-   strlwr(buff);
+	strlwr(buff);
 
 /*--------------------------------------------------------------------*/
-/*    Determine if the keyword should processed in this environment   */
+/*    Determine if the keyword should processed in this environment	 */
 /*--------------------------------------------------------------------*/
 
-   period = keyword = strchr( buff, '.' );
-                              /* Look for environment prefix          */
+	period = keyword = strchr( buff, '.' );
+										/* Look for environment prefix			 */
 
-   if ( keyword == NULL )     /* No environment?                      */
-   {
-      keyword = buff;         /* Then buffer starts with keyword      */
-      target_env = active_env;
-   }
-   else {
+	if ( keyword == NULL )		/* No environment?							 */
+	{
+		keyword = buff;			/* Then buffer starts with keyword		 */
+		target_env = active_env;
+	}
+	else {
 
-      short subscript = 0;
+		short subscript = 0;
 
-      *keyword++ = '\0';      /* Terminate environment string         */
-      target_env = ENV_UNKNOWN;
+		*keyword++ = '\0';		/* Terminate environment string			 */
+		target_env = ENV_UNKNOWN;
 
-      while( osEnvTable[subscript].name != NULL)
-      {
+		while( osEnvTable[subscript].name != NULL)
+		{
 
-         if (equal( osEnvTable[subscript].name, buff ))
-         {
-            target_env = osEnvTable[subscript].value;
-            break;
-         }
-         else
-            subscript ++;
+			if (equal( osEnvTable[subscript].name, buff ))
+			{
+				target_env = osEnvTable[subscript].value;
+				break;
+			}
+			else
+				subscript ++;
 
-      } /* while */
+		} /* while */
 
-      if ( target_env == ENV_UNKNOWN )
-      {
-         printmsg(0,"Unknown environment \"%s\", keyword \"%s\" ignored",
-               buff, keyword );
+		if ( target_env == ENV_UNKNOWN )
+		{
+			printmsg(0,"Unknown environment \"%s\", keyword \"%s\" ignored",
+					buff, keyword );
 
-         return KWTrue;
-      }
+			return KWTrue;
+		}
 
-   } /* else */
+	} /* else */
 
-   if ( period != NULL )
-      *period = '.';
+	if ( period != NULL )
+		*period = '.';
 
 /*--------------------------------------------------------------------*/
-/*            Binary search to locate keyword in the table            */
+/*            Binary search to locate keyword in the table				 */
 /*--------------------------------------------------------------------*/
 
-   while( (tptr == NULL) && (lower <= upper) )
-   {
-      int midpoint = ( lower + upper ) / 2;
-      int hit = strcmp( keyword, table[midpoint].sym );
+	while( (tptr == NULL) && (lower <= upper) )
+	{
+		int midpoint = ( lower + upper ) / 2;
+		int hit = strcmp( keyword, table[midpoint].sym );
 
-      if (hit > 0)
-         lower = midpoint + 1;
-      else if (hit < 0)
-         upper = midpoint - 1;
-      else
-         tptr = &table[midpoint];
-   }
+		if (hit > 0)
+			lower = midpoint + 1;
+		else if (hit < 0)
+			upper = midpoint - 1;
+		else
+			tptr = &table[midpoint];
+	}
 
-   if ( tptr == NULL )              /* Search fail?                  */
-      return KWFalse;               /* Yes, report same to caller    */
+	if ( tptr == NULL )					/* Search fail?						*/
+		return KWFalse;					/* Yes, report same to caller    */
 
 /*--------------------------------------------------------------------*/
-/*            Skip the keyword because of the environment?            */
+/*            Skip the keyword because of the environment?				 */
 /*--------------------------------------------------------------------*/
 
-   if (!(((unsigned long) active_env) & (unsigned long) target_env) )
-   {
-       printmsg(2,"%s-environment keyword \"%s\" skipped.",
-                   strupr(buff), keyword);
-       return KWTrue;
-   }
+	if (!(((unsigned long) active_env) & (unsigned long) target_env) )
+	{
+		 printmsg(2,"%s-environment keyword \"%s\" skipped.",
+						 strupr(buff), keyword);
+		 return KWTrue;
+	}
 
 /*--------------------------------------------------------------------*/
-/*                  Handle mis-placed system options                  */
+/*                  Handle mis-placed system options						 */
 /*--------------------------------------------------------------------*/
 
-   if ((tptr->flag & B_GLOBAL) && (sysmode != SYSTEM_CONFIG))
-   {
-       printmsg(0,
-          "User specified system keyword \"%s\" ignored.",
-          keyword);
-       return KWTrue;
-   }
+	if ((tptr->flag & B_GLOBAL) && (sysmode != SYSTEM_CONFIG))
+	{
+		 printmsg(0,
+			 "User specified system keyword \"%s\" ignored.",
+			 keyword);
+		 return KWTrue;
+	}
 
 /*--------------------------------------------------------------------*/
-/*       Skip options we don't need for this particular program       */
+/*       Skip options we don't need for this particular program		 */
 /*--------------------------------------------------------------------*/
 
-   if (program && !(tptr->program & program))
-   {
-      tptr->flag |= B_FOUND;
-      return KWTrue;                /* No operation if we don't need
-                                       the keyword                   */
-   }
+	if (program && !(tptr->program & program))
+	{
+		tptr->flag |= B_FOUND;
+		return KWTrue;                /* No operation if we don't need
+													the keyword                   */
+	}
 
 /*--------------------------------------------------------------------*/
 /*                       Handle Boolean options                       */
 /*--------------------------------------------------------------------*/
 
-   if (tptr->flag & B_BOOLEAN )
-      options(cp,
-              sysmode,
-              bTable,
-              (KWBoolean *) tptr->loc,
-              bTableSize);
+	if (tptr->flag & B_BOOLEAN )
+		options(cp,
+				  sysmode,
+				  bTable,
+				  (KWBoolean *) tptr->loc,
+				  bTableSize);
 
 /*--------------------------------------------------------------------*/
-/*                        Process the keyword                         */
+/*                        Process the keyword								 */
 /*--------------------------------------------------------------------*/
 
   else if (processKeyword( tptr, cp ))
-     tptr->flag |= B_FOUND;
+	  tptr->flag |= B_FOUND;
 
   return KWTrue;
 
@@ -969,417 +969,418 @@
 /*--------------------------------------------------------------------*/
 
 KWBoolean getconfig(FILE *fp,
-                  SYSMODE sysmode,
-                  CONFIGBITS program,
-                  CONFIGTABLE *table,
-                  const size_t tableSize,
-                  FLAGTABLE *bTable,
-                  const size_t bTableSize)
+						SYSMODE sysmode,
+						CONFIGBITS program,
+						CONFIGTABLE *table,
+						const size_t tableSize,
+						FLAGTABLE *bTable,
+						const size_t bTableSize)
 {
 
-   char buff[BUFSIZ];
-   char *cp;
+	char buff[BUFSIZ];
+	char *cp;
 
-   while(!(fgets(buff, sizeof buff, fp) == nil(char)))
-   {
+	while(!(fgets(buff, sizeof buff, fp) == nil(char)))
+	{
 
 /*--------------------------------------------------------------------*/
-/*                        Ingore comment lines                        */
+/*                        Ingore comment lines								 */
 /*--------------------------------------------------------------------*/
 
-      if (*buff == '#')
-         continue;            /* comment line   */
+		if (*buff == '#')
+			continue;				/* comment line	*/
 
 /*--------------------------------------------------------------------*/
 /*                       Drop trailing new line                       */
 /*--------------------------------------------------------------------*/
 
-      if (*(cp = buff + strlen(buff) - 1) == '\n')
-         *cp = '\0';
+		if (*(cp = buff + strlen(buff) - 1) == '\n')
+			*cp = '\0';
 
 /*--------------------------------------------------------------------*/
-/*                 Drop leading blanks on input line                  */
+/*                 Drop leading blanks on input line						 */
 /*--------------------------------------------------------------------*/
 
-      cp = buff;
+		cp = buff;
 
-      while( isspace( *cp ) )
-         cp ++ ;
+		while( isspace( *cp ) )
+			cp ++ ;
 
 /*--------------------------------------------------------------------*/
 /*                 If line was not blank, process it.                 */
 /*--------------------------------------------------------------------*/
 
-     if (*cp != '\0')
-     {
-        if ( ! processconfig( cp,
-                              sysmode,
-                              program,
-                              table,
-                              tableSize,
-                              bTable,
-                              bTableSize ) )
-            printmsg(0,
-               "Unknown keyword \"%s\" in %s configuration file ignored",
-               buff, sysmode ? "system" : "user");
-     }
+	  if (*cp != '\0')
+	  {
+		  if ( ! processconfig( cp,
+										sysmode,
+										program,
+										table,
+										tableSize,
+										bTable,
+										bTableSize ) )
+				printmsg(0,
+					"Unknown keyword \"%s\" in %s configuration file ignored",
+					buff, sysmode ? "system" : "user");
+	  }
 
-   } /* while */
+	} /* while */
 
-   return KWTrue;
+	return KWTrue;
 
 } /* getconfig */
 
 /*--------------------------------------------------------------------*/
-/*    o p t i o n s                                                   */
+/*    o p t i o n s																	 */
 /*                                                                    */
 /*    Process a line of KWBoolean option flags.                       */
 /*--------------------------------------------------------------------*/
 
 void
 options(char *s,
-        SYSMODE sysmode,
-        FLAGTABLE *flags,
-        KWBoolean *barray,
-        const size_t flagSize )
+		  SYSMODE sysmode,
+		  FLAGTABLE *flags,
+		  KWBoolean *barray,
+		  const size_t flagSize )
 {
-   char *token;
+	char *token;
 
-   strlwr(s);
-   token = strtok(s,WHITESPACE);
+	strlwr(s);
+	token = strtok(s,WHITESPACE);
 
-   while (token != NULL)
-   {
-      KWBoolean newValue;
-      char *compare;
-      int upper, lower;
-
-      if ( equaln(token,"no",2) && (strlen(token) > 2) )
-      {
-         newValue = KWFalse;
-         compare = token + 2;
-      }
-      else {
-         newValue = KWTrue;
-         compare = token;
-      }
-
-      upper = (int) flagSize - 1;
-      lower = 0;
-
-/*--------------------------------------------------------------------*/
-/*            Binary search to locate keyword in the table            */
-/*--------------------------------------------------------------------*/
-
-      while( lower <= upper)
-      {
-         int midpoint = ( lower + upper ) / 2;
-         int hit = strcmp( compare, flags[midpoint].sym );
-
-         if (hit > 0)
-            lower = midpoint + 1;
-         else if (hit < 0)
-            upper = midpoint - 1;
-         else {
-            if ((flags[midpoint].bits & B_GLOBAL) &&
-                (sysmode != SYSTEM_CONFIG))
-            {
-               printmsg(0,"options: System boolean option %s "
-                          "only be specified in system configuration file.",
-                          token );
-            }
-            else {
-               barray[ flags[midpoint].position ] = newValue;
-            }
-
-            break;
-
-         } /* else */
-
-      } /* while( lower <= upper) */
-
-      if ( lower > upper )
-      {
-         strupr( token );
-         printf("options: Invalid boolean option %s specified\n", token);
-      }
+	while (token != NULL)
+	{
+		KWBoolean newValue;
+		char *compare;
+		int upper, lower;
+
+		if ( equaln(token,"no",2) && (strlen(token) > 2) )
+		{
+			newValue = KWFalse;
+			compare = token + 2;
+		}
+		else {
+			newValue = KWTrue;
+			compare = token;
+		}
+
+		upper = (int) flagSize - 1;
+		lower = 0;
+
+/*--------------------------------------------------------------------*/
+/*            Binary search to locate keyword in the table				 */
+/*--------------------------------------------------------------------*/
+
+		while( lower <= upper)
+		{
+			int midpoint = ( lower + upper ) / 2;
+			int hit = strcmp( compare, flags[midpoint].sym );
+
+			if (hit > 0)
+				lower = midpoint + 1;
+			else if (hit < 0)
+				upper = midpoint - 1;
+			else {
+				if ((flags[midpoint].bits & B_GLOBAL) &&
+					 (sysmode != SYSTEM_CONFIG))
+				{
+					printmsg(0,"options: System boolean option %s "
+								  "only be specified in system configuration file.",
+								  token );
+				}
+				else {
+					barray[ flags[midpoint].position ] = newValue;
+				}
+
+				break;
+
+			} /* else */
+
+		} /* while( lower <= upper) */
+
+		if ( lower > upper )
+		{
+			strupr( token );
+			printf("options: Invalid boolean option %s specified\n", token);
+		}
 
-      token = strtok(NULL,WHITESPACE);  /* Step to next token on line */
+		token = strtok(NULL,WHITESPACE);  /* Step to next token on line */
 
-   } /* while */
+	} /* while */
 
 } /* options */
 
 /*--------------------------------------------------------------------*/
 /*    c o n f i g u r e                                               */
 /*                                                                    */
-/*    Define the global parameters of UUPC/extended                   */
+/*    Define the global parameters of UUPC/extended						 */
 /*--------------------------------------------------------------------*/
 
 KWBoolean configure( CONFIGBITS program)
 {
-   char *sysrc, *usrrc;
-   FILE *fp;
-   KWBoolean success;
-   char buf[BUFSIZ];
-   size_t subscript = 0;
-   char *s;
+	char *sysrc, *usrrc;
+	FILE *fp;
+	KWBoolean success;
+	char buf[BUFSIZ];
+	size_t subscript = 0;
+	char *s;
 
 /*--------------------------------------------------------------------*/
 /*     In Windows/NT, set the console input mode to non-linebased     */
 /*--------------------------------------------------------------------*/
 
 #ifdef WIN32
-   setstdinmode();
+	setstdinmode();
 #endif
 
 #ifdef __IBMC__
-   logfile = stdout;
+	logfile = stdout;
 #endif
 
 /*--------------------------------------------------------------------*/
-/*                  Determine the active environment                  */
+/*                  Determine the active environment						 */
 /*--------------------------------------------------------------------*/
 
-   if (!getrcnames(&sysrc, &usrrc))
-      return KWFalse;
+	if (!getrcnames(&sysrc, &usrrc))
+		return KWFalse;
 
 /*--------------------------------------------------------------------*/
 /*          Extract selected variables from our environment           */
 /*--------------------------------------------------------------------*/
 
-   for ( subscript = 0; envVarList[subscript].envName != NULL; subscript++ )
-   {
-      s = getenv( envVarList[subscript].envName );
-
-      if (s != NULL )
-      {
-         sprintf(buf,"%s=%s", envVarList[subscript].confName, s );
-         printmsg(5,"Inserting environment variable %s as %s",
-                     s, buf );
-
-         if ( !processconfig( buf,
-                              SYSTEM_CONFIG,
-                              program,
-                              rcTable,
-                              rcTableSize,
-                              configFlags,
-                              configFlagsSize ))
-         {
-            printmsg(0,"Internal error: Invalid keyword %s",
-                       envVarList[subscript].confName  );
-            panic();
-         }
+	for ( subscript = 0; envVarList[subscript].envName != NULL; subscript++ )
+	{
+		s = getenv( envVarList[subscript].envName );
+
+		if (s != NULL )
+		{
+			sprintf(buf,"%s=%s", envVarList[subscript].confName, s );
+			printmsg(5,"Inserting environment variable %s as %s",
+							s, buf );
+
+			if ( !processconfig( buf,
+										SYSTEM_CONFIG,
+										program,
+										rcTable,
+										rcTableSize,
+										configFlags,
+										configFlagsSize ))
+			{
+				printmsg(0,"Internal error: Invalid keyword %s",
+							  envVarList[subscript].confName  );
+				panic();
+			}
 
-      } /* if (sysrc != NULL ) */
+		} /* if (sysrc != NULL ) */
 
-   } /* for ( subscript = 0; ... ) */
+	} /* for ( subscript = 0; ... ) */
 
 /*--------------------------------------------------------------------*/
 /*       If the user specified a user name in the environment but     */
-/*       not a UUPCUSRRC variable, build a UUPCUSRRC variable         */
+/*       not a UUPCUSRRC variable, build a UUPCUSRRC variable			 */
 /*--------------------------------------------------------------------*/
 
-   if ((usrrc == nil(char)) && ( E_mailbox != NULL ))
-   {                             /* Can build from the environment?  */
-      strcpy( buf, E_mailbox );
-      strcat( buf, ".rc" );
-      usrrc = newstr( buf );
-      printmsg(2,"Using UUPCUSRRC=%s", usrrc );
-   }
+	if ((usrrc == nil(char)) && ( E_mailbox != NULL ))
+	{										/* Can build from the environment?	*/
+		strcpy( buf, E_mailbox );
+		strcat( buf, ".rc" );
+		usrrc = newstr( buf );
+		printmsg(2,"Using UUPCUSRRC=%s", usrrc );
+	}
 
 /*--------------------------------------------------------------------*/
-/*          Determine configuration directory from UUPCSYSRC          */
+/*          Determine configuration directory from UUPCSYSRC			 */
 /*--------------------------------------------------------------------*/
 
-   E_confdir = normalize( sysrc );     /* Make 'em all slashes        */
+	E_confdir = normalize( sysrc );		/* Make 'em all slashes        */
 
-   s = strrchr( E_confdir, '/' );      /* Get end of path component   */
-   if ( s == NULL )                    /* There WAS one, right?       */
-   {                                   /* Er, no, sorry.              */
-      printmsg(0,"No path name in UUPCSYSRC: %s", sysrc);
-      panic();
-   }
+	s = strrchr( E_confdir, '/' );		/* Get end of path component	 */
+	if ( s == NULL )							/* There WAS one, right?		 */
+	{												/* Er, no, sorry.              */
+		printmsg(0,"No path name in UUPCSYSRC: %s", sysrc);
+		panic();
+	}
 
-   *(s+1) = '\0';                      /* Terminate for Config Directory */
-   E_confdir = newstr(normalize( E_confdir ));
-                                       /* Drop trailing slash unless  */
-                                       /* root directory and save     */
+	*(s+1) = '\0';                      /* Terminate for Config Directory */
+	E_confdir = newstr(normalize( E_confdir ));
+													/* Drop trailing slash unless  */
+													/* root directory and save     */
 
 /*--------------------------------------------------------------------*/
-/*               Process the system configuration file                */
+/*               Process the system configuration file					 */
 /*--------------------------------------------------------------------*/
 
-   if ((fp = FOPEN(sysrc, "r",TEXT_MODE)) == nil(FILE))
-   {
-      printmsg(0, "Cannot open system configuration file \"%s\"", sysrc);
-      printerr(sysrc);
-      return KWFalse;
-   }
+	if ((fp = FOPEN(sysrc, "r",TEXT_MODE)) == nil(FILE))
+	{
+		printmsg(0, "Cannot open system configuration file \"%s\"", sysrc);
+		printerr(sysrc);
+		return KWFalse;
+	}
 
-   PushDir( E_confdir );
+	PushDir( E_confdir );
 
-   success = getconfig(fp,
-                       SYSTEM_CONFIG,
-                       program,
-                       rcTable,
-                       rcTableSize,
-                       configFlags,
-                       configFlagsSize );
+	success = getconfig(fp,
+							  SYSTEM_CONFIG,
+							  program,
+							  rcTable,
+							  rcTableSize,
+							  configFlags,
+							  configFlagsSize );
 
-   fclose(fp);
+	fclose(fp);
 
-   if (!success)
-   {
-      PopDir();
-      return KWFalse;
-   }
+	if (!success)
+	{
+		PopDir();
+		return KWFalse;
+	}
 
 /*--------------------------------------------------------------------*/
-/*                Process the user configuration value                */
+/*                Process the user configuration value					 */
 /*--------------------------------------------------------------------*/
 
-   if (usrrc != nil(char))
-   {
-      usrrc = normalize( usrrc );
+	if (usrrc != nil(char))
+	{
+		usrrc = normalize( usrrc );
 
-      if ((fp = FOPEN(usrrc, "r",TEXT_MODE)) == nil(FILE))
-      {
-         printmsg(0, "Cannot open user configuration file \"%s\"", usrrc);
-         PopDir();
-         return KWFalse;
-      }
+		if ((fp = FOPEN(usrrc, "r",TEXT_MODE)) == nil(FILE))
+		{
+			printmsg(0, "Cannot open user configuration file \"%s\"", usrrc);
+			PopDir();
+			return KWFalse;
+		}
 
-      success = getconfig(fp,
-                           USER_CONFIG,
-                           program,
-                           rcTable,
-                           rcTableSize,
-                           configFlags,
-                           configFlagsSize );
+		success = getconfig(fp,
+									USER_CONFIG,
+									program,
+									rcTable,
+									rcTableSize,
+									configFlags,
+									configFlagsSize );
 
-      fclose(fp);
+		fclose(fp);
 
-      if (!success)
-      {
-         PopDir();
-         return KWFalse;
-      }
+		if (!success)
+		{
+			PopDir();
+			return KWFalse;
+		}
 
-   } /* if (usrrc != nil(char)) */
+	} /* if (usrrc != nil(char)) */
 
 /*--------------------------------------------------------------------*/
-/*                       Display our copyright                        */
+/*                       Display our copyright								 */
 /*--------------------------------------------------------------------*/
 
-   if (! bflag[F_SUPPRESSCOPYRIGHT] &&
-        (program != B_MTA) &&
-        isatty(fileno(stdout)))
-      fprintf(stdout,
+	if (! bflag[F_SUPPRESSCOPYRIGHT] &&
+		  (program != B_MTA) &&
+		  (program != B_DBZ) &&
+		  isatty(fileno(stdout)))
+		fprintf(stdout,
 "Changes and Compilation Copyright (c) 1989-1997 by Kendra Electronic\n"
 "Wonderworks.  May be freely distributed for reasonable copying fee\n"
 "if original documentation and source is included.  See license for\n"
 "details and restrictions.\n");
 
 /*--------------------------------------------------------------------*/
-/*          Validate that all required parameters were given          */
+/*          Validate that all required parameters were given			 */
 /*--------------------------------------------------------------------*/
 
-   for (subscript = 0; subscript < rcTableSize; subscript++ )
-   {
+	for (subscript = 0; subscript < rcTableSize; subscript++ )
+	{
 
-      if ((rcTable[subscript].flag & (B_REQUIRED | B_FOUND)) == B_REQUIRED)
-      {
-         printmsg(0, "%s configuration parameter \"%s\" must be set.",
-            (rcTable[subscript].flag & B_GLOBAL) ? "System" : "User",
-            rcTable[subscript].sym);
-         success = KWFalse;
-      } /* if */
+		if ((rcTable[subscript].flag & (B_REQUIRED | B_FOUND)) == B_REQUIRED)
+		{
+			printmsg(0, "%s configuration parameter \"%s\" must be set.",
+				(rcTable[subscript].flag & B_GLOBAL) ? "System" : "User",
+				rcTable[subscript].sym);
+			success = KWFalse;
+		} /* if */
 
-   } /* for */
+	} /* for */
 
 /*--------------------------------------------------------------------*/
-/*                     Fill in derived parameters                     */
+/*                     Fill in derived parameters							 */
 /*--------------------------------------------------------------------*/
 
-   subscript = 0;
+	subscript = 0;
 
-   while( directoryList[subscript].value != NULL )
-   {
-      if ( *(directoryList[subscript].value) == NULL )
-         *(directoryList[subscript].value) = directoryList[subscript].path ?
-                     newstr( normalize(directoryList[subscript].literal) ) :
-                     directoryList[subscript].literal;
-      subscript++;
-   }
+	while( directoryList[subscript].value != NULL )
+	{
+		if ( *(directoryList[subscript].value) == NULL )
+			*(directoryList[subscript].value) = directoryList[subscript].path ?
+							newstr( normalize(directoryList[subscript].literal) ) :
+							directoryList[subscript].literal;
+		subscript++;
+	}
 
 /*--------------------------------------------------------------------*/
 /*                         Set our time zone                          */
 /*--------------------------------------------------------------------*/
 
-   if (E_tz != NULL)
-   {
-      sprintf( buf, "TZ=%s", E_tz );
-      E_tz = newstr( buf );
-      putenv( E_tz );
-   }
+	if (E_tz != NULL)
+	{
+		sprintf( buf, "TZ=%s", E_tz );
+		E_tz = newstr( buf );
+		putenv( E_tz );
+	}
 
-   tzset();                      /* Set up time zone information  */
+	tzset();                      /* Set up time zone information	*/
 
-   PopDir();
+	PopDir();
 
-   return success;
+	return success;
 
 } /*configure*/
 
 /*--------------------------------------------------------------------*/
-/*    g e t r c n a m e s                                             */
+/*    g e t r c n a m e s															 */
 /*                                                                    */
-/*    Return the name of the configuration files                      */
+/*    Return the name of the configuration files							 */
 /*--------------------------------------------------------------------*/
 
 KWBoolean getrcnames(char **sysp,char **usrp)
 {
-   char *debugp = NULL;      /* Pointer to debug environment variable */
+	char *debugp = NULL;      /* Pointer to debug environment variable */
 
-   if ((*sysp = getenv(SYSRCSYM)) == nil(char)
+	if ((*sysp = getenv(SYSRCSYM)) == nil(char)
 #if defined(WIN32)
-      && (getregistry(SYSRCSYM, sysp) == nil(char))
+		&& (getregistry(SYSRCSYM, sysp) == nil(char))
 #endif
-   )
-   {
-      printf("Environment variable %s must be specified\n", SYSRCSYM);
-      return KWFalse;
-   }
+	)
+	{
+		printf("Environment variable %s must be specified\n", SYSRCSYM);
+		return KWFalse;
+	}
 
-   *usrp = getenv(USRRCSYM);
+	*usrp = getenv(USRRCSYM);
 
 #if defined(WIN32)
-   if (*usrp == nil(char))
-      getregistry(USRRCSYM, usrp);
+	if (*usrp == nil(char))
+		getregistry(USRRCSYM, usrp);
 #endif
 
-   debugp = getenv(SYSDEBUG);
+	debugp = getenv(SYSDEBUG);
 
-   if ( debugp != nil(char))        /* Debug specified in environment? */
-      debuglevel = atoi(debugp);    /* Yes --> preset debuglevel for user */
+	if ( debugp != nil(char))			/* Debug specified in environment? */
+		debuglevel = atoi(debugp);    /* Yes --> preset debuglevel for user */
 
-   return KWTrue;
+	return KWTrue;
 
 } /*getrcnames*/
 
 /*--------------------------------------------------------------------*/
-/*       I s D O S                                                    */
+/*       I s D O S																	 */
 /*                                                                    */
-/*       Reports if current enviroment is DOS                         */
+/*       Reports if current enviroment is DOS								 */
 /*--------------------------------------------------------------------*/
 
 KWBoolean IsDOS( void )
 {
-   if ( ((unsigned long) active_env) & ENV_DOS )
-      return KWTrue;
-   else
-      return KWFalse;
+	if ( ((unsigned long) active_env) & ENV_DOS )
+		return KWTrue;
+	else
+		return KWFalse;
 
 } /* IsDOS */
 
@@ -1389,59 +1390,59 @@
 
 char *getregistry(char *envName, char **value)
 {
-   LONG result;
-   DWORD dwType;
-   char bData[BUFSIZ];
-   DWORD cbData = BUFSIZ;
-
-   *value = NULL;
-
-   if (uupcMachineKey == INVALID_HANDLE_VALUE)
-   {
-      result = RegOpenKey(HKEY_LOCAL_MACHINE, REGISTRYHIVE, &uupcMachineKey);
-
-      if (result != ERROR_SUCCESS)
-      {
-         printmsg(2, "getregistry: could not open LOCAL_MACHINE hive");
-         if (debuglevel > 1)
-            printNTerror("RegOpenKey", result);
-      }
-   }
-
-   if (uupcUserKey == INVALID_HANDLE_VALUE)
-   {
-      result = RegOpenKey(HKEY_CURRENT_USER, REGISTRYHIVE, &uupcUserKey);
-      if (result != ERROR_SUCCESS)
-      {
-         printmsg(2, "getregistry: could not open CURRENT_USER hive");
-         if (debuglevel > 1)
-            printNTerror("RegOpenKey", result);
-      }
-   }
-
-/*--------------------------------------------------------------------*/
-/*   Check the user's hive first, then the machine's hive             */
-/*--------------------------------------------------------------------*/
-
-   result = RegQueryValueEx(uupcUserKey, envName, NULL, &dwType, bData, &cbData);
-   if (result == ERROR_SUCCESS && dwType == REG_SZ)
-   {
-      printmsg(2, "Found user registry entry %s, value %s", envName, bData);
-      *value = newstr(bData);
-      return *value;
-   }
-
-   result = RegQueryValueEx(uupcMachineKey, envName, NULL, &dwType, bData, &cbData);
-
-   if (result == ERROR_SUCCESS && dwType == REG_SZ)
-   {
-      printmsg(2, "Found machine registry entry %s, value %s", envName, bData);
-      *value = newstr(bData);
-      return *value;
-   }
+	LONG result;
+	DWORD dwType;
+	char bData[BUFSIZ];
+	DWORD cbData = BUFSIZ;
+
+	*value = NULL;
+
+	if (uupcMachineKey == INVALID_HANDLE_VALUE)
+	{
+		result = RegOpenKey(HKEY_LOCAL_MACHINE, REGISTRYHIVE, &uupcMachineKey);
+
+		if (result != ERROR_SUCCESS)
+		{
+			printmsg(2, "getregistry: could not open LOCAL_MACHINE hive");
+			if (debuglevel > 1)
+				printNTerror("RegOpenKey", result);
+		}
+	}
+
+	if (uupcUserKey == INVALID_HANDLE_VALUE)
+	{
+		result = RegOpenKey(HKEY_CURRENT_USER, REGISTRYHIVE, &uupcUserKey);
+		if (result != ERROR_SUCCESS)
+		{
+			printmsg(2, "getregistry: could not open CURRENT_USER hive");
+			if (debuglevel > 1)
+				printNTerror("RegOpenKey", result);
+		}
+	}
+
+/*--------------------------------------------------------------------*/
+/*   Check the user's hive first, then the machine's hive				 */
+/*--------------------------------------------------------------------*/
+
+	result = RegQueryValueEx(uupcUserKey, envName, NULL, &dwType, bData, &cbData);
+	if (result == ERROR_SUCCESS && dwType == REG_SZ)
+	{
+		printmsg(2, "Found user registry entry %s, value %s", envName, bData);
+		*value = newstr(bData);
+		return *value;
+	}
+
+	result = RegQueryValueEx(uupcMachineKey, envName, NULL, &dwType, bData, &cbData);
+
+	if (result == ERROR_SUCCESS && dwType == REG_SZ)
+	{
+		printmsg(2, "Found machine registry entry %s, value %s", envName, bData);
+		*value = newstr(bData);
+		return *value;
+	}
 
-   *value = NULL;
-   return *value;
+	*value = NULL;
+	return *value;
 }
 
 #endif
--- e:\uupc1.12s\source\lib\EXECUTE.C	Sun Apr 20 13:10:40 1997
+++ EXECUTE.C	Sat Jul 26 15:49:16 1997
@@ -1,19 +1,19 @@
 /*--------------------------------------------------------------------*/
 /*       e x e c u t e . C                                            */
 /*                                                                    */
-/*       Execute an external command for UUPC/extended functions      */
+/*       Execute an external command for UUPC/extended functions		 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*       Changes Copyright (c) 1989-1997 by Kendra Electronic         */
-/*       Wonderworks.                                                 */
+/*       Changes Copyright (c) 1989-1997 by Kendra Electronic			 */
+/*       Wonderworks.																 */
 /*                                                                    */
-/*       All rights reserved except those explicitly granted by       */
-/*       the UUPC/extended license agreement.                         */
+/*       All rights reserved except those explicitly granted by		 */
+/*       the UUPC/extended license agreement.								 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                          RCS Information                           */
+/*                          RCS Information									 */
 /*--------------------------------------------------------------------*/
 
 /*
@@ -21,150 +21,150 @@
  *
  *    Revision history:
  *    $Log: execute.c $
- *    Revision 1.44  1997/03/31 07:12:17  ahd
+ *    Revision 1.44	1997/03/31 07:12:17	ahd
  *    COpyright update
  *    Restore previous title of window
  *
- *    Revision 1.43  1996/11/18 04:46:49  ahd
+ *    Revision 1.43	1996/11/18 04:46:49	ahd
  *    Normalize arguments to bugout
  *    Reset title after exec of sub-modules
  *    Normalize host status names to use HS_ prefix
  *
- *    Revision 1.42  1996/01/01 20:50:52  ahd
+ *    Revision 1.42	1996/01/01 20:50:52	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.41  1995/03/11 22:33:46  ahd
+ *    Revision 1.41	1995/03/11 22:33:46	ahd
  *    Blow off undelete processing if so configured under OS/2
  *
- *    Revision 1.40  1995/03/11 15:49:23  ahd
+ *    Revision 1.40	1995/03/11 15:49:23	ahd
  *    Clean up compiler warnings, modify dcp/dcpsys/nbstime for better msgs
  *
- *    Revision 1.39  1995/03/08 03:00:20  ahd
+ *    Revision 1.39	1995/03/08 03:00:20	ahd
  *    Work around IBM C/Set++ bug which generates spurious operand
  *    when no operands are passed to program.
  *
- *    Revision 1.38  1995/01/07 16:12:13  ahd
+ *    Revision 1.38	1995/01/07 16:12:13	ahd
  *    Change boolean to KWBoolean to avoid VC++ 2.0 conflict
  *
- *    Revision 1.37  1995/01/05 03:41:36  ahd
+ *    Revision 1.37	1995/01/05 03:41:36	ahd
  *    Print more precise error messages for file errors
  *
- *    Revision 1.36  1994/12/22 00:08:08  ahd
+ *    Revision 1.36	1994/12/22 00:08:08	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.35  1994/10/23 23:29:44  ahd
+ *    Revision 1.35	1994/10/23 23:29:44	ahd
  *    Under OS/2 and Windows NT, always use current window when processing
  *    synchronous commands.
  *
- * Revision 1.34  1994/10/02  20:47:38  ahd
+ * Revision 1.34	1994/10/02	20:47:38  ahd
  * Correct processing for synchronous command
  *
- * Revision 1.33  1994/08/08  00:21:00  ahd
+ * Revision 1.33	1994/08/08	00:21:00  ahd
  * Further OS/2 cleanup
  *
- * Revision 1.32  1994/08/07  21:28:54  ahd
+ * Revision 1.32	1994/08/07	21:28:54  ahd
  * Clean up OS/2 processing to not use new sessions, but rather simply user
  * command processor to allow firing off PM programs such as E and EPM.
  *
- * Revision 1.31  1994/05/23  22:47:23  ahd
+ * Revision 1.31	1994/05/23	22:47:23  ahd
  * Include commands ending in .cmd for ALL 32 bit environments
  *
- * Revision 1.30  1994/02/28  01:02:06  ahd
+ * Revision 1.30	1994/02/28	01:02:06  ahd
  * Reopen output file after input file.
  *
- * Revision 1.29  1994/02/19  04:39:30  ahd
+ * Revision 1.29	1994/02/19	04:39:30  ahd
  * Use standard first header
  *
- * Revision 1.28  1994/02/19  04:04:23  ahd
+ * Revision 1.28	1994/02/19	04:04:23  ahd
  * Use standard first header
  *
- * Revision 1.27  1994/02/19  03:47:51  ahd
+ * Revision 1.27	1994/02/19	03:47:51  ahd
  * Use standard first header
  *
- * Revision 1.26  1994/02/18  23:07:43  ahd
+ * Revision 1.26	1994/02/18	23:07:43  ahd
  * Use standard first header
  *
- * Revision 1.25  1994/02/14  01:03:56  ahd
+ * Revision 1.25	1994/02/14	01:03:56  ahd
  * Use properly sized buffer for executeCommand processing
  *
- * Revision 1.24  1994/02/13  13:52:33  rommel
+ * Revision 1.24	1994/02/13	13:52:33  rommel
  * Cosmetic changes to lower case file name extensions
  *
- * Revision 1.23  1994/01/01  19:01:27  ahd
+ * Revision 1.23	1994/01/01	19:01:27  ahd
  * Annual Copyright Update
  *
- * Revision 1.22  1993/12/29  02:46:47  ahd
+ * Revision 1.22	1993/12/29	02:46:47  ahd
  * Trap errors from dup2() calls
  *
- * Revision 1.21  1993/12/23  03:11:17  rommel
+ * Revision 1.21	1993/12/23	03:11:17  rommel
  * OS/2 32 bit support for additional compilers
  *
- * Revision 1.20  1993/12/06  01:59:07  ahd
+ * Revision 1.20	1993/12/06	01:59:07  ahd
  * Delete debug message from inner loop for search for internal commands
  *
- * Revision 1.19  1993/11/30  04:16:23  dmwatt
+ * Revision 1.19	1993/11/30	04:16:23  dmwatt
  * Add Windows NT executeAsync()
  *
- * Revision 1.18  1993/11/14  20:51:37  ahd
+ * Revision 1.18	1993/11/14	20:51:37  ahd
  * Correct Windows 3.1 compile error
  *
- * Revision 1.17  1993/11/13  17:37:02  ahd
+ * Revision 1.17	1993/11/13	17:37:02  ahd
  * Only use system() call for CMD files under OS/2
  *
- * Revision 1.16  1993/11/08  04:46:49  ahd
+ * Revision 1.16	1993/11/08	04:46:49  ahd
  * Add OS/2 specific support for seperate sessions
  *
- * Revision 1.15  1993/11/06  17:54:55  rhg
+ * Revision 1.15	1993/11/06	17:54:55  rhg
  * Drive Drew nuts by submitting cosmetic changes mixed in with bug fixes
  *
- * Revision 1.14  1993/10/30  17:10:40  rhg
+ * Revision 1.14	1993/10/30	17:10:40  rhg
  * Correct direction of redirection for Windows batch files
  *
- * Revision 1.13  1993/10/12  00:43:34  ahd
+ * Revision 1.13	1993/10/12	00:43:34  ahd
  * Normalize comments
  *
- * Revision 1.12  1993/10/09  15:46:15  rhg
+ * Revision 1.12	1993/10/09	15:46:15  rhg
  * ANSIify the source
  *
- * Revision 1.11  1993/10/03  22:09:09  ahd
+ * Revision 1.11	1993/10/03	22:09:09  ahd
  * Change debugging messages
  *
- * Revision 1.10  1993/10/02  22:56:59  ahd
+ * Revision 1.10	1993/10/02	22:56:59  ahd
  * Suppress compile warning
  *
- * Revision 1.9  1993/10/02  19:07:49  ahd
+ * Revision 1.9  1993/10/02  19:07:49	ahd
  * Suppress compiler warning
  *
- * Revision 1.8  1993/09/27  00:45:20  ahd
+ * Revision 1.8  1993/09/27  00:45:20	ahd
  * Fix Windows compile, add debug to OS/2 and DOS version
  *
- * Revision 1.7  1993/09/26  03:32:27  dmwatt
+ * Revision 1.7  1993/09/26  03:32:27	dmwatt
  * Use Standard Windows NT error message module
  *
- * Revision 1.6  1993/09/23  03:26:51  ahd
+ * Revision 1.6  1993/09/23  03:26:51	ahd
  * Use common file search routine
  *
- * Revision 1.5  1993/09/20  04:38:11  ahd
+ * Revision 1.5  1993/09/20  04:38:11	ahd
  * TCP/IP support from Dave Watt
  * 't' protocol support
  * OS/2 2.x support
  *
- * Revision 1.4  1993/08/08  17:39:09  ahd
+ * Revision 1.4  1993/08/08  17:39:09	ahd
  * Denormalize path for opening on selected networks
  *
- * Revision 1.3  1993/08/03  03:11:49  ahd
+ * Revision 1.3  1993/08/03  03:11:49	ahd
  * Further Windows 3.x fixes
  *
- * Revision 1.2  1993/08/02  03:24:59  ahd
+ * Revision 1.2  1993/08/02  03:24:59	ahd
  * Further changes in support of Robert Denny's Windows 3.x support
  *
- * Revision 1.1  1993/07/31  16:22:16  ahd
+ * Revision 1.1  1993/07/31  16:22:16	ahd
  * Initial revision
  *
  */
 
 /*--------------------------------------------------------------------*/
-/*                        System include files                        */
+/*                        System include files								 */
 /*--------------------------------------------------------------------*/
 
 #include "uupcmoah.h"
@@ -186,10 +186,14 @@
 #include <os2.h>
 #endif
 
+#ifdef __GCC__
+#include <stdlib.h>
+#else
 #include <direct.h>
+#endif
 
 /*--------------------------------------------------------------------*/
-/*                    UUPC/extended include files                     */
+/*                    UUPC/extended include files							 */
 /*--------------------------------------------------------------------*/
 
 #include "execute.h"
@@ -205,7 +209,7 @@
 #endif
 
 /*--------------------------------------------------------------------*/
-/*                          Local variables                           */
+/*                          Local variables									 */
 /*--------------------------------------------------------------------*/
 
 currentfile();
@@ -221,156 +225,156 @@
 #if defined(__OS2__) || defined(FAMILYAPI) || defined(WIN32)
 
 static int executeAsync( const char *command,
-                         const char *parameters,
-                         const KWBoolean synchronous,
-                         const KWBoolean foreground );
+								 const char *parameters,
+								 const KWBoolean synchronous,
+								 const KWBoolean foreground );
 #endif
 
 #ifdef _Windows
 
 /*--------------------------------------------------------------------*/
-/*       e x e c u t e                       (Windows 3.x version)    */
+/*       e x e c u t e								(Windows 3.x version)	 */
 /*                                                                    */
 /*       execute external command under Windows                       */
 /*--------------------------------------------------------------------*/
 
 int execute( const char *command,
-             const char *parameters,
-             const char *input,
-             const char *output,
-             const KWBoolean synchronous,
-             const KWBoolean foreground )
+				 const char *parameters,
+				 const char *input,
+				 const char *output,
+				 const KWBoolean synchronous,
+				 const KWBoolean foreground )
 {
-   int result;
+	int result;
 
-   KWBoolean useBat = (input != NULL) || (output != NULL );
+	KWBoolean useBat = (input != NULL) || (output != NULL );
 
-   char path[FILENAME_MAX];         /* String for executable file   */
-   char batchFile[FILENAME_MAX];    /* String for batch driver file */
-   char perfect[FILENAME_MAX];      /* String for results test file */
+	char path[FILENAME_MAX];			/* String for executable file   */
+	char batchFile[FILENAME_MAX];    /* String for batch driver file */
+	char perfect[FILENAME_MAX];		/* String for results test file */
 
 /*--------------------------------------------------------------------*/
 /*                    Validate command redirection                    */
 /*--------------------------------------------------------------------*/
 
-   if ( ((input != NULL) || (output != NULL)) && ! synchronous )
-   {
-      printmsg(0, "execute: Internal error, cannot redirect asynchronous"
-                  " command %s",
-                 command );
-      panic();
-   }
+	if ( ((input != NULL) || (output != NULL)) && ! synchronous )
+	{
+		printmsg(0, "execute: Internal error, cannot redirect asynchronous"
+						" command %s",
+					  command );
+		panic();
+	}
 
 /*--------------------------------------------------------------------*/
-/*                          Locate the command                        */
+/*                          Locate the command								 */
 /*--------------------------------------------------------------------*/
 
-   if ( internal( command ) )
-   {
-      strcpy( path , command );
-      useBat = KWTrue;
-   }
-   else if (batch( command, path ))
-   {
-      if (useBat)                      /* Using redirection?          */
-      {
-         printmsg(0,"Cannot use redirection with batch file %s",
-                     path );
-         return -2;
-      }
-   } /* else */
-   else if ( !*path )                  /* Error returned from search? */
-      return -1;                       /* Yes --> Error already reported */
+	if ( internal( command ) )
+	{
+		strcpy( path , command );
+		useBat = KWTrue;
+	}
+	else if (batch( command, path ))
+	{
+		if (useBat)                      /* Using redirection?			 */
+		{
+			printmsg(0,"Cannot use redirection with batch file %s",
+							path );
+			return -2;
+		}
+	} /* else */
+	else if ( !*path )						/* Error returned from search? */
+		return -1;								/* Yes --> Error already reported */
 
 /*--------------------------------------------------------------------*/
-/*     Generate a batch file for redirected DOS programs, if needed   */
+/*     Generate a batch file for redirected DOS programs, if needed	 */
 /*--------------------------------------------------------------------*/
 
-   if ( useBat )
-   {
-      FILE *stream ;
+	if ( useBat )
+	{
+		FILE *stream ;
 
-      mktempname( batchFile, "bat");
-      mktempname( perfect, "tmp");
-      stream = FOPEN( batchFile, "w", TEXT_MODE );
+		mktempname( batchFile, "bat");
+		mktempname( perfect, "tmp");
+		stream = FOPEN( batchFile, "w", TEXT_MODE );
 
-      if ( stream == NULL )
-      {
-         printmsg(0,"execute: Cannot generate batch file %s",
-                     batchFile );
-         printerr( batchFile );
-         panic();
-      }
+		if ( stream == NULL )
+		{
+			printmsg(0,"execute: Cannot generate batch file %s",
+							batchFile );
+			printerr( batchFile );
+			panic();
+		}
 
-      fprintf( stream ,
-               "@echo off\n%s %s",
-               path,
-               parameters == NULL ? "" : parameters );
+		fprintf( stream ,
+					"@echo off\n%s %s",
+					path,
+					parameters == NULL ? "" : parameters );
 
-      if ( input != NULL )
-         fprintf( stream, " < %s", input );
+		if ( input != NULL )
+			fprintf( stream, " < %s", input );
 
-      if ( output != NULL )
-         fprintf( stream, " > %s", output );
+		if ( output != NULL )
+			fprintf( stream, " > %s", output );
 
-      fprintf( stream,
-              "\nif errorlevel 1 erase %s\n",
-               perfect );
+		fprintf( stream,
+				  "\nif errorlevel 1 erase %s\n",
+					perfect );
 
-      fclose ( stream );
+		fclose ( stream );
 
-      stream = FOPEN( perfect, "w", TEXT_MODE );
-      if ( stream == NULL )
-      {
-         printmsg(0,"Cannot generate test batch file %s", perfect );
-         printerr( perfect );
-         panic();
-      }
+		stream = FOPEN( perfect, "w", TEXT_MODE );
+		if ( stream == NULL )
+		{
+			printmsg(0,"Cannot generate test batch file %s", perfect );
+			printerr( perfect );
+			panic();
+		}
 
-      fclose( stream );
+		fclose( stream );
 
-      strcpy( path, batchFile );             /* Run the batch command */
+		strcpy( path, batchFile );             /* Run the batch command */
 
-   } /* if ( useBat ) */
+	} /* if ( useBat ) */
 
 /*--------------------------------------------------------------------*/
-/*                       Actually run the command                     */
+/*                       Actually run the command							 */
 /*--------------------------------------------------------------------*/
 
-   result = SpawnWait( path,
-                       parameters,
-                       synchronous,
-                       foreground ? SW_MAXIMIZE : SW_SHOWMINNOACTIVE );
+	result = SpawnWait( path,
+							  parameters,
+							  synchronous,
+							  foreground ? SW_MAXIMIZE : SW_SHOWMINNOACTIVE );
 
 /*--------------------------------------------------------------------*/
-/*       For batch files, we can only report zero/non-zero            */
+/*       For batch files, we can only report zero/non-zero				 */
 /*       results.  Do so, and clean up our input file at the same     */
 /*       time.                                                        */
 /*--------------------------------------------------------------------*/
 
-   if ( useBat )
-   {
-      int unlinkResult = REMOVE( perfect );
+	if ( useBat )
+	{
+		int unlinkResult = REMOVE( perfect );
 
-      if (( result == 0 ) && (unlinkResult != 0))
-         result = 255;
+		if (( result == 0 ) && (unlinkResult != 0))
+			result = 255;
 
-      if (REMOVE( batchFile ))
-      {
+		if (REMOVE( batchFile ))
+		{
 
-         printmsg(0,"Cannot delete batch file %s", batchFile );
-         printerr( batchFile );
-      }
+			printmsg(0,"Cannot delete batch file %s", batchFile );
+			printerr( batchFile );
+		}
 
-   } /* if ( useBat ) */
+	} /* if ( useBat ) */
 
 /*--------------------------------------------------------------------*/
-/*                     Report results of command                      */
+/*                     Report results of command							 */
 /*--------------------------------------------------------------------*/
 
-   printmsg( 4,"Result of spawn %s is ... %d", command, result);
+	printmsg( 4,"Result of spawn %s is ... %d", command, result);
 
-   return result;
+	return result;
 
 } /* execute */
 
@@ -381,190 +385,190 @@
 #endif
 
 /*--------------------------------------------------------------------*/
-/*       e x e c u t e                 (OS/2, DOS, and NT version)    */
+/*       e x e c u t e						(OS/2, DOS, and NT version)	 */
 /*                                                                    */
-/*       Generic execute external command with optional redirection   */
-/*       of standard input and output                                 */
+/*       Generic execute external command with optional redirection	 */
+/*       of standard input and output											 */
 /*--------------------------------------------------------------------*/
 
 int execute( const char *command,
-             const char *parameters,
-             const char *input,
-             const char *output,
-             const KWBoolean synchronous,
-             const KWBoolean foreground )
+				 const char *parameters,
+				 const char *input,
+				 const char *output,
+				 const KWBoolean synchronous,
+				 const KWBoolean foreground )
 {
-   int result;
-   int tempHandle;
-   char path[BUFSIZ];
-
-   printmsg(3,"Command = %s, parameters = \"%s\"%s%s%s%s, %s, %s.",
-               command,
-               parameters,
-               input == NULL ? "" : ", input = ",
-               input == NULL ? "" : input,
-               output == NULL ? "" : ", output = ",
-               output == NULL ? "" : output,
-               synchronous ? "synchronous" : "asynchronous",
-               foreground  ? "foreground"  : "background" );
-
-/*--------------------------------------------------------------------*/
-/*               Redirect STDIN and STDOUT as required                */
-/*--------------------------------------------------------------------*/
-
-   if ( (input != NULL) || (output != NULL) )
-   {
-      if ( ! synchronous )
-      {
-         printmsg(0, "execute: Internal error, "
-                     "cannot redirect asynchronous command %s",
-                 command );
-         panic();
-
-      } /* if ( ! synchronous ) */
-   }
-
-   if (input != NULL)
-   {
-     if ((tempHandle = open(input, O_RDONLY|O_BINARY)) == -1)
-     {
-        printmsg(0,"execute: Cannot redirect input from %s",
-                    input );
-       printerr(input);
-       return -2;
-     }
-
-     if (dup2(tempHandle, 0))
-     {
-        printmsg(0,"execute: Cannot dup handle for %s",
-                    input );
-         printerr( input );
-         panic();
-     }
-     close(tempHandle);
-   }
-
-   if (output != NULL)
-   {
-     if ((tempHandle = open(output, O_RDWR|O_BINARY|O_CREAT|O_TRUNC, 0666)) == -1)
-     {
-        printmsg(0,"execute: Cannot redirect output to %s",
-                    output );
-       printerr( output );
-
-       if ( input != NULL )
-       {
-         FILE *tempStream = freopen(CONSOLE, "r", stdin);
-
-         if ( (tempStream == NULL) && (errno != 0) )
-         {
-            printmsg(0,"execute: Cannot reopen original standard in" );
-            printerr("stdin");
-            panic();
-         }
-         setvbuf( stdin, NULL, _IONBF, 0);
-
-      } /* if ( input != NULL ) */
-
-      return -2;
-
-     }
-
-     if (dup2(tempHandle, 1))
-     {
-         printmsg(0,"execute: Cannot original standard in" );
-         printerr( input );
-         panic();
-     }
-     close(tempHandle);
-
-   } /* if (output != NULL) */
-
-/*--------------------------------------------------------------------*/
-/*                  Execute the command in question                   */
-/*--------------------------------------------------------------------*/
-
-   strcpy(path, command);
-
-   if (internal(path) ||
-       batch(command, path))        /* Internal command or batch file? */
-   {
-
-      if ( parameters != NULL )
-      {
-         strcat( path, " ");
-         strcat( path, parameters );
-      }
-
-      result = system( path );
-
-   } /* if (internal(command)) */
-   else if ( ! *path )
-      result = -3;                  /* Flag we never ran command     */
-   else {
+	int result;
+	int tempHandle;
+	char path[BUFSIZ];
+
+	printmsg(3,"Command = %s, parameters = \"%s\"%s%s%s%s, %s, %s.",
+					command,
+					parameters,
+					input == NULL ? "" : ", input = ",
+					input == NULL ? "" : input,
+					output == NULL ? "" : ", output = ",
+					output == NULL ? "" : output,
+					synchronous ? "synchronous" : "asynchronous",
+					foreground	? "foreground"  : "background" );
+
+/*--------------------------------------------------------------------*/
+/*               Redirect STDIN and STDOUT as required					 */
+/*--------------------------------------------------------------------*/
+
+	if ( (input != NULL) || (output != NULL) )
+	{
+		if ( ! synchronous )
+		{
+			printmsg(0, "execute: Internal error, "
+							"cannot redirect asynchronous command %s",
+					  command );
+			panic();
+
+		} /* if ( ! synchronous ) */
+	}
+
+	if (input != NULL)
+	{
+	  if ((tempHandle = open(input, O_RDONLY|O_BINARY)) == -1)
+	  {
+		  printmsg(0,"execute: Cannot redirect input from %s",
+						  input );
+		 printerr(input);
+		 return -2;
+	  }
+
+	  if (dup2(tempHandle, 0))
+	  {
+		  printmsg(0,"execute: Cannot dup handle for %s",
+						  input );
+			printerr( input );
+			panic();
+	  }
+	  close(tempHandle);
+	}
+
+	if (output != NULL)
+	{
+	  if ((tempHandle = open(output, O_RDWR|O_BINARY|O_CREAT|O_TRUNC, 0666)) == -1)
+	  {
+		  printmsg(0,"execute: Cannot redirect output to %s",
+						  output );
+		 printerr( output );
+
+		 if ( input != NULL )
+		 {
+			FILE *tempStream = freopen(CONSOLE, "r", stdin);
+
+			if ( (tempStream == NULL) && (errno != 0) )
+			{
+				printmsg(0,"execute: Cannot reopen original standard in" );
+				printerr("stdin");
+				panic();
+			}
+			setvbuf( stdin, NULL, _IONBF, 0);
+
+		} /* if ( input != NULL ) */
+
+		return -2;
+
+	  }
+
+	  if (dup2(tempHandle, 1))
+	  {
+			printmsg(0,"execute: Cannot original standard in" );
+			printerr( input );
+			panic();
+	  }
+	  close(tempHandle);
+
+	} /* if (output != NULL) */
+
+/*--------------------------------------------------------------------*/
+/*                  Execute the command in question						 */
+/*--------------------------------------------------------------------*/
+
+	strcpy(path, command);
+
+	if (internal(path) ||
+		 batch(command, path))			/* Internal command or batch file? */
+	{
+
+		if ( parameters != NULL )
+		{
+			strcat( path, " ");
+			strcat( path, parameters );
+		}
+
+		result = system( path );
+
+	} /* if (internal(command)) */
+	else if ( ! *path )
+		result = -3;						/* Flag we never ran command		*/
+	else {
 
 #if defined(WIN32) || defined(__OS2__) || defined(FAMILYAPI)
 
-      result = executeAsync( path, parameters, synchronous, foreground );
+		result = executeAsync( path, parameters, synchronous, foreground );
 
 #else
 
-      result = spawnl(  P_WAIT,
-                        (char *) path,
+		result = spawnl(	P_WAIT,
+								(char *) path,
 #ifdef __IBMC__
-                        (char *) (parameters ? command : NULL),
+								(char *) (parameters ? command : NULL),
 #else
-                        (char *) command,
+								(char *) command,
 #endif
-                        (char *) parameters,
-                        NULL);
+								(char *) parameters,
+								NULL);
 
-      if (result == -1)       /* Did spawn fail?                   */
-         printerr(command);   /* Yes --> Report error              */
+		if (result == -1)       /* Did spawn fail?						 */
+			printerr(command);	/* Yes --> Report error              */
 
 #endif
 
-   } /* else */
+	} /* else */
 
-   setTitle( NULL);                 /* Restore previous title      */
+	setTitle( NULL);						/* Restore previous title		 */
 
 /*--------------------------------------------------------------------*/
-/*                  Re-open our standard i/o streams                  */
+/*                  Re-open our standard i/o streams						 */
 /*--------------------------------------------------------------------*/
 
-   if ( input != NULL )
-   {
-      FILE *tempStream = freopen(CONSOLE, "r", stdin);
+	if ( input != NULL )
+	{
+		FILE *tempStream = freopen(CONSOLE, "r", stdin);
 
-      if (tempStream == NULL)
-      {
-         printerr("execute:" CONSOLE);
-         panic();
-      }
+		if (tempStream == NULL)
+		{
+			printerr("execute:" CONSOLE);
+			panic();
+		}
 
-      setvbuf( stdin, NULL, _IONBF, 0);
+		setvbuf( stdin, NULL, _IONBF, 0);
 
-   } /* if ( input != NULL ) */
+	} /* if ( input != NULL ) */
 
-   if ( output != NULL )
-   {
-      FILE *tempStream = freopen(CONSOLE, "w", stdout);
+	if ( output != NULL )
+	{
+		FILE *tempStream = freopen(CONSOLE, "w", stdout);
 
-      if (tempStream == NULL)
-      {
-         printerr( "execute: " CONSOLE);
-         panic();
-      }
-      setvbuf( stdout, NULL, _IONBF, 0);
-   }
+		if (tempStream == NULL)
+		{
+			printerr( "execute: " CONSOLE);
+			panic();
+		}
+		setvbuf( stdout, NULL, _IONBF, 0);
+	}
 
 /*--------------------------------------------------------------------*/
-/*                     Report results of command                      */
+/*                     Report results of command							 */
 /*--------------------------------------------------------------------*/
 
-   printmsg( 4,"Result of spawn %s is ... %d", command, result);
+	printmsg( 4,"Result of spawn %s is ... %d", command, result);
 
-   return result;
+	return result;
 
 } /* execute */
 
@@ -575,260 +579,260 @@
 #endif
 
 /*--------------------------------------------------------------------*/
-/*       e x e c u t e C o m m a n d                                  */
+/*       e x e c u t e C o m m a n d											 */
 /*                                                                    */
-/*       Split command from its parameters for execute                */
+/*       Split command from its parameters for execute					 */
 /*--------------------------------------------------------------------*/
 
 int executeCommand( const char *command,
-                    const char *input,
-                    const char *output,
-                    const KWBoolean synchronous,
-                    const KWBoolean foreground )
+						  const char *input,
+						  const char *output,
+						  const KWBoolean synchronous,
+						  const KWBoolean foreground )
 {
-   char *cmdname;
-   char *parameters;
-   char buffer[BUFSIZ];
-   int result;
-
-   strcpy( buffer, command );
-
-   cmdname = strtok( buffer, WHITESPACE );
-   parameters = strtok( NULL, "\r\n" );
-
-   if ( parameters != NULL )
-   {
-      while (isspace( *parameters ) || iscntrl( *parameters ))
-         parameters++;
-
-      if ( !strlen( parameters ))
-         parameters = NULL;
-   }
-
-   result = execute( cmdname,
-                     parameters,
-                     input,
-                     output,
-                     synchronous,
-                     foreground );
+	char *cmdname;
+	char *parameters;
+	char buffer[BUFSIZ];
+	int result;
+
+	strcpy( buffer, command );
+
+	cmdname = strtok( buffer, WHITESPACE );
+	parameters = strtok( NULL, "\r\n" );
+
+	if ( parameters != NULL )
+	{
+		while (isspace( *parameters ) || iscntrl( *parameters ))
+			parameters++;
+
+		if ( !strlen( parameters ))
+			parameters = NULL;
+	}
+
+	result = execute( cmdname,
+							parameters,
+							input,
+							output,
+							synchronous,
+							foreground );
 
-   return result;
+	return result;
 
 } /* executeCommand */
 
 /*--------------------------------------------------------------------*/
-/*    i n t e r n a l                                                 */
+/*    i n t e r n a l																 */
 /*                                                                    */
 /*    Determine if command is internal DOS command                    */
 /*--------------------------------------------------------------------*/
 
 static KWBoolean internal( const char *command )
 {
-   static char *commands[] = { "break",   "cd",    "chdir",    "copy",
-                               "ctty",    "date",  "del",      "dir",
-                               "echo",    "erase", "for",      "md",
-                               "mkdir",   "rd",    "rem",      "ren",
-                               "rename",  "rmdir", "time",     "type",
-                               "ver",     "verify",  "vol",
-                               NULL };
-   char **list;
-
-/*--------------------------------------------------------------------*/
-/*       Empty commands are a special signal to use the command       */
-/*       processor to run the arguments.                              */
-/*--------------------------------------------------------------------*/
-
-   if ( *command == '\0' )
-   {
-      printmsg(4,"internal: Empty command, using command processor");
-      return KWTrue;
-   }
+	static char *commands[] = { "break",	"cd",    "chdir",    "copy",
+										 "ctty",    "date",	"del",		"dir",
+										 "echo",    "erase", "for",		"md",
+										 "mkdir",	"rd",    "rem",		"ren",
+										 "rename",	"rmdir", "time",		"type",
+										 "ver",		"verify",  "vol",
+										 NULL };
+	char **list;
+
+/*--------------------------------------------------------------------*/
+/*       Empty commands are a special signal to use the command		 */
+/*       processor to run the arguments.										 */
+/*--------------------------------------------------------------------*/
+
+	if ( *command == '\0' )
+	{
+		printmsg(4,"internal: Empty command, using command processor");
+		return KWTrue;
+	}
 
 /*--------------------------------------------------------------------*/
 /*                   Determine command list to use                    */
 /*--------------------------------------------------------------------*/
 
-   if (E_internal == NULL )
-      list = commands;
-   else
-      list = E_internal;
+	if (E_internal == NULL )
+		list = commands;
+	else
+		list = E_internal;
 
 /*--------------------------------------------------------------------*/
 /*                   Scan the list for the command                    */
 /*--------------------------------------------------------------------*/
 
-   while( *list != NULL )
-   {
-      if (equali(*list++,command))
-      {
-         printmsg(4,"\"%s\" is an internal command",command);
-         return KWTrue;
-      } /* if */
+	while( *list != NULL )
+	{
+		if (equali(*list++,command))
+		{
+			printmsg(4,"\"%s\" is an internal command",command);
+			return KWTrue;
+		} /* if */
 
-   } /* while( *list != NULL ) */
+	} /* while( *list != NULL ) */
 
 /*--------------------------------------------------------------------*/
 /*       The command is not in the list; return KWFalse (external      */
 /*       command)                                                     */
 /*--------------------------------------------------------------------*/
 
-   printmsg(4,"\"%s\" is an external command",command);
-   return KWFalse;
+	printmsg(4,"\"%s\" is an external command",command);
+	return KWFalse;
 
 } /* internal */
 
 /*--------------------------------------------------------------------*/
-/*    b a t c h                                                       */
+/*    b a t c h																		 */
 /*                                                                    */
-/*    Determine if a command is batch file                            */
+/*    Determine if a command is batch file									 */
 /*--------------------------------------------------------------------*/
 
 static KWBoolean batch( const char *input, char *output)
 {
-   char *search = getenv("PATH");
-   char *gotPath;
-   char *period;
+	char *search = getenv("PATH");
+	char *gotPath;
+	char *period;
 
-   static const char *extensions[] = { ".exe",
-                                       ".com",
+	static const char *extensions[] = { ".exe",
+													".com",
 #if (!defined(_DOS) && !defined(_Windows)) || defined(BIT32ENV)
-                                       ".cmd",
+													".cmd",
 #endif
-                                       ".bat",
-                                       NULL };
+													".bat",
+													NULL };
 
 /*--------------------------------------------------------------------*/
-/*                  Validate the search path exists                   */
+/*                  Validate the search path exists						 */
 /*--------------------------------------------------------------------*/
 
-   if ( search == NULL )
-   {
-      printmsg(0,"batch: Unable to retrieve PATH environment variable!");
-      panic();
-   }
+	if ( search == NULL )
+	{
+		printmsg(0,"batch: Unable to retrieve PATH environment variable!");
+		panic();
+	}
 
 /*--------------------------------------------------------------------*/
-/*        Determine if we have path, and if we have an extension      */
+/*        Determine if we have path, and if we have an extension		 */
 /*--------------------------------------------------------------------*/
 
-   gotPath = strchr( input, '/');
-   if ( gotPath == NULL )
-      gotPath = strchr( input, '\\');
+	gotPath = strchr( input, '/');
+	if ( gotPath == NULL )
+		gotPath = strchr( input, '\\');
 
-   period = strchr( (gotPath == NULL) ? input : gotPath, '.');
+	period = strchr( (gotPath == NULL) ? input : gotPath, '.');
 
-   if ( period != NULL )         /*    We have extension?             */
-   {
-      if ( gotPath )             /* Extension + path?                 */
-      {                          /* Yes --> Just look for the file    */
+	if ( period != NULL )			/*    We have extension?				 */
+	{
+		if ( gotPath )             /* Extension + path?                 */
+		{									/* Yes --> Just look for the file	 */
 
-         char *fname = normalize( input );
+			char *fname = normalize( input );
 
-         if ( access( input, 00))
-            *output = '\0';
-         else
-            strcpy( output, fname );
+			if ( access( input, 00))
+				*output = '\0';
+			else
+				strcpy( output, fname );
 
-      } /* if ( gotPath ) */
-      else
-         _searchenv( (char *) input, "PATH", output );
+		} /* if ( gotPath ) */
+		else
+			_searchenv( (char *) input, "PATH", output );
 
-      if ( ! *output )           /* No file found?                    */
-      {
+		if ( ! *output )				/* No file found?                    */
+		{
 
-         printerr( input );
-         return KWFalse;
+			printerr( input );
+			return KWFalse;
 
-      }  /* if ( ! *output ) */
+		}	/* if ( ! *output ) */
 
 #if defined(_DOS) || defined(_Windows)
-      return equal( period, ".bat" );
+		return equal( period, ".bat" );
 #else
 
-      if (equali( period, ".cmd" ) || equali( period, ".bat" ))
-         return KWTrue;
-      else
-         return KWFalse;
+		if (equali( period, ".cmd" ) || equali( period, ".bat" ))
+			return KWTrue;
+		else
+			return KWFalse;
 #endif
 
-   } /* if ( p != NULL ) */
+	} /* if ( p != NULL ) */
 
 /*--------------------------------------------------------------------*/
-/*       Walk the path looking for the file's possible types in       */
-/*       the path's directories                                       */
+/*       Walk the path looking for the file's possible types in		 */
+/*       the path's directories													 */
 /*--------------------------------------------------------------------*/
 
-   while( *search )
-   {
-      char base[FILENAME_MAX];
-      int extension = 0;
+	while( *search )
+	{
+		char base[FILENAME_MAX];
+		int extension = 0;
 
-      if ( gotPath )
-      {
-         strcpy( base, input );
-         search = "";                        /* Force this to be last pass */
-      }
-      else {
+		if ( gotPath )
+		{
+			strcpy( base, input );
+			search = "";								/* Force this to be last pass */
+		}
+		else {
 
-         char *next = strchr(search,';');    /* Find next path component */
-         size_t len;
+			char *next = strchr(search,';');    /* Find next path component */
+			size_t len;
 
-         if ( next == NULL )
-            len = strlen( search );
-         else
-            len = (size_t) (next - search);
+			if ( next == NULL )
+				len = strlen( search );
+			else
+				len = (size_t) (next - search);
 
-         memcpy( base, search, len );        /* Path for search ...   */
-         search += len + 1;                  /* Step past semicolon   */
-         if ( base[len - 1 ] != '\\' )       /* Ending in back slash? */
-            base[len++] = '\\';              /* No --> Add one        */
-         strcpy( base + len , input );       /* ... plus file name    */
+			memcpy( base, search, len );			/* Path for search ...	 */
+			search += len + 1;						/* Step past semicolon	 */
+			if ( base[len - 1 ] != '\\' )       /* Ending in back slash? */
+				base[len++] = '\\';					/* No --> Add one        */
+			strcpy( base + len , input );       /* ... plus file name	 */
 
-      } /* else */
+		} /* else */
 
-      printmsg(8,
-               "Searching for extension of %s",
-               base );
+		printmsg(8,
+					"Searching for extension of %s",
+					base );
 
 /*--------------------------------------------------------------------*/
-/*       Search a single directory in a path for a file with          */
-/*       various extensions.                                          */
+/*       Search a single directory in a path for a file with			 */
+/*       various extensions.														 */
 /*--------------------------------------------------------------------*/
 
-      while( extensions[extension] != NULL )
-      {
-         strcpy( output, base );
-         strcat( output, extensions[extension] );
+		while( extensions[extension] != NULL )
+		{
+			strcpy( output, base );
+			strcat( output, extensions[extension] );
 
-         if ( ! access(output, 00 ))
-         {
+			if ( ! access(output, 00 ))
+			{
 
 #if defined(_DOS) || defined(_Windows)
-            return equal( extensions[extension] , ".bat" );
+				return equal( extensions[extension] , ".bat" );
 #else
-            if (equal( extensions[extension] , ".cmd" ) ||
-                   equal( extensions[extension] , ".bat" ))
-               return KWTrue;
-            else
-               return KWFalse;
+				if (equal( extensions[extension] , ".cmd" ) ||
+						 equal( extensions[extension] , ".bat" ))
+					return KWTrue;
+				else
+					return KWFalse;
 #endif
-         } /* if ( result != NULL ) */
+			} /* if ( result != NULL ) */
 
-         extension++;
+			extension++;
 
-      }  /* while( extensions[extension] != NULL ) */
+		}	/* while( extensions[extension] != NULL ) */
 
-   } /* while( *search ) */
+	} /* while( *search ) */
 
 /*--------------------------------------------------------------------*/
 /*       We could not find the file, report failure to the caller     */
 /*--------------------------------------------------------------------*/
 
-   printmsg(0, "batch: Unable to locate %s in search path", input);
+	printmsg(0, "batch: Unable to locate %s in search path", input);
 
-   *output = '\0';                  /* Flag no file found!            */
+	*output = '\0';						/* Flag no file found!				 */
 
-   return KWFalse;
+	return KWFalse;
 
 } /* batch */
 
@@ -841,46 +845,46 @@
 /*--------------------------------------------------------------------*/
 
 static int executeAsync( const char *command,
-                         const char *parameters,
-                         const KWBoolean synchronous,
-                         const KWBoolean foreground )
+								 const char *parameters,
+								 const KWBoolean synchronous,
+								 const KWBoolean foreground )
 {
-   STARTDATA sd;
-   PID   childPID;
-   static int instance = 0;      /* Number of program we've invoke   */
-
-   char  queueName[FILENAME_MAX];
-   PVOID queueDataAddress;
-   BYTE  queueElementPriority;
-   HQUEUE queueHandle;
+	STARTDATA sd;
+	PID	childPID;
+	static int instance = 0;		/* Number of program we've invoke	*/
+
+	char	queueName[FILENAME_MAX];
+	PVOID queueDataAddress;
+	BYTE	queueElementPriority;
+	HQUEUE queueHandle;
 
 #ifdef __OS2__
-   APIRET rc;
-   REQUESTDATA  queueRequest;
-   ULONG sessID;
-   ULONG queueDataLength;
+	APIRET rc;
+	REQUESTDATA  queueRequest;
+	ULONG sessID;
+	ULONG queueDataLength;
 #else
-   USHORT rc;
-   QUEUERESULT  queueRequest;
-   USHORT sessID;
-   USHORT queueDataLength;
+	USHORT rc;
+	QUEUERESULT  queueRequest;
+	USHORT sessID;
+	USHORT queueDataLength;
 
 #ifndef SSF_RELATED_CHILD
 
-   #define SSF_RELATED_INDEPENDENT 0
-   #define SSF_RELATED_CHILD       1
+	#define SSF_RELATED_INDEPENDENT 0
+	#define SSF_RELATED_CHILD		  1
 
-   #define SSF_FGBG_FORE           0
-   #define SSF_FGBG_BACK           1
+	#define SSF_FGBG_FORE			  0
+	#define SSF_FGBG_BACK			  1
 
-   #define SSF_TRACEOPT_NONE       0
+	#define SSF_TRACEOPT_NONE		  0
 
-   #define SSF_INHERTOPT_PARENT    1
+	#define SSF_INHERTOPT_PARENT	  1
 
-   #define SSF_TYPE_DEFAULT        0
+	#define SSF_TYPE_DEFAULT		  0
 
-   #define SSF_CONTROL_MAXIMIZE    0x0002
-   #define SSF_CONTROL_MINIMIZE    0x0004
+	#define SSF_CONTROL_MAXIMIZE	  0x0002
+	#define SSF_CONTROL_MINIMIZE	  0x0004
 
 #endif  /* SSF_RELATED_CHILD */
 #endif
@@ -890,125 +894,125 @@
 /*       insures redirected input is processed properly.              */
 /*--------------------------------------------------------------------*/
 
-   if ( synchronous )
-   {
-      int result = spawnl(  P_WAIT,
-                            (char *) command,
-                            (char *) command,
-                            (char *) parameters,
-                            NULL);
+	if ( synchronous )
+	{
+		int result = spawnl(  P_WAIT,
+									 (char *) command,
+									 (char *) command,
+									 (char *) parameters,
+									 NULL);
 
-      if (result == -1)       /* Did spawn fail?                   */
-         printerr(command);   /* Yes --> Report error              */
+		if (result == -1)       /* Did spawn fail?						 */
+			printerr(command);	/* Yes --> Report error              */
 
-      return result;
+		return result;
 
-   } /*  */
+	} /*	*/
 
 /*--------------------------------------------------------------------*/
-/*              Initialize the start session parameters               */
+/*              Initialize the start session parameters					 */
 /*--------------------------------------------------------------------*/
 
-   memset( (void *) &sd, 0, sizeof sd );
+	memset( (void *) &sd, 0, sizeof sd );
 
-   sd.Length      = 32;          /* Just basic info + InheritOpt     */
+	sd.Length		= 32;          /* Just basic info + InheritOpt		*/
 
-   sd.FgBg        = (USHORT) (foreground ? SSF_FGBG_FORE : SSF_FGBG_BACK);
-   sd.TraceOpt    = SSF_TRACEOPT_NONE;
-   sd.PgmName     = (PSZ) command;
-   sd.PgmInputs   = (PSZ) parameters;
-   sd.Environment = 0;           /* Just use our own envionment      */
-   sd.InheritOpt  = SSF_INHERTOPT_PARENT; /* Pass it to child        */
-   sd.SessionType = SSF_TYPE_DEFAULT;     /* Let the system pick
-                                             session type            */
-   sd.PgmControl  = (USHORT) (foreground ?
-                        SSF_CONTROL_MAXIMIZE : SSF_CONTROL_MINIMIZE);
+	sd.FgBg			= (USHORT) (foreground ? SSF_FGBG_FORE : SSF_FGBG_BACK);
+	sd.TraceOpt    = SSF_TRACEOPT_NONE;
+	sd.PgmName		= (PSZ) command;
+	sd.PgmInputs	= (PSZ) parameters;
+	sd.Environment = 0;				/* Just use our own envionment		*/
+	sd.InheritOpt	= SSF_INHERTOPT_PARENT; /* Pass it to child			*/
+	sd.SessionType = SSF_TYPE_DEFAULT;		/* Let the system pick
+															session type				*/
+	sd.PgmControl	= (USHORT) (foreground ?
+								SSF_CONTROL_MAXIMIZE : SSF_CONTROL_MINIMIZE);
 
 /*--------------------------------------------------------------------*/
-/*       Build the queue to listen for the subtask ending.  This      */
-/*       code is actually correct, but ignored since we returned      */
+/*       Build the queue to listen for the subtask ending.	This		 */
+/*       code is actually correct, but ignored since we returned		 */
 /*       after spawn() above.                                         */
 /*--------------------------------------------------------------------*/
 
-   if ( synchronous )
-   {
-      sprintf(queueName,
-              "\\queues\\pid%d\\pgm%d",
-              (int) getpid(),
-              instance++);
+	if ( synchronous )
+	{
+		sprintf(queueName,
+				  "\\queues\\pid%d\\pgm%d",
+				  (int) getpid(),
+				  instance++);
 
-      rc = DosCreateQueue( &queueHandle,
+		rc = DosCreateQueue( &queueHandle,
 #ifdef __OS2__
-                           QUE_FIFO | QUE_CONVERT_ADDRESS,
+									QUE_FIFO | QUE_CONVERT_ADDRESS,
 #else
-                           QUE_FIFO,
+									QUE_FIFO,
 #endif
-                           (PSZ) queueName );
+									(PSZ) queueName );
 
-      if ( rc )
-      {
-         printOS2error( queueName, rc );
-         return -4;                 /* Report command never was run     */
-      }
+		if ( rc )
+		{
+			printOS2error( queueName, rc );
+			return -4;						/* Report command never was run		*/
+		}
 
-      sd.TermQ       = (PSZ) queueName;
-      sd.Related     = SSF_RELATED_CHILD;       /* Child session        */
+		sd.TermQ       = (PSZ) queueName;
+		sd.Related		= SSF_RELATED_CHILD;       /* Child session			*/
 
-   } /* if ( synchronous ) */
-   else {
+	} /* if ( synchronous ) */
+	else {
 
-      sd.TermQ       = (PSZ) 0;     /* Don't wait for session end       */
-      sd.Related     = SSF_RELATED_INDEPENDENT; /* Not a child session  */
+		sd.TermQ       = (PSZ) 0;		/* Don't wait for session end       */
+		sd.Related		= SSF_RELATED_INDEPENDENT; /* Not a child session	*/
 
-   } /* else */
+	} /* else */
 
-   rc = DosStartSession( &sd,
-                         &sessID,
-                         &childPID );
+	rc = DosStartSession( &sd,
+								 &sessID,
+								 &childPID );
 
-   if ( rc )
-   {
-      printOS2error( command ? command : parameters, rc );
-      return -5;
-   }
+	if ( rc )
+	{
+		printOS2error( command ? command : parameters, rc );
+		return -5;
+	}
 
 /*--------------------------------------------------------------------*/
-/*      If the command is running asynchonously return to caller      */
+/*      If the command is running asynchonously return to caller		 */
 /*--------------------------------------------------------------------*/
 
-   if ( ! synchronous )
-      return 0;
+	if ( ! synchronous )
+		return 0;
 
 /*--------------------------------------------------------------------*/
-/*                   Wait for the child to complete                   */
+/*                   Wait for the child to complete						 */
 /*--------------------------------------------------------------------*/
 
-   memset( (void *) &queueRequest, 0, sizeof queueRequest );
+	memset( (void *) &queueRequest, 0, sizeof queueRequest );
 
-   rc = DosReadQueue( queueHandle,
-                      &queueRequest,
-                      &queueDataLength,
-                      &queueDataAddress,
-                      0,            /* First element in the queue    */
-                      0,            /* Wait for queue to be ready    */
-                      &queueElementPriority,
-                      0);           /* Semaphore handle -- not used  */
+	rc = DosReadQueue( queueHandle,
+							 &queueRequest,
+							 &queueDataLength,
+							 &queueDataAddress,
+							 0,				/* First element in the queue    */
+							 0,				/* Wait for queue to be ready    */
+							 &queueElementPriority,
+							 0);				/* Semaphore handle -- not used	*/
 
-   if ( rc )
-   {
-      printOS2error( queueName, rc );
-      panic();
-   }
+	if ( rc )
+	{
+		printOS2error( queueName, rc );
+		panic();
+	}
 
-   rc = ((unsigned short FAR*) queueDataAddress)[1];
+	rc = ((unsigned short FAR*) queueDataAddress)[1];
 
 #ifdef __OS2__
-   DosFreeMem( queueDataAddress );
+	DosFreeMem( queueDataAddress );
 #else
-   DosFreeSeg( SELECTOROF(queueDataAddress) );
+	DosFreeSeg( SELECTOROF(queueDataAddress) );
 #endif
 
-   return (int) rc;
+	return (int) rc;
 
 } /* executeAsync */
 
@@ -1017,104 +1021,104 @@
 /*--------------------------------------------------------------------*/
 /*    e x e c u t e A s y n c                   (Windows NT version)  */
 /*                                                                    */
-/*    Execute an external program                                     */
+/*    Execute an external program												 */
 /*--------------------------------------------------------------------*/
 
 int executeAsync( const char *command,
-             const char *parameters,
-             const KWBoolean synchronous,
-             const KWBoolean foreground )
+				 const char *parameters,
+				 const KWBoolean synchronous,
+				 const KWBoolean foreground )
 {
-   int result;
-   char path[BUFSIZ];
-   STARTUPINFO si;
-   PROCESS_INFORMATION pi;
-   void *oldCtrlCHandler;
-   DWORD fdwCreate;
+	int result;
+	char path[BUFSIZ];
+	STARTUPINFO si;
+	PROCESS_INFORMATION pi;
+	void *oldCtrlCHandler;
+	DWORD fdwCreate;
 
 /*--------------------------------------------------------------------*/
-/*                  Execute the command in question                   */
+/*                  Execute the command in question						 */
 /*--------------------------------------------------------------------*/
 
-   strcpy(path, command);
+	strcpy(path, command);
 
-   if ( ! *path )                /* Did search fail?               */
-      return -2;                 /* Yes --> Msg issued, just return */
+	if ( ! *path )                /* Did search fail?					 */
+		return -2;						/* Yes --> Msg issued, just return */
 
-   memset(&si, 0, sizeof(STARTUPINFO));
-   si.cb = sizeof(STARTUPINFO);
-   si.lpTitle = (LPSTR)command;
-   si.dwFlags = STARTF_USESHOWWINDOW;
-   si.wShowWindow = foreground ? SW_MAXIMIZE : SW_SHOWMINNOACTIVE;
+	memset(&si, 0, sizeof(STARTUPINFO));
+	si.cb = sizeof(STARTUPINFO);
+	si.lpTitle = (LPSTR)command;
+	si.dwFlags = STARTF_USESHOWWINDOW;
+	si.wShowWindow = foreground ? SW_MAXIMIZE : SW_SHOWMINNOACTIVE;
 
-   if (parameters != NULL)
-   {
-      strcat( path, " ");
-      strcat( path, parameters );
-   }
+	if (parameters != NULL)
+	{
+		strcat( path, " ");
+		strcat( path, parameters );
+	}
 
-   if (synchronous)
-      fdwCreate = 0;
-   else
-      fdwCreate = CREATE_NEW_CONSOLE;
+	if (synchronous)
+		fdwCreate = 0;
+	else
+		fdwCreate = CREATE_NEW_CONSOLE;
 
-   result = CreateProcess(NULL,
-                          path,
-                          NULL,
-                          NULL,
-                          KWTrue,
-                          fdwCreate,
-                          NULL,
-                          NULL,
-                          &si,
-                          &pi);
+	result = CreateProcess(NULL,
+								  path,
+								  NULL,
+								  NULL,
+								  KWTrue,
+								  fdwCreate,
+								  NULL,
+								  NULL,
+								  &si,
+								  &pi);
 
-   if (!result)                  /* Did CreateProcess() fail?      */
-   {                             /* Yes --> Report error           */
-      DWORD dwError = GetLastError();
-      printmsg(0, "execute:  CreateProcess failed");
-      printNTerror("CreateProcess", dwError);
-   }
-   else {
+	if (!result)						/* Did CreateProcess() fail?		 */
+	{										/* Yes --> Report error           */
+		DWORD dwError = GetLastError();
+		printmsg(0, "execute:  CreateProcess failed");
+		printNTerror("CreateProcess", dwError);
+	}
+	else {
 
-      if (synchronous)
-      {
+		if (synchronous)
+		{
 
 /*--------------------------------------------------------------------*/
-/*       Set things up so that we ignore Ctrl-C's coming in to the    */
-/*       child, and wait for other application to finish.             */
+/*       Set things up so that we ignore Ctrl-C's coming in to the	 */
+/*       child, and wait for other application to finish.				 */
 /*--------------------------------------------------------------------*/
 
-         oldCtrlCHandler = signal(SIGINT, SIG_IGN);
+			oldCtrlCHandler = signal(SIGINT, SIG_IGN);
 
-         WaitForSingleObject(pi.hProcess, INFINITE);
-         GetExitCodeProcess(pi.hProcess, &result);
+			WaitForSingleObject(pi.hProcess, INFINITE);
+			GetExitCodeProcess(pi.hProcess, &result);
 
-         signal(SIGINT, oldCtrlCHandler); /* Re-enable Ctrl-C handling */
+			signal(SIGINT, oldCtrlCHandler); /* Re-enable Ctrl-C handling */
 
-      }  /* if (synchronous) */
-      else
-         result = 0;
+		}	/* if (synchronous) */
+		else
+			result = 0;
 
 /*--------------------------------------------------------------------*/
-/*       If we're spawning asynchronously, we assume that we don't    */
+/*       If we're spawning asynchronously, we assume that we don't	 */
 /*       care about the exit code from the spawned process.           */
-/*       Closing these makes it impossible to get at the old          */
+/*       Closing these makes it impossible to get at the old			 */
 /*       process's exit code.                                         */
 /*--------------------------------------------------------------------*/
 
-      CloseHandle(pi.hProcess);
-      CloseHandle(pi.hThread);
+		CloseHandle(pi.hProcess);
+		CloseHandle(pi.hThread);
 
-   } /* else !result */
+	} /* else !result */
 
 /*--------------------------------------------------------------------*/
-/*                     Report results of command                      */
+/*                     Report results of command							 */
 /*--------------------------------------------------------------------*/
 
-   printmsg( 4 ,"Result of spawn %s is ... %d", command, result);
+	printmsg( 4 ,"Result of spawn %s is ... %d", command, result);
 
-   return result;
+	return result;
 
 } /* executeAsync */
 
--- e:\uupc1.12s\source\lib\EXPATH.C	Sun Mar 30 22:58:48 1997
+++ EXPATH.C	Fri Jul 25 22:11:48 1997
@@ -1,19 +1,19 @@
 /*--------------------------------------------------------------------*/
-/*    e x p a t h . c                                                 */
+/*    e x p a t h . c																 */
 /*                                                                    */
-/*    Path expansion functions for UUPC/extended                      */
+/*    Path expansion functions for UUPC/extended							 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*       Changes Copyright (c) 1989-1997 by Kendra Electronic         */
-/*       Wonderworks.                                                 */
+/*       Changes Copyright (c) 1989-1997 by Kendra Electronic			 */
+/*       Wonderworks.																 */
 /*                                                                    */
-/*       All rights reserved except those explicitly granted by       */
-/*       the UUPC/extended license agreement.                         */
+/*       All rights reserved except those explicitly granted by		 */
+/*       the UUPC/extended license agreement.								 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                          RCS Information                           */
+/*                          RCS Information									 */
 /*--------------------------------------------------------------------*/
 
 /*
@@ -21,34 +21,34 @@
  *
  *    Revision history:
  *    $Log: expath.c $
- *    Revision 1.23  1997/03/31 06:58:55  ahd
+ *    Revision 1.23	1997/03/31 06:58:55	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.22  1996/01/01 20:51:04  ahd
+ *    Revision 1.22	1996/01/01 20:51:04	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.21  1995/02/14 04:38:42  ahd
+ *    Revision 1.21	1995/02/14 04:38:42	ahd
  *    Correct problems with directory processing under NT
  *
- *    Revision 1.20  1995/02/12 23:37:04  ahd
+ *    Revision 1.20	1995/02/12 23:37:04	ahd
  *    compiler cleanup, NNS C/news support, optimize dir processing
  *
- *    Revision 1.19  1995/01/30 04:05:08  ahd
+ *    Revision 1.19	1995/01/30 04:05:08	ahd
  *    Additional compiler warning fixes, optimize path normalizing
  *
- *    Revision 1.18  1995/01/29 16:43:03  ahd
+ *    Revision 1.18	1995/01/29 16:43:03	ahd
  *    IBM C/Set compiler warnings
  *
- *    Revision 1.17  1995/01/28 23:13:11  ahd
+ *    Revision 1.17	1995/01/28 23:13:11	ahd
  *    Use isAbsolutePath()
  *
- *    Revision 1.16  1995/01/07 16:12:21  ahd
+ *    Revision 1.16	1995/01/07 16:12:21	ahd
  *    Change KWBoolean to KWBoolean to avoid VC++ 2.0 conflict
  *
- *    Revision 1.15  1994/12/22 00:08:15  ahd
+ *    Revision 1.15	1994/12/22 00:08:15	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.14  1994/02/19 04:40:47  ahd
+ *    Revision 1.14	1994/02/19 04:40:47	ahd
  *    Use standard first header
  *
  *     Revision 1.13  1994/02/19  04:05:26  ahd
@@ -63,16 +63,16 @@
  *     Revision 1.10  1994/01/01  19:01:38  ahd
  *     Annual Copyright Update
  *
- *     Revision 1.9  1993/11/06  17:54:55  rhg
+ *     Revision 1.9	1993/11/06	17:54:55  rhg
  *     Drive Drew nuts by submitting cosmetic changes mixed in with bug fixes
  *
- *     Revision 1.8  1993/10/30  17:10:40  rhg
+ *     Revision 1.8	1993/10/30	17:10:40  rhg
  *     Be more conservative about the need to push to new directory
  *
- *     Revision 1.7  1993/10/12  00:43:34  ahd
+ *     Revision 1.7	1993/10/12	00:43:34  ahd
  *     Normalize comments
  *
- *     Revision 1.6  1993/08/08  17:39:09  ahd
+ *     Revision 1.6	1993/08/08	17:39:09  ahd
  *     Denormalize path for opening on selected networks
  *
  */
@@ -85,10 +85,14 @@
 
 #include <ctype.h>
 
+#ifdef __GCC__
+#include <stdlib.h>
+#else
 #include <direct.h>
+#endif
 
 /*--------------------------------------------------------------------*/
-/*                     UUPC/extended header files                     */
+/*                     UUPC/extended header files							 */
 /*--------------------------------------------------------------------*/
 
 #include "expath.h"
@@ -98,195 +102,201 @@
 #include "pushpop.h"
 
 /*--------------------------------------------------------------------*/
-/*                          Local variables                           */
+/*                          Local variables									 */
 /*--------------------------------------------------------------------*/
 
 currentfile();
 
 /*--------------------------------------------------------------------*/
-/*   e x p a n d _ p a t  h                                           */
+/*   e x p a n d _ p a t  h														 */
 /*                                                                    */
-/*   Expands ~, ~/ and relative paths                                 */
+/*   Expands ~, ~/ and relative paths											 */
 /*--------------------------------------------------------------------*/
 
-char *expand_path(char *input,         /* Input/output path name      */
-                  const char *cur_dir, /* Default directory path      */
-                  const char *home,    /* Default home directory      */
-                  const char *ftype )  /* Default extension           */
+char *expand_path(char *input,			/* Input/output path name		 */
+						const char *cur_dir, /* Default directory path		 */
+						const char *home,    /* Default home directory		 */
+						const char *ftype )	/* Default extension           */
 {
-   char        *p, *fname;
-   char        save[FILENAME_MAX];
-   char        path[FILENAME_MAX];
-   struct UserTable *userp;
+	char			*p, *fname;
+	char			save[FILENAME_MAX];
+	char			path[FILENAME_MAX];
+	struct UserTable *userp;
+	int fullP;
 
 /*--------------------------------------------------------------------*/
-/*                   Convert backslashes to slashes                   */
+/*                   Convert backslashes to slashes						 */
 /*--------------------------------------------------------------------*/
 
-   strcpy(path, input);
-   renormalize( path );
+	strcpy(path, input);
+	renormalize( path );
 
 /*--------------------------------------------------------------------*/
-/*                 Add optional extension, if needed                  */
+/*                 Add optional extension, if needed						 */
 /*--------------------------------------------------------------------*/
 
-   if ( ftype != NULL )
-   {
-      p = strrchr(path,'/');  /* Get the last slash in name           */
+	if ( ftype != NULL )
+	{
+		p = strrchr(path,'/');	/* Get the last slash in name           */
 
-      if ( p == NULL )        /* No slash?                            */
-         p = path;            /* Okay, look at entire name            */
+		if ( p == NULL )			/* No slash?									 */
+			p = path;				/* Okay, look at entire name				 */
 
-      if (( strchr( p , '.') == NULL ) && (*p != '~'))
-                              /* Does name have a period?             */
-         strcat( strcat(p, ".") ,ftype );
-                              /* No --> Add extension                 */
-   } /* if ( ftype != NULL ) */
+		if (( strchr( p , '.') == NULL ) && (*p != '~'))
+										/* Does name have a period?				 */
+			strcat( strcat(p, ".") ,ftype );
+										/* No --> Add extension                 */
+	} /* if ( ftype != NULL ) */
 
 /*--------------------------------------------------------------------*/
-/*               If a fully qualified path name, return               */
+/*               If a fully qualified path name, return					 */
 /*--------------------------------------------------------------------*/
 
-   if (isAbsolutePath( path ))
-   {
-
-      if ( strstr( path, "..") == NULL )
-      {
-         if (( path[0] == '/' ) && ( path[1] != '/' ))
-         {
-            memmove( path + 2, path, strlen( path ) + 1);
+	if (isAbsolutePath( path ))
+	{
 
-            path[0] = getDrive( cur_dir );
-            path[1] = ':';
-         }
-      }
-      else {
-         KWBoolean push;
+		if ( strstr( path, "..") == NULL )
+		{
+			if (( path[0] == '/' ) && ( path[1] != '/' ))
+			{
+				memmove( path + 2, path, strlen( path ) + 1);
 
-         strcpy( save, path );
+				path[0] = getDrive( cur_dir );
+				path[1] = ':';
+			}
+		}
+		else {
+			KWBoolean push;
 
-         if (cur_dir == NULL )
-            push = KWFalse;
-         else {
+			strcpy( save, path );
 
-            PushDir( cur_dir );
-            push = KWTrue;
+			if (cur_dir == NULL )
+				push = KWFalse;
+			else {
 
-         }
+				PushDir( cur_dir );
+				push = KWTrue;
 
-         p = _fullpath( path, save, sizeof save );
+			}
 
-         if ( p == NULL )
-         {
-            printerr( path );
-            return NULL;
-         }
+#ifdef __GCC__
+			fullP = _fullpath(path, save, sizeof save);
+			if (fullP < 0)
+#else
+			p = _fullpath( path, save, sizeof save );
+			if ( p == NULL )
+#endif
 
-         if (push)
-            PopDir();
-      }
+			{
+				printerr( path );
+				return NULL;
+			}
+
+			if (push)
+				PopDir();
+		}
 
-      renormalize( path );
+		renormalize( path );
 
 #ifdef UDEBUG
-      printmsg(5,"expand_path: cwd = %s, input = %s, output = %s",
-                  cur_dir ? cur_dir : E_cwd,
-                  input,
-                  path );
+		printmsg(5,"expand_path: cwd = %s, input = %s, output = %s",
+						cur_dir ? cur_dir : E_cwd,
+						input,
+						path );
 #endif
 
-      return strcpy( input, path );
+		return strcpy( input, path );
 
-   } /* if */
+	} /* if */
 
 /*--------------------------------------------------------------------*/
-/*            Try to translate the file as a home directory path      */
+/*            Try to translate the file as a home directory path		 */
 /*--------------------------------------------------------------------*/
 
-   p = path;                  /* Copy entire path                     */
-   strcpy(save, p);
-
-   if (save[0] == '~')
-   {
-      if (save[1] == '/')
-      {
-         strcpy(path, home);  /* Use home dir for this user           */
-         fname = save + 2;    /* Step past directory for simple name  */
-      }
-      else if ( save[1] == '\0')
-      {
-         strcpy(path, home);  /* Use home dir for this user           */
-         fname = save + 1;    /* Step past directory for simple name  */
-      }
-      else {
-
-         if ((fname = strchr(save + 1, '/')) == NULL)
-            fname = save + strlen(save);  /* That's all, folks!       */
-         else
-            *fname++ = '\0';           /* End string, step past it */
+	p = path;						/* Copy entire path							 */
+	strcpy(save, p);
+
+	if (save[0] == '~')
+	{
+		if (save[1] == '/')
+		{
+			strcpy(path, home);	/* Use home dir for this user           */
+			fname = save + 2;    /* Step past directory for simple name  */
+		}
+		else if ( save[1] == '\0')
+		{
+			strcpy(path, home);	/* Use home dir for this user           */
+			fname = save + 1;    /* Step past directory for simple name  */
+		}
+		else {
+
+			if ((fname = strchr(save + 1, '/')) == NULL)
+				fname = save + strlen(save);	/* That's all, folks!		 */
+			else
+				*fname++ = '\0';				/* End string, step past it */
 
 /*--------------------------------------------------------------------*/
 /*                Look in /etc/passwd for the user id                 */
 /*--------------------------------------------------------------------*/
 
-         userp = checkuser(save + 1);  /* Locate user id in table  */
+			userp = checkuser(save + 1);	/* Locate user id in table  */
 
-         if ( userp == BADUSER )    /* Invalid user id?         */
-         {                          /* Yes --> Dump in trash    */
-            printmsg(0,"expand_path: User \"%s\" is invalid", save + 1);
-            return NULL;
-         } /* if */
+			if ( userp == BADUSER )    /* Invalid user id?			 */
+			{									/* Yes --> Dump in trash	 */
+				printmsg(0,"expand_path: User \"%s\" is invalid", save + 1);
+				return NULL;
+			} /* if */
 
-         strcpy(path, userp->homedir);
+			strcpy(path, userp->homedir);
 
-      } /* else */
+		} /* else */
 
-   } /* if (save[0] == '~') */
+	} /* if (save[0] == '~') */
 
 /*--------------------------------------------------------------------*/
-/*    No user id appears in the path; just append the input data      */
+/*    No user id appears in the path; just append the input data		 */
 /*    to the current directory to convert the relative path to an     */
-/*    absolute path                                                   */
+/*    absolute path																	 */
 /*--------------------------------------------------------------------*/
 
-   else {
-         fname = save;              /* Save entire file name          */
+	else {
+			fname = save;					/* Save entire file name			 */
 
-         if ( cur_dir != NULL )
-            strcpy( path, cur_dir );
-         else if ( E_cwd != NULL )
-            strcpy( path, E_cwd );
-         else
-            getcwd( path, FILENAME_MAX);
+			if ( cur_dir != NULL )
+				strcpy( path, cur_dir );
+			else if ( E_cwd != NULL )
+				strcpy( path, E_cwd );
+			else
+				getcwd( path, FILENAME_MAX);
 
-   } /* else */
+	} /* else */
 
 /*--------------------------------------------------------------------*/
 /*             Normalize the path, and then add the name              */
 /*--------------------------------------------------------------------*/
 
-   renormalize( p );
+	renormalize( p );
 
-   strlwr( path );            /* Can lower case path, but not the
-                                 name because name may be UNIX!       */
+	strlwr( path );				/* Can lower case path, but not the
+											name because name may be UNIX!		 */
 
-   p = path + strlen(path);
-   if (*path == '\0' || p[-1] != '/')
-      *p++ = '/';
+	p = path + strlen(path);
+	if (*path == '\0' || p[-1] != '/')
+		*p++ = '/';
 
-   strcpy( p, fname );
+	strcpy( p, fname );
 
 /*--------------------------------------------------------------------*/
-/*                       Return data to caller                        */
+/*                       Return data to caller								 */
 /*--------------------------------------------------------------------*/
 
 #ifdef UDEBUG
-   printmsg(5,"expand_path: cwd = %s, input = %s, output = %s",
-               cur_dir ? cur_dir : E_cwd,
-               input,
-               path );
+	printmsg(5,"expand_path: cwd = %s, input = %s, output = %s",
+					cur_dir ? cur_dir : E_cwd,
+					input,
+					path );
 #endif
 
-   return strcpy( input, path );
+	return strcpy( input, path );
 
 } /* expand_path */
--- e:\uupc1.12s\source\lib\EXPORT.C	Sun Mar 30 22:58:54 1997
+++ EXPORT.C	Sat Jul 26 22:59:48 1997
@@ -1,19 +1,19 @@
 /*--------------------------------------------------------------------*/
-/*    e x p o r t . c                                                 */
+/*    e x p o r t . c																 */
 /*                                                                    */
 /*    File name mapping routines for UUPC/extended                    */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*       Changes Copyright (c) 1989-1997 by Kendra Electronic         */
-/*       Wonderworks.                                                 */
+/*       Changes Copyright (c) 1989-1997 by Kendra Electronic			 */
+/*       Wonderworks.																 */
 /*                                                                    */
-/*       All rights reserved except those explicitly granted by       */
-/*       the UUPC/extended license agreement.                         */
+/*       All rights reserved except those explicitly granted by		 */
+/*       the UUPC/extended license agreement.								 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                          RCS Information                           */
+/*                          RCS Information									 */
 /*--------------------------------------------------------------------*/
 
 /*
@@ -21,46 +21,46 @@
  *
  *    Revision history:
  *    $Log: export.c $
- *    Revision 1.13  1997/03/31 06:59:00  ahd
+ *    Revision 1.13	1997/03/31 06:59:00	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.12  1996/01/01 20:51:21  ahd
+ *    Revision 1.12	1996/01/01 20:51:21	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.11  1995/01/29 16:43:03  ahd
+ *    Revision 1.11	1995/01/29 16:43:03	ahd
  *    IBM C/Set compiler warnings
  *
- *    Revision 1.10  1994/12/22 00:08:21  ahd
+ *    Revision 1.10	1994/12/22 00:08:21	ahd
  *    Annual Copyright Update
  *
  *    Revision 1.9  1994/03/13 17:22:20  ahd
  *    Add debugging statement
  *
- *     Revision 1.8  1994/02/19  04:41:08  ahd
+ *     Revision 1.8	1994/02/19	04:41:08  ahd
  *     Use standard first header
  *
- *     Revision 1.7  1994/02/19  04:05:37  ahd
+ *     Revision 1.7	1994/02/19	04:05:37  ahd
  *     Use standard first header
  *
- *     Revision 1.6  1994/02/19  03:49:46  ahd
+ *     Revision 1.6	1994/02/19	03:49:46  ahd
  *     Use standard first header
  *
- *     Revision 1.5  1994/02/18  23:08:59  ahd
+ *     Revision 1.5	1994/02/18	23:08:59  ahd
  *     Use standard first header
  *
- *     Revision 1.4  1994/01/01  19:01:46  ahd
+ *     Revision 1.4	1994/01/01	19:01:46  ahd
  *     Annual Copyright Update
  *
- *     Revision 1.3  1993/10/12  00:41:51  ahd
+ *     Revision 1.3	1993/10/12	00:41:51  ahd
  *     Normalize comments
  *
- *     Revision 1.2  1993/10/09  15:46:15  rhg
+ *     Revision 1.2	1993/10/09	15:46:15  rhg
  *     ANSIify the source
  *
  */
 
 /*--------------------------------------------------------------------*/
-/*                        System include files                        */
+/*                        System include files								 */
 /*--------------------------------------------------------------------*/
 
 #include "uupcmoah.h"
@@ -68,7 +68,7 @@
 #include <ctype.h>
 
 /*--------------------------------------------------------------------*/
-/*                    UUPC/extended include files                     */
+/*                    UUPC/extended include files							 */
 /*--------------------------------------------------------------------*/
 
 #include "arbmath.h"
@@ -81,144 +81,144 @@
 currentfile();
 
 /*--------------------------------------------------------------------*/
-/*       e x p o r t p a t h                                          */
+/*       e x p o r t p a t h														 */
 /*                                                                    */
-/*       Convert a local environment name to UNIX format name         */
+/*       Convert a local environment name to UNIX format name			 */
 /*--------------------------------------------------------------------*/
 
 void exportpath(char *canon, const char *host, const char *remote)
 {
-   const char *xhost;
-   char *copy;
-   char tempname[FILENAME_MAX];
-   unsigned subscript;
-   unsigned char number[MAX_DIGITS];
-   char *token, *out;
-
-   static size_t range =  UNIX_END_C - UNIX_START_C + 1;
-                              /* Determine unique number characters in
-                                 the UNIX file names we are mapping   */
-   size_t charsetsize;
-            /* Number of allowed characters in
-                              MS-DOS file names                   */
+	const char *xhost;
+	char *copy;
+	char tempname[FILENAME_MAX];
+	size_t subscript;
+	unsigned char number[MAX_DIGITS];
+	char *token, *out;
+
+	static size_t range =  UNIX_END_C - UNIX_START_C + 1;
+										/* Determine unique number characters in
+											the UNIX file names we are mapping	 */
+	size_t charsetsize;
+				/* Number of allowed characters in
+										MS-DOS file names                   */
 
 #ifdef UDEBUG
-   printmsg(5,"Exporting %s for %s", host, remote );
+	printmsg(5,"Exporting %s for %s", host, remote );
 #endif
 
 /*--------------------------------------------------------------------*/
-/*                      Define our character set                      */
+/*                      Define our character set							 */
 /*--------------------------------------------------------------------*/
 
-   if ( E_charset == NULL )
-      E_charset = DOSCHARS;
+	if ( E_charset == NULL )
+		E_charset = DOSCHARS;
 
-   charsetsize = strlen( E_charset );
+	charsetsize = strlen( E_charset );
 
 /*--------------------------------------------------------------------*/
-/*                Drop leading spool directory, if any                */
+/*                Drop leading spool directory, if any					 */
 /*--------------------------------------------------------------------*/
 
-   if (equalni(host, E_spooldir, strlen( E_spooldir )))
-      xhost = host + strlen( E_spooldir ) + 1;
-   else
-      xhost = host;
+	if (equalni(host, E_spooldir, strlen( E_spooldir )))
+		xhost = host + strlen( E_spooldir ) + 1;
+	else
+		xhost = host;
 
-   copy = strdup( xhost );
-   checkref( copy );
+	copy = strdup( xhost );
+	checkref( copy );
 
 /*--------------------------------------------------------------------*/
-/*                        Drop the remote name                        */
+/*                        Drop the remote name								 */
 /*--------------------------------------------------------------------*/
 
-   token = strtok( copy, "/");
+	token = strtok( copy, "/");
 
-   if ((token == NULL) || !equaln( token, remote, strlen( token )))
-   {
-      printmsg(0,"exportpath: Badly formed host name \"%s\"",xhost);
-      panic();
-   }
+	if ((token == NULL) || !equaln( token, remote, strlen( token )))
+	{
+		printmsg(0,"exportpath: Badly formed host name \"%s\"",xhost);
+		panic();
+	}
 
 /*--------------------------------------------------------------------*/
 /*                 Get the character leading the name                 */
 /*--------------------------------------------------------------------*/
 
-   token = strtok( NULL, "/");
-   if ( (token == NULL) || (strlen(token) != 1))
-   {
-      printmsg(0,"exportpath: Badly formed host name \"%s\"",xhost);
-      panic();
-   }
+	token = strtok( NULL, "/");
+	if ( (token == NULL) || (strlen(token) != 1))
+	{
+		printmsg(0,"exportpath: Badly formed host name \"%s\"",xhost);
+		panic();
+	}
 
-   strcpy(canon, token);
-   strcat(canon, ".");
+	strcpy(canon, token);
+	strcat(canon, ".");
 
 /*--------------------------------------------------------------------*/
 /*       Create a binary number which represents our file name        */
 /*--------------------------------------------------------------------*/
 
-   for (subscript = 0; subscript < MAX_DIGITS; subscript++ )
-      number[subscript] = 0;  /* Initialize number to zero        */
+	for (subscript = 0; subscript < MAX_DIGITS; subscript++ )
+		number[subscript] = 0;	/* Initialize number to zero			*/
 
-   token = strtok( NULL, "/");   /* Get variable part of name         */
-   while( (*token != '\0') && (*number == '\0'))
-   {
-      unsigned char digit;
-      mult(number, charsetsize, MAX_DIGITS); /* Shift the number over */
-      digit = (unsigned char) (strchr( E_charset , *token++) - E_charset);
-      add(number, digit , MAX_DIGITS); /* Add in new low order        */
-      if (*token == '.')               /* Next character a period?    */
-         token ++;                     /* Yes --> Ignore it           */
-   } /* while */
+	token = strtok( NULL, "/");	/* Get variable part of name			 */
+	while( (*token != '\0') && (*number == '\0'))
+	{
+		unsigned char digit;
+		mult(number, charsetsize, MAX_DIGITS); /* Shift the number over */
+		digit = (unsigned char) (strchr( E_charset , *token++) - E_charset);
+		add(number, digit , MAX_DIGITS); /* Add in new low order        */
+		if (*token == '.')					/* Next character a period?	 */
+			token ++;							/* Yes --> Ignore it           */
+	} /* while */
 
-   out = &tempname[FILENAME_MAX];
-   *--out = '\0';          /* Terminate the string we will build  */
+	out = &tempname[FILENAME_MAX];
+	*--out = '\0';          /* Terminate the string we will build	*/
 
 /*--------------------------------------------------------------------*/
-/*         Here's the loop to actually do the base conversion         */
+/*         Here's the loop to actually do the base conversion			 */
 /*--------------------------------------------------------------------*/
 
-      while(adiv( number, range, &subscript, MAX_DIGITS))
-       *--out = (char) (subscript + UNIX_START_C);
+		while(adiv( number, range, &subscript, MAX_DIGITS))
+		 *--out = (char) (subscript + UNIX_START_C);
 
 /*--------------------------------------------------------------------*/
 /*    We sort of lied above; the first character out of the           */
-/*    conversion is not a character at all, but bits which say how    */
-/*    many characters the remote and local file names get prefixed    */
-/*    to the converted name.  Retrieve that information now           */
-/*--------------------------------------------------------------------*/
-
-      subscript = (unsigned) (*out - UNIX_START_C);
-                              /* Convert back to pure number          */
-      token = canon + strlen( canon ); /* Remember end of string      */
-      if (subscript > HOSTLEN)
-      {
-         subscript /= HOSTLEN;
-         strcat( canon, remote );
-      }
-      else
-         strcat( canon, E_nodename );
-      token[ subscript ] = '\0';    /* Only use the length we were told */
+/*    conversion is not a character at all, but bits which say how	 */
+/*    many characters the remote and local file names get prefixed	 */
+/*    to the converted name.	Retrieve that information now           */
+/*--------------------------------------------------------------------*/
+
+		subscript = (unsigned) (*out - UNIX_START_C);
+										/* Convert back to pure number			 */
+		token = canon + strlen( canon ); /* Remember end of string		 */
+		if (subscript > HOSTLEN)
+		{
+			subscript /= HOSTLEN;
+			strcat( canon, remote );
+		}
+		else
+			strcat( canon, E_nodename );
+		token[ subscript ] = '\0';    /* Only use the length we were told */
 
 /*--------------------------------------------------------------------*/
 /*               Add in the variable name and we're done              */
 /*--------------------------------------------------------------------*/
 
-      strcat( canon, ++out );
-      free( copy );
+		strcat( canon, ++out );
+		free( copy );
 
 /*--------------------------------------------------------------------*/
 /*                          Check the result                          */
 /*--------------------------------------------------------------------*/
 
-      importpath( tempname, canon, remote );
-      if ( !equal( tempname, xhost ))
-      {
-         printmsg(0,
-            "exportpath: **mapping error** input \"%s\","
-            " result \"%s\", import \"%s\"",
-            xhost, canon, tempname );
-         panic();
-      } /* if */
+		importpath( tempname, canon, remote );
+		if ( !equal( tempname, xhost ))
+		{
+			printmsg(0,
+				"exportpath: **mapping error** input \"%s\","
+				" result \"%s\", import \"%s\"",
+				xhost, canon, tempname );
+			panic();
+		} /* if */
 
 } /* exportpath */
--- e:\uupc1.12s\source\lib\FILEBKUP.C	Sun Mar 30 22:59:00 1997
+++ FILEBKUP.C	Fri Jul 25 22:45:14 1997
@@ -1,19 +1,19 @@
 /*--------------------------------------------------------------------*/
-/*       f i l e b k u p                                              */
+/*       f i l e b k u p															 */
 /*                                                                    */
-/*       UUPC/extended file backup routines                           */
+/*       UUPC/extended file backup routines									 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*       Changes Copyright (c) 1989-1997 by Kendra Electronic         */
-/*       Wonderworks.                                                 */
+/*       Changes Copyright (c) 1989-1997 by Kendra Electronic			 */
+/*       Wonderworks.																 */
 /*                                                                    */
-/*       All rights reserved except those explicitly granted by       */
-/*       the UUPC/extended license agreement.                         */
+/*       All rights reserved except those explicitly granted by		 */
+/*       the UUPC/extended license agreement.								 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                          RCS Information                           */
+/*                          RCS Information									 */
 /*--------------------------------------------------------------------*/
 
 /*
@@ -21,10 +21,10 @@
  *
  *    Revision history:
  *    $Log: filebkup.c $
- *    Revision 1.11  1997/03/31 06:59:07  ahd
+ *    Revision 1.11	1997/03/31 06:59:07	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.10  1996/01/01 20:51:32  ahd
+ *    Revision 1.10	1996/01/01 20:51:32	ahd
  *    Annual Copyright Update
  *
  *    Revision 1.9  1995/03/11 22:33:46  ahd
@@ -36,93 +36,95 @@
  *    Revision 1.7  1994/02/20 19:05:02  ahd
  *    IBM C/Set 2 Conversion, memory leak cleanup
  *
- *     Revision 1.6  1994/01/01  19:01:54  ahd
+ *     Revision 1.6	1994/01/01	19:01:54  ahd
  *     Annual Copyright Update
  *
- *     Revision 1.5  1993/12/23  03:11:17  rommel
+ *     Revision 1.5	1993/12/23	03:11:17  rommel
  *     OS/2 32 bit support for additional compilers
  *
- *     Revision 1.4  1993/10/12  00:43:34  ahd
+ *     Revision 1.4	1993/10/12	00:43:34  ahd
  *     Normalize comments
  *
- *     Revision 1.3  1993/04/11  00:33:38  dmwatt
+ *     Revision 1.3	1993/04/11	00:33:38  dmwatt
  *     Global edits for year, TEXT, etc.
  *
- * Revision 1.2  1992/11/19  02:57:51  ahd
+ * Revision 1.2  1992/11/19  02:57:51	ahd
  * drop rcsid
  *
- * Revision 1.1  1992/11/16  05:00:26  ahd
+ * Revision 1.1  1992/11/16  05:00:26	ahd
  * Initial revision
  *
  */
 
 /*--------------------------------------------------------------------*/
-/*                        System include files                        */
+/*                        System include files								 */
 /*--------------------------------------------------------------------*/
 
-#ifndef __GNUC__
-
 #include "uupcmoah.h"
 
+#ifndef __GCC__
 #include <direct.h>
+#else
+#include <stdio.h>
+#include <stdlib.h>
 #endif
 
 /*--------------------------------------------------------------------*/
-/*                    UUPC/extended include files                     */
+/*                    UUPC/extended include files							 */
 /*--------------------------------------------------------------------*/
 
 currentfile();
 
 /*--------------------------------------------------------------------*/
-/*    f i l e b k u p                                                 */
+/*    f i l e b k u p																 */
 /*                                                                    */
-/*    Backup a file to the standard UUPC/extended defined             */
-/*    extension.                                                      */
+/*    Backup a file to the standard UUPC/extended defined				 */
+/*    extension.																		 */
 /*--------------------------------------------------------------------*/
 
 int filebkup( const char *input )
 {
-   char fdrive[FILENAME_MAX];
-   char fpath[FILENAME_MAX];
-   char fname[FILENAME_MAX];
-   char ftype[FILENAME_MAX];
-   char backup[FILENAME_MAX];
+	char fdrive[FILENAME_MAX];
+	char fpath[FILENAME_MAX];
+	char fname[FILENAME_MAX];
+	char ftype[FILENAME_MAX];
+	char backup[FILENAME_MAX];
 
-   if ( !bflag[F_BACKUP] )    /* Are we to not back it up?            */
-      return 1;               /* Yes --> Report we did not            */
+	if ( !bflag[F_BACKUP] )    /* Are we to not back it up?				 */
+		return 1;					/* Yes --> Report we did not				 */
 
 #ifdef __TURBOC__
-   fnsplit( input, fdrive, fpath, fname, ftype );
+	fnsplit( input, fdrive, fpath, fname, ftype );
 
-   if ( E_backup == NULL )
-      strcpy(ftype, ".bak" );
-   else if ( *E_backup == '.' )
-      strcpy( ftype, E_backup );
-   else {
-      *ftype = '.';
-      strcpy(  ftype + 1 , E_backup );
-   } /* else */
+	if ( E_backup == NULL )
+		strcpy(ftype, ".bak" );
+	else if ( *E_backup == '.' )
+		strcpy( ftype, E_backup );
+	else {
+		*ftype = '.';
+		strcpy(	ftype + 1 , E_backup );
+	} /* else */
 
-   fnmerge( backup, fdrive, fpath, fname, ftype );
+	fnmerge( backup, fdrive, fpath, fname, ftype );
 #else
 
-   if ( E_backup == NULL )
-      E_backup = ".bak";
+	if ( E_backup == NULL )
+		E_backup = ".bak";
 
-   _splitpath( (char *) input , fdrive, fpath, fname, ftype );
-   _makepath( backup , fdrive, fpath, fname, E_backup );
+	_splitpath( (char *) input , fdrive, fpath, fname, ftype );
+	_makepath( backup , fdrive, fpath, fname, E_backup );
 #endif /* __TURBOC__ */
 
-   REMOVE( backup );
+	REMOVE( backup );
 
-   if (rename( input, backup ))
-   {
-      printerr( backup );
-      printmsg(1,"Unable to rename %s to %s", input, backup );
-      return 1;
-
-   } /* if (rename( input, backup )) */
-   else
-      return 0;
+	if (rename( input, backup ))
+	{
+		printerr( backup );
+		printmsg(1,"Unable to rename %s to %s", input, backup );
+		return 1;
+
+	} /* if (rename( input, backup )) */
+	else
+		return 0;
 
 } /* filebkup */
--- e:\uupc1.12s\source\lib\GETDRIVE.C	Sun Mar 30 22:59:08 1997
+++ GETDRIVE.C	Sat Jul 26 13:25:34 1997
@@ -1,19 +1,19 @@
 /*--------------------------------------------------------------------*/
-/*       g e t d r i v e . c                                          */
+/*       g e t d r i v e . c														 */
 /*                                                                    */
-/*       Determine current drive letter efficiently                   */
+/*       Determine current drive letter efficiently						 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*       Changes Copyright (c) 1989-1997 by Kendra Electronic         */
-/*       Wonderworks.                                                 */
+/*       Changes Copyright (c) 1989-1997 by Kendra Electronic			 */
+/*       Wonderworks.																 */
 /*                                                                    */
-/*       All rights reserved except those explicitly granted by       */
-/*       the UUPC/extended license agreement.                         */
+/*       All rights reserved except those explicitly granted by		 */
+/*       the UUPC/extended license agreement.								 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                          RCS Information                           */
+/*                          RCS Information									 */
 /*--------------------------------------------------------------------*/
 
 /*
@@ -32,35 +32,39 @@
  *
  */
 
-#include <uupcmoah.h>
+#include "uupcmoah.h"
 
+#ifdef __GCC__
+#include <stdlib.h>
+#else
 #include <direct.h>
+#endif
 #include <ctype.h>
 
 /*--------------------------------------------------------------------*/
-/*       g e t D r i v e                                              */
+/*       g e t D r i v e															 */
 /*                                                                    */
-/*       Get the current drive letter                                 */
+/*       Get the current drive letter											 */
 /*--------------------------------------------------------------------*/
 
 char getDrive( const char *currentDirectory )
 {
 
-   if (( currentDirectory != NULL ) &&
-       isalpha( currentDirectory[0] ) &&
-       (currentDirectory[1] == ':' ))  /* Current dir has drive?     */
-      return (char) toupper(*currentDirectory);
-                                    /* Yes --> Use it                */
+	if (( currentDirectory != NULL ) &&
+		 isalpha( currentDirectory[0] ) &&
+		 (currentDirectory[1] == ':' ))	/* Current dir has drive?		*/
+		return (char) toupper(*currentDirectory);
+												/* Yes --> Use it                */
 
-   if (( E_cwd != NULL ) &&
-       isalpha( E_cwd[0] ) &&
-       (E_cwd[1] == ':' ))          /* Current dir has drive?        */
-      return (char) toupper(*E_cwd);/* Yes --> Use it, of course     */
+	if (( E_cwd != NULL ) &&
+		 isalpha( E_cwd[0] ) &&
+		 (E_cwd[1] == ':' ))          /* Current dir has drive?			*/
+		return (char) toupper(*E_cwd);/* Yes --> Use it, of course		*/
 
 /*--------------------------------------------------------------------*/
-/*         Determine the current drive letter from the system         */
+/*         Determine the current drive letter from the system			 */
 /*--------------------------------------------------------------------*/
 
-    return (char) toupper(_getdrive() + 'A' - 1);
+	 return (char) toupper(_getdrive() + 'A' - 1);
 
 } /* getDrive */
--- e:\uupc1.12s\source\lib\HOSTABLE.C	Sat May 10 23:27:40 1997
+++ HOSTABLE.C	Sun Jul 27 17:34:38 1997
@@ -1,69 +1,69 @@
 /*--------------------------------------------------------------------*/
-/*       h o s t a b l e . c                                          */
+/*       h o s t a b l e . c														 */
 /*                                                                    */
 /*       Remote host table routines for UUPC/extended                 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*    Changes Copyright (c) 1989-1997 by Kendra Electronic            */
-/*    Wonderworks.                                                    */
+/*    Changes Copyright (c) 1989-1997 by Kendra Electronic				 */
+/*    Wonderworks.																	 */
 /*                                                                    */
-/*    All rights reserved except those explicitly granted by the      */
+/*    All rights reserved except those explicitly granted by the		 */
 /*    UUPC/extended license agreement.                                */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                          RCS Information                           */
+/*                          RCS Information									 */
 /*--------------------------------------------------------------------*/
 
  /*
-  *      $Id: hostable.c 1.29 1997/05/11 04:27:40 ahd Exp $
+  *		$Id: hostable.c 1.29 1997/05/11 04:27:40 ahd Exp $
   *
-  *      $Log: hostable.c $
-  *      Revision 1.29  1997/05/11 04:27:40  ahd
-  *      SMTP client support for RMAIL/UUXQT
+  *		$Log: hostable.c $
+  *		Revision 1.29	1997/05/11 04:27:40	ahd
+  *		SMTP client support for RMAIL/UUXQT
   *
-  *      Revision 1.28  1997/03/31 06:59:39  ahd
-  *      Annual Copyright Update
+  *		Revision 1.28	1997/03/31 06:59:39	ahd
+  *		Annual Copyright Update
   *
-  *      Revision 1.27  1996/11/18 04:46:49  ahd
-  *      Normalize arguments to bugout
-  *      Reset title after exec of sub-modules
-  *      Normalize host status names to use HS_ prefix
+  *		Revision 1.27	1996/11/18 04:46:49	ahd
+  *		Normalize arguments to bugout
+  *		Reset title after exec of sub-modules
+  *		Normalize host status names to use HS_ prefix
   *
-  *      Revision 1.26  1996/01/01 20:52:21  ahd
-  *      Annual Copyright Update
+  *		Revision 1.26	1996/01/01 20:52:21	ahd
+  *		Annual Copyright Update
   *
-  *      Revision 1.25  1995/07/21 13:23:19  ahd
-  *      Clean up OS/2 compiler warnings
+  *		Revision 1.25	1995/07/21 13:23:19	ahd
+  *		Clean up OS/2 compiler warnings
   *
-  *      Revision 1.24  1995/03/24 04:17:22  ahd
-  *      Compiler warning message cleanup, optimize for low memory processing
+  *		Revision 1.24	1995/03/24 04:17:22	ahd
+  *		Compiler warning message cleanup, optimize for low memory processing
   *
-  *      Revision 1.23  1995/02/25 18:21:44  ahd
-  *      Correct selected flags for config variables
+  *		Revision 1.23	1995/02/25 18:21:44	ahd
+  *		Correct selected flags for config variables
   *
-  *      Revision 1.22  1995/02/21 13:02:33  ahd
-  *      Supress compiler warning
+  *		Revision 1.22	1995/02/21 13:02:33	ahd
+  *		Supress compiler warning
   *
-  *      Revision 1.21  1995/02/21 03:30:52  ahd
-  *      More compiler warning cleanup, drop selected messages at compile
-  *      time if not debugging.
+  *		Revision 1.21	1995/02/21 03:30:52	ahd
+  *		More compiler warning cleanup, drop selected messages at compile
+  *		time if not debugging.
   *
-  *      Revision 1.20  1995/01/29 16:43:03  ahd
-  *      IBM C/Set compiler warnings
+  *		Revision 1.20	1995/01/29 16:43:03	ahd
+  *		IBM C/Set compiler warnings
   *
-  *      Revision 1.19  1995/01/07 16:12:32  ahd
-  *      Change KWBoolean to KWBoolean to avoid VC++ 2.0 conflict
+  *		Revision 1.19	1995/01/07 16:12:32	ahd
+  *		Change KWBoolean to KWBoolean to avoid VC++ 2.0 conflict
   *
-  *      Revision 1.18  1994/12/27 20:49:47  ahd
-  *      Revise confusing local domain message
+  *		Revision 1.18	1994/12/27 20:49:47	ahd
+  *		Revise confusing local domain message
   *
-  *      Revision 1.17  1994/12/22 00:08:50  ahd
-  *      Annual Copyright Update
+  *		Revision 1.17	1994/12/22 00:08:50	ahd
+  *		Annual Copyright Update
   *
-  *      Revision 1.16  1994/05/08 21:43:33  ahd
-  *      Report caller of checkname(), checkreal() on panics
+  *		Revision 1.16	1994/05/08 21:43:33	ahd
+  *		Report caller of checkname(), checkreal() on panics
   *
  *     Revision 1.15  1994/02/20  19:07:38  ahd
  *     IBM C/Set 2 Conversion, memory leak cleanup
@@ -71,39 +71,39 @@
  *     Revision 1.11  1994/02/18  23:09:55  ahd
  *     Use standard first header
  *
- *     Revision 1.9  1994/01/01  19:02:25  ahd
+ *     Revision 1.9	1994/01/01	19:02:25  ahd
  *     Annual Copyright Update
  *
- *     Revision 1.8  1993/10/12  00:45:27  ahd
+ *     Revision 1.8	1993/10/12	00:45:27  ahd
  *     Normalize comments
  *
- *     Revision 1.7  1993/06/21  02:17:31  ahd
+ *     Revision 1.7	1993/06/21	02:17:31  ahd
  *     Correct errors in mail routing via HOSTPATH
  *
- *     Revision 1.6  1993/05/29  15:19:59  ahd
+ *     Revision 1.6	1993/05/29	15:19:59  ahd
  *     Allow configured systems, passwd files
  *
- *     Revision 1.5  1993/04/11  00:32:29  ahd
+ *     Revision 1.5	1993/04/11	00:32:29  ahd
  *     Global edits for year, TEXT, etc.
  *
- *     Revision 1.4  1993/04/04  04:57:01  ahd
+ *     Revision 1.4	1993/04/04	04:57:01  ahd
  *     Trap existence of local host name in SYSTEMS file
  *
- *     Revision 1.3  1992/12/18  12:05:57  ahd
+ *     Revision 1.3	1992/12/18	12:05:57  ahd
  *     Suppress duplicate machine state messages to improving OS/2 scrolling
  *
- *     Revision 1.3  1992/12/18  12:05:57  ahd
+ *     Revision 1.3	1992/12/18	12:05:57  ahd
  *     Suppress duplicate machine state messages to improving OS/2 scrolling
  *
- *    Revision 1.2  1992/11/22  20:58:55  ahd
+ *    Revision 1.2  1992/11/22  20:58:55	ahd
  *    Use strpool to allocate const strings
  *
- *    18 Mar 1990 Create hostable.c from router.c                    ahd
+ *    18 Mar 1990 Create hostable.c from router.c							ahd
  *                Move code to generate localdomain to here          ahd
- *    22 Apr 90   Perform check for full host name before examining
+ *    22 Apr 90	Perform check for full host name before examining
  *                name without domain.                               ahd
- *    29 Jul 90   Only load host table based on first six characters
- *                of host name.                                      ahd
+ *    29 Jul 90	Only load host table based on first six characters
+ *                of host name.													ahd
  *
   */
 
@@ -120,149 +120,153 @@
 
 static struct HostTable *hosts = NULL;
 
-static size_t  HostElements = 0;
+static size_t	HostElements = 0;
 
 static size_t loadhost( void );
 
 static int hostcmp( const void *a , const void *b );
 
-static size_t localdomainl;   /* Length of localdomain                */
+static size_t localdomainl;	/* Length of localdomain					 */
+
+#ifndef max
+#define max(x,y) (((x) > (y)) ? (x) : (y))
+#endif
 
 /*--------------------------------------------------------------------*/
 /*    c h e c k n a m e                                               */
 /*                                                                    */
-/*    Perform a search for a single host name                         */
+/*    Perform a search for a single host name								 */
 /*                                                                    */
-/*    Rewritten for release 1.10a.  The old release had               */
-/*    most of the same logic, but nested it inside the search         */
-/*    loop; adding new cases (specifically, the wildcard domain       */
-/*    search) was difficult.  This version is slower because it       */
-/*    makes multiple passes through the host table, but this          */
+/*    Rewritten for release 1.10a.	The old release had					 */
+/*    most of the same logic, but nested it inside the search			 */
+/*    loop; adding new cases (specifically, the wildcard domain		 */
+/*    search) was difficult.	This version is slower because it		 */
+/*    makes multiple passes through the host table, but this			 */
 /*    isn't really performance code for a small (under 100 hosts)     */
-/*    table.                                 ahd 26 April 1991        */
+/*    table.											ahd 26 April 1991        */
 /*                                                                    */
-/*    Note because we save the arguments and use a static variable    */
-/*    to save the result of searches, this function is not            */
-/*    recursive!                                                      */
+/*    Note because we save the arguments and use a static variable	 */
+/*    to save the result of searches, this function is not				 */
+/*    recursive!																		 */
 /*--------------------------------------------------------------------*/
 
 struct HostTable *checkName(const char *name,
-                            const size_t line,
-                            const char *function)
+									 const size_t line,
+									 const char *function)
 {
-   char  hostname[MAXADDR];   /* Local copy of name to process        */
-   char *period;              /* Pointer "." in hostname              */
-   size_t namel;              /* Length of the name input             */
-   size_t column;             /* Length of the name input             */
+	char	hostname[MAXADDR];	/* Local copy of name to process        */
+	char *period;					/* Pointer "." in hostname              */
+	size_t namel;					/* Length of the name input				 */
+	size_t column;             /* Length of the name input				 */
 
-   static char savename[MAXADDR] = "";
-                              /* Saved copy of name to make function
-                                 reducible                            */
-   static struct HostTable *hostz;
+	static char savename[MAXADDR] = "";
+										/* Saved copy of name to make function
+											reducible									 */
+	static struct HostTable *hostz;
 
 /*--------------------------------------------------------------------*/
-/*                       Validate the argument                        */
+/*                       Validate the argument								 */
 /*--------------------------------------------------------------------*/
 
-   if ((name == NULL) || (*name == '\0'))
-   {
-      printmsg(0,"checkName: Invalid (missing) hostname passed");
-      bugout(function, line);
-   }
+	if ((name == NULL) || (*name == '\0'))
+	{
+		printmsg(0,"checkName: Invalid (missing) hostname passed");
+		bugout(function, line);
+	}
 
-   namel = strlen(name);
+	namel = strlen(name);
 
 /*--------------------------------------------------------------------*/
-/*    If same argument as last time, return same result; otherwise    */
-/*    save input for next pass                                        */
+/*    If same argument as last time, return same result; otherwise	 */
+/*    save input for next pass													 */
 /*--------------------------------------------------------------------*/
 
-   if (equali(name, savename))
-      return hostz;
+	if (equali(name, savename))
+		return hostz;
 
-   strcpy( savename, name);   /* Save for next pass                   */
+	strcpy( savename, name);	/* Save for next pass						 */
 
 /*--------------------------------------------------------------------*/
-/*                      Search for the full name                      */
+/*                      Search for the full name							 */
 /*--------------------------------------------------------------------*/
 
-   if ((hostz = searchname(name, MAXADDR)) != BADHOST)
-      return hostz;
+	if ((hostz = searchname(name, MAXADDR)) != BADHOST)
+		return hostz;
 
 /*--------------------------------------------------------------------*/
-/*    If the name already has the local domain attached, search for   */
-/*    the host name without the domain.                               */
+/*    If the name already has the local domain attached, search for	 */
+/*    the host name without the domain.										 */
 /*--------------------------------------------------------------------*/
 
-   column = namel - localdomainl;
+	column = namel - localdomainl;
 
-   if ((namel > localdomainl) && equali(E_localdomain, &name[column]) &&
-       (name[ column - 1] == '.'))
-   {
-      if ((hostz = searchname(name,column-1 )) != BADHOST)
-         return hostz;
-   } /* if */
+	if ((namel > localdomainl) && equali(E_localdomain, &name[column]) &&
+		 (name[ column - 1] == '.'))
+	{
+		if ((hostz = searchname(name,column-1 )) != BADHOST)
+			return hostz;
+	} /* if */
 
 /*--------------------------------------------------------------------*/
-/*    If the name already has the UUCP  domain attached, search for   */
-/*    the host name without the domain.                               */
+/*    If the name already has the UUCP  domain attached, search for	 */
+/*    the host name without the domain.										 */
 /*--------------------------------------------------------------------*/
 
-   column = namel - 5;
+	column = namel - 5;
 
-   if ((column > 0) && equali(".UUCP", &name[column]))
-   {
-      if ((hostz = searchname(name, column )) != BADHOST)
-         return hostz;
-   } /* if */
+	if ((column > 0) && equali(".UUCP", &name[column]))
+	{
+		if ((hostz = searchname(name, column )) != BADHOST)
+			return hostz;
+	} /* if */
 
 /*--------------------------------------------------------------------*/
-/*              Search for the name in the local domain               */
+/*              Search for the name in the local domain					 */
 /*--------------------------------------------------------------------*/
 
-   if ((namel + localdomainl + 2) < MAXADDR)
-   {
-      strcpy( hostname, name );
-      strcat( hostname, "." );
-      strcat( hostname, E_localdomain );
+	if ((namel + localdomainl + 2) < MAXADDR)
+	{
+		strcpy( hostname, name );
+		strcat( hostname, "." );
+		strcat( hostname, E_localdomain );
 
-      if ((hostz = searchname(hostname, MAXADDR)) != BADHOST)
-         return hostz;
+		if ((hostz = searchname(hostname, MAXADDR)) != BADHOST)
+			return hostz;
 
-   } /* if */
+	} /* if */
 
 /*--------------------------------------------------------------------*/
 /*    If a simple name and not found, return search for truncated     */
-/*    UNIX name.                                                      */
+/*    UNIX name.																		 */
 /*--------------------------------------------------------------------*/
 
-   if ( strchr(name,'.') == NULL )
-      return checkreal( name );
+	if ( strchr(name,'.') == NULL )
+		return checkreal( name );
 
 /*--------------------------------------------------------------------*/
-/*               Perform a wildcard domain name search                */
+/*               Perform a wildcard domain name search					 */
 /*--------------------------------------------------------------------*/
 
-   period = (char *) name;          /* Begin at front of name        */
+	period = (char *) name;          /* Begin at front of name			*/
 
-   while( (period = strchr( ++period, '.' )) != NULL )
-   {
+	while( (period = strchr( ++period, '.' )) != NULL )
+	{
 
-      hostname[0] = '*';               /* Do wildcard search time    */
-      strcpy( hostname + 1, period );
+		hostname[0] = '*';					/* Do wildcard search time    */
+		strcpy( hostname + 1, period );
 
-      if ((hostz = searchname(hostname, MAXADDR)) != BADHOST)
-         return hostz;
+		if ((hostz = searchname(hostname, MAXADDR)) != BADHOST)
+			return hostz;
 
-   }
+	}
 
 /*--------------------------------------------------------------------*/
-/*         We didn't find the host.  Return failure to caller         */
+/*         We didn't find the host.  Return failure to caller			 */
 /*--------------------------------------------------------------------*/
 
-   return BADHOST;
+	return BADHOST;
 
-}  /* checkname */
+}	/* checkname */
 
 /*--------------------------------------------------------------------*/
 /*    c h e c k r e a l                                               */
@@ -271,577 +275,577 @@
 /*--------------------------------------------------------------------*/
 
 struct HostTable *checkReal(const char *name,
-                            const size_t line,
-                            const char *function)
+									 const size_t line,
+									 const char *function)
 {
-   size_t  namel;
-   struct HostTable *hostp;
+	size_t  namel;
+	struct HostTable *hostp;
 
 /*--------------------------------------------------------------------*/
-/*                       Validate the argument                        */
+/*                       Validate the argument								 */
 /*--------------------------------------------------------------------*/
 
-   if ((name == NULL) || ((namel = strlen(name)) == 0))
-   {
-      printmsg(0,"checkReal: Invalid (missing) hostname passed");
-      bugout(function, line);
-   }
+	if ((name == NULL) || ((namel = strlen(name)) == 0))
+	{
+		printmsg(0,"checkReal: Invalid (missing) hostname passed");
+		bugout(function, line);
+	}
 
-   namel = max( strlen(name), HOSTLEN);
-   hostp = searchname( name, namel );
+	namel = max( strlen(name), HOSTLEN);
+	hostp = searchname( name, namel );
 
 /*--------------------------------------------------------------------*/
-/*             If we didn't find the host, return failure             */
+/*             If we didn't find the host, return failure				 */
 /*--------------------------------------------------------------------*/
 
-   if ((hostp == BADHOST) || (hostp->status.hstatus >= HS_NOCALL))
-      return hostp;           /* Return raw information               */
-   else
-      return BADHOST;         /* Not a real host, invalid for our
-                                 purposes                             */
+	if ((hostp == BADHOST) || (hostp->status.hstatus >= HS_NOCALL))
+		return hostp;				/* Return raw information					 */
+	else
+		return BADHOST;			/* Not a real host, invalid for our
+											purposes                             */
 
 } /* searchreal */
 
 /*--------------------------------------------------------------------*/
-/*    s e a r c h n a m e                                             */
+/*    s e a r c h n a m e															 */
 /*                                                                    */
 /*    Look up a system name in our systems (L.sys) file.              */
-/*    Only the first 7 characters of a system name is significant.    */
+/*    Only the first 7 characters of a system name is significant.	 */
 /*--------------------------------------------------------------------*/
 
 struct HostTable *searchname(const char *name, const size_t namel)
 {
-   int   lower;
-   int   upper;
+	int	lower;
+	int	upper;
 
  /*-------------------------------------------------------------------*/
- /*             Initialize the host name table if needed              */
+ /*				 Initialize the host name table if needed              */
  /*-------------------------------------------------------------------*/
 
-   if (HostElements == 0)           /* host table initialized yet?    */
-      HostElements = loadhost();        /* No --> load it             */
+	if (HostElements == 0)				/* host table initialized yet?	 */
+		HostElements = loadhost();        /* No --> load it				 */
 
-   lower = 0;
-   upper = (int) (HostElements - 1);
+	lower = 0;
+	upper = (int) (HostElements - 1);
 
-   while ( lower <= upper )
-   {
-      int midpoint = (lower + upper) / 2;
-      int hit;
+	while ( lower <= upper )
+	{
+		int midpoint = (lower + upper) / 2;
+		int hit;
 
 /*--------------------------------------------------------------------*/
-/*    Compare for up to the specified length of the host name, but    */
-/*    never less than the length of the item we are comparing it      */
+/*    Compare for up to the specified length of the host name, but	 */
+/*    never less than the length of the item we are comparing it		 */
 /*    to.  In other words, the search key can be shorter than the     */
 /*    table entry for a simple host name.                             */
 /*                                                                    */
-/*    This mostly affects simple host names, as domain names          */
-/*    have a Very Large Number (VLN) passed into to insure we         */
+/*    This mostly affects simple host names, as domain names			 */
+/*    have a Very Large Number (VLN) passed into to insure we			 */
 /*    compare the entire length of the name.                          */
 /*--------------------------------------------------------------------*/
 
-      hit = strnicmp(name,hosts[midpoint].hostname,namel);
+		hit = strnicmp(name,hosts[midpoint].hostname,namel);
 
-      if (hit > 0)
-         lower = midpoint + 1;
-      else if ((hit < 0) || (strlen(hosts[midpoint].hostname) > namel))
-         upper = midpoint - 1;
-      else {
+		if (hit > 0)
+			lower = midpoint + 1;
+		else if ((hit < 0) || (strlen(hosts[midpoint].hostname) > namel))
+			upper = midpoint - 1;
+		else {
 
 #ifdef UDEBUG
-            printmsg(8,"searchname: Looking for \"%s\" of length %d,\
+				printmsg(8,"searchname: Looking for \"%s\" of length %d,\
  found \"%s\"",
-            name,
-            namel,
-            hosts[midpoint].hostname);
+				name,
+				namel,
+				hosts[midpoint].hostname);
 #endif
 
-         return &hosts[midpoint];
-      }
-   }
+			return &hosts[midpoint];
+		}
+	}
 
 /*--------------------------------------------------------------------*/
-/*         We didn't find the host.  Return failure to caller         */
+/*         We didn't find the host.  Return failure to caller			 */
 /*--------------------------------------------------------------------*/
 
 #ifdef UDEBUG
-   printmsg(8,"searchname: Looking for \"%s\", did not find it",
-            name);
+	printmsg(8,"searchname: Looking for \"%s\", did not find it",
+				name);
 #endif
 
-   return BADHOST;
+	return BADHOST;
 
-}  /* searchname */
+}	/* searchname */
 
 /*--------------------------------------------------------------------*/
-/*    n e x t h o s t                                                 */
+/*    n e x t h o s t																 */
 /*                                                                    */
-/*    Returns next host in table with requested attribute             */
+/*    Returns next host in table with requested attribute				 */
 /*--------------------------------------------------------------------*/
 
 struct HostTable *nexthost( const KWBoolean start )
 {
-   static size_t current = 0;
+	static size_t current = 0;
 
-   if (HostElements == 0)     /* host table initialized yet?          */
-      HostElements = loadhost(); /* No --> load it                    */
+	if (HostElements == 0)		/* host table initialized yet?			 */
+		HostElements = loadhost(); /* No --> load it                    */
 
-   if (start)
-      current = 0;
-   else
-      current ++;
+	if (start)
+		current = 0;
+	else
+		current ++;
 
-   while ( current < HostElements )
-   {
-      if (hosts[current].status.hstatus >= HS_NOCALL)
-         return &hosts[current];
-      else
-         current++;
-   }
+	while ( current < HostElements )
+	{
+		if (hosts[current].status.hstatus >= HS_NOCALL)
+			return &hosts[current];
+		else
+			current++;
+	}
 
-   return BADHOST;
+	return BADHOST;
 
-}  /* nexthost */
+}	/* nexthost */
 
 /*--------------------------------------------------------------------*/
-/*    i n i t h o s t                                                 */
+/*    i n i t h o s t																 */
 /*                                                                    */
-/*    Intializes a host table entry for for loadhost                  */
+/*    Intializes a host table entry for for loadhost						 */
 /*--------------------------------------------------------------------*/
 
 struct HostTable *inithost(char *name)
 {
 
-   size_t hit = HostElements;
-   size_t element = 0;
-   static size_t max_elements = 32; /* This is automatically
-                                       raised if we run out of room   */
-
-   if (hosts == NULL)
-   {
-      hosts = calloc(max_elements, sizeof(*hosts));
+	size_t hit = HostElements;
+	size_t element = 0;
+	static size_t max_elements = 32; /* This is automatically
+													raised if we run out of room	 */
+
+	if (hosts == NULL)
+	{
+		hosts = calloc(max_elements, sizeof(*hosts));
 
 #ifdef UDEBUG
-      printmsg(5,"inithost: Allocated room for %d host entries",
-               max_elements);
+		printmsg(5,"inithost: Allocated room for %d host entries",
+					max_elements);
 #endif
 
-   }
-   else if ( max_elements == HostElements )
-   {
-      max_elements = max_elements * 2;
-      hosts = realloc(hosts , max_elements * sizeof(*hosts));
+	}
+	else if ( max_elements == HostElements )
+	{
+		max_elements = max_elements * 2;
+		hosts = realloc(hosts , max_elements * sizeof(*hosts));
 
 #ifdef UDEBUG
-      printmsg(5,"inithost: reallocated room for %d host entries",
-               max_elements);
+		printmsg(5,"inithost: reallocated room for %d host entries",
+					max_elements);
 #endif
 
-   }
+	}
 
-   checkref(hosts);
+	checkref(hosts);
 
 /*--------------------------------------------------------------------*/
-/*    Add the host to the table.  Note that we must add the host      */
+/*    Add the host to the table.  Note that we must add the host		 */
 /*    to the table ourselves (rather than use lsearch) because we     */
-/*    must make a copy of the string; the *token we use for the       */
-/*    search is in the middle of our I/O buffer!                      */
+/*    must make a copy of the string; the *token we use for the		 */
+/*    search is in the middle of our I/O buffer!							 */
 /*--------------------------------------------------------------------*/
 
-   while ( element < hit )
-   {
-      if (equali( hosts[element].hostname , name ))
-         hit = element;
-      else
-         element++;
-   }
+	while ( element < hit )
+	{
+		if (equali( hosts[element].hostname , name ))
+			hit = element;
+		else
+			element++;
+	}
 
 /*--------------------------------------------------------------------*/
-/*               If a new element, initialize the block               */
+/*               If a new element, initialize the block					 */
 /*--------------------------------------------------------------------*/
 
-   if (hit == HostElements)
-   {
-      memset( &hosts[hit] , 0, sizeof hosts[hit] );
-      hosts[hit].hostname = newstr(name);
-      checkref( hosts[hit].hostname );
-      hosts[hit].anylogin = KWTrue;  /* Allow generic login by default */
-      HostElements ++ ;
-   } /* if */
+	if (hit == HostElements)
+	{
+		memset( &hosts[hit] , 0, sizeof hosts[hit] );
+		hosts[hit].hostname = newstr(name);
+		checkref( hosts[hit].hostname );
+		hosts[hit].anylogin = KWTrue;  /* Allow generic login by default */
+		HostElements ++ ;
+	} /* if */
 
-   return &hosts[hit];
+	return &hosts[hit];
 
 } /* inithost */
 
 /*--------------------------------------------------------------------*/
-/*    l o a d h o s t                                                 */
+/*    l o a d h o s t																 */
 /*                                                                    */
-/*    Initializes table of known host names for checkname             */
+/*    Initializes table of known host names for checkname				 */
 /*--------------------------------------------------------------------*/
 
 static size_t loadhost()
 {
-   FILE *ff;
-   char *token;
-   char s_hostable[FILENAME_MAX]; /* full-name of hostable file       */
-   size_t hit;
+	FILE *ff;
+	char *token;
+	char s_hostable[FILENAME_MAX]; /* full-name of hostable file		 */
+	size_t hit;
 
-   struct HostTable *hostp;
+	struct HostTable *hostp;
 
 /*--------------------------------------------------------------------*/
-/*                  Load the local host information                   */
+/*                  Load the local host information						 */
 /*--------------------------------------------------------------------*/
 
-   hostp = inithost(E_nodename);
-   hostp->status.hstatus  = HS_LOCALHOST;
-   hostp->realname = E_nodename; /* Don't let user alias our system
-                                    name                              */
+	hostp = inithost(E_nodename);
+	hostp->status.hstatus  = HS_LOCALHOST;
+	hostp->realname = E_nodename; /* Don't let user alias our system
+												name										 */
 
 /*--------------------------------------------------------------------*/
 /*                Now do the local domain information                 */
 /*--------------------------------------------------------------------*/
 
-   if ( E_domain != NULL )
-   {
+	if ( E_domain != NULL )
+	{
 
-      if (strchr(E_domain,'.') == NULL)
-      {
-         printmsg(0,"Domain name \"%s\" is invalid, missing period",
-                     E_domain);
-         panic();
-      }
+		if (strchr(E_domain,'.') == NULL)
+		{
+			printmsg(0,"Domain name \"%s\" is invalid, missing period",
+							E_domain);
+			panic();
+		}
 
-      token = strchr( E_domain, '%' );
+		token = strchr( E_domain, '%' );
 
-      if ( token == NULL )
-         token = strchr( E_domain, '!' );
+		if ( token == NULL )
+			token = strchr( E_domain, '!' );
 
-      if (token != NULL)
-      {
-         printmsg(0,"Domain name \"%s\" contains invalid character \"%c\"",
-                     E_domain,
-                     *token );
-         panic();
-      }
+		if (token != NULL)
+		{
+			printmsg(0,"Domain name \"%s\" contains invalid character \"%c\"",
+							E_domain,
+							*token );
+			panic();
+		}
 
-      hostp = inithost(E_domain);
-      hostp->via = hostp->realname = E_nodename;
+		hostp = inithost(E_domain);
+		hostp->via = hostp->realname = E_nodename;
 
-   } /* if ( E_domain != NULL ) */
+	} /* if ( E_domain != NULL ) */
 
 /*--------------------------------------------------------------------*/
-/*    If we allow anonymous UUCP, load the dummy host we use for      */
-/*    connections to such hosts                                       */
+/*    If we allow anonymous UUCP, load the dummy host we use for		 */
+/*    connections to such hosts													 */
 /*--------------------------------------------------------------------*/
 
-   if ( E_anonymous != NULL )
-   {
-      hostp = inithost( ANONYMOUS_HOST );
-      hostp->status.hstatus = HS_NOCALL;
-      hostp->via     = E_nodename;
-   } /* if */
+	if ( E_anonymous != NULL )
+	{
+		hostp = inithost( ANONYMOUS_HOST );
+		hostp->status.hstatus = HS_NOCALL;
+		hostp->via		= E_nodename;
+	} /* if */
 
 /*--------------------------------------------------------------------*/
-/*                  Load names from the systems file                  */
+/*                  Load names from the systems file						 */
 /*--------------------------------------------------------------------*/
 
-   ff = FOPEN(E_systems, "r",TEXT_MODE);
+	ff = FOPEN(E_systems, "r",TEXT_MODE);
 
-   if (ff == NULL)
-   {
-      printerr(E_systems);
-      panic();
-   }
+	if (ff == NULL)
+	{
+		printerr(E_systems);
+		panic();
+	}
 
-   while (! feof(ff))
-   {
-      char buf[BUFSIZ];
+	while (! feof(ff))
+	{
+		char buf[BUFSIZ];
 
-      if (fgets(buf,BUFSIZ,ff) == NULL)   /* Try to read a line       */
-         break;                  /* Exit if end of file               */
+		if (fgets(buf,BUFSIZ,ff) == NULL)	/* Try to read a line		 */
+			break;						/* Exit if end of file					 */
 
-      token = strtok(buf,WHITESPACE);
+		token = strtok(buf,WHITESPACE);
 
-      if (token == NULL)         /* Any data?                         */
-         continue;               /* No --> read another line          */
+		if (token == NULL)			/* Any data?								 */
+			continue;					/* No --> read another line			 */
 
-      if (token[0] == '#')
-         continue;                  /* Line is a comment; loop again  */
+		if (token[0] == '#')
+			continue;						/* Line is a comment; loop again  */
 
-      if ( equali( token, E_nodename ))
-      {
-         printmsg(0,"Error: Local host %s must not be in SYSTEMS file",
-                    E_nodename );
-         panic();
-      }
+		if ( equali( token, E_nodename ))
+		{
+			printmsg(0,"Error: Local host %s must not be in SYSTEMS file",
+						  E_nodename );
+			panic();
+		}
 
-      hostp = inithost(token);
+		hostp = inithost(token);
 
-      if (hostp->status.hstatus == HS_PHANTOM)
-      {
-         hostp->status.hstatus = HS_NOCALL;
-      }
+		if (hostp->status.hstatus == HS_PHANTOM)
+		{
+			hostp->status.hstatus = HS_NOCALL;
+		}
 
-   } /* while */
+	} /* while */
 
-   fclose(ff);
+	fclose(ff);
 
 /*--------------------------------------------------------------------*/
-/*               Now the load the routing file, if any.               */
+/*               Now the load the routing file, if any.					 */
 /*--------------------------------------------------------------------*/
 
-   mkfilename(s_hostable, E_confdir, PATHS);
+	mkfilename(s_hostable, E_confdir, PATHS);
 
-   if ((E_mailserv != NULL ) &&
-       (ff = FOPEN(s_hostable, "r",TEXT_MODE)) != NULL)
-   {
+	if ((E_mailserv != NULL ) &&
+		 (ff = FOPEN(s_hostable, "r",TEXT_MODE)) != NULL)
+	{
 
-      while (! feof(ff))
-      {
-         char buf[BUFSIZ];
+		while (! feof(ff))
+		{
+			char buf[BUFSIZ];
 
-         KWBoolean freeit = KWFalse;
+			KWBoolean freeit = KWFalse;
 
-         if (fgets(buf,BUFSIZ,ff) == NULL)   /* Try to read a line    */
-            break;                  /* Exit if end of file            */
+			if (fgets(buf,BUFSIZ,ff) == NULL)	/* Try to read a line	 */
+				break;						/* Exit if end of file				 */
 
-         token = strtok(buf,WHITESPACE);
+			token = strtok(buf,WHITESPACE);
 
-         if (token == NULL)         /* Any data?                      */
-            continue;               /* No --> read another line       */
+			if (token == NULL)			/* Any data?							 */
+				continue;					/* No --> read another line		 */
 
-         if (*token == '#')
-            continue;               /* Line is a comment; loop again  */
+			if (*token == '#')
+				continue;					/* Line is a comment; loop again  */
 
-         hostp = inithost(token);
-         token = strtok(NULL,WHITESPACE);
+			hostp = inithost(token);
+			token = strtok(NULL,WHITESPACE);
 
-         if ( token == NULL )
-         {
-            printmsg(0,"loadhost: Missing path name for host \"%s\"",
-                        hostp->hostname);
-            freeit = KWTrue;
-         }
+			if ( token == NULL )
+			{
+				printmsg(0,"loadhost: Missing path name for host \"%s\"",
+								hostp->hostname);
+				freeit = KWTrue;
+			}
 
 /*--------------------------------------------------------------------*/
-/*                              Gate way                              */
+/*                              Gate way										 */
 /*--------------------------------------------------------------------*/
 
-         else if ((equal(token,"|") || equal(token,"@")))
-         {
-            char operator = *token;
+			else if ((equal(token,"|") || equal(token,"@")))
+			{
+				char operator = *token;
 
-            token = strtok(NULL,"\n");
+				token = strtok(NULL,"\n");
 
-            if (( hostp->via != NULL ) || ( token == NULL ))
-               freeit = KWTrue;
-            else {
-               if ( operator == '@' )
-                  hostp->status.hstatus = HS_SMTP;
-               else
-                  hostp->status.hstatus = HS_GATEWAYED;
+				if (( hostp->via != NULL ) || ( token == NULL ))
+					freeit = KWTrue;
+				else {
+					if ( operator == '@' )
+						hostp->status.hstatus = HS_SMTP;
+					else
+						hostp->status.hstatus = HS_GATEWAYED;
 
-               while(isspace( *token ))   /* Drop leading white space only */
-                  token++;
+					while(isspace( *token ))	/* Drop leading white space only */
+						token++;
 
-               if (*token == '\0')        /* Empty string?            */
-                  freeit = KWTrue;         /* Yes --> Flag for error   */
-               else
-                  hostp->via = token = newstr(token);
+					if (*token == '\0')			/* Empty string?				 */
+						freeit = KWTrue;			 /* Yes --> Flag for error   */
+					else
+						hostp->via = token = newstr(token);
 
-            } /* else if */
+				} /* else if */
 
-            if ( freeit )
-               printmsg(0,"loadhost: Invalid/duplicate gateway for \"%s\"",
-                     hostp->hostname );
+				if ( freeit )
+					printmsg(0,"loadhost: Invalid/duplicate gateway for \"%s\"",
+							hostp->hostname );
 
-         } /* else if */
+			} /* else if */
 
 /*--------------------------------------------------------------------*/
 /*                               Alias                                */
 /*--------------------------------------------------------------------*/
 
-         else if (equal(token,"="))
-         {
-            token = strtok(NULL,WHITESPACE);
+			else if (equal(token,"="))
+			{
+				token = strtok(NULL,WHITESPACE);
 
-            if (( hostp->realname == NULL ) && (token != NULL))
-               hostp->realname = token = newstr( token );
-            else {
+				if (( hostp->realname == NULL ) && (token != NULL))
+					hostp->realname = token = newstr( token );
+				else {
 
-               printmsg(0,"loadhost: Invalid/duplicate alias of \"%s\"",
-                     hostp->hostname );
-               freeit = KWTrue;
+					printmsg(0,"loadhost: Invalid/duplicate alias of \"%s\"",
+							hostp->hostname );
+					freeit = KWTrue;
 
-            } /* else */
+				} /* else */
 
-         } /* else if (equal(token,"=")) */
+			} /* else if (equal(token,"=")) */
 
 /*--------------------------------------------------------------------*/
-/*                           Routing entry                            */
+/*                           Routing entry									 */
 /*--------------------------------------------------------------------*/
 
-         else {
+			else {
 
-            if ( hostp->via == NULL )
-               hostp->via = token = newstr( token );
-            else {
-               printmsg(0,"loadhost: Invalid/duplicate route for \"%s\"",
-                     hostp->hostname );
-               freeit = KWTrue;
-            } /* else */
+				if ( hostp->via == NULL )
+					hostp->via = token = newstr( token );
+				else {
+					printmsg(0,"loadhost: Invalid/duplicate route for \"%s\"",
+							hostp->hostname );
+					freeit = KWTrue;
+				} /* else */
 
-         } /* else */
+			} /* else */
 
-         if ( ! freeit )
-         {
-            checkref( token );
+			if ( ! freeit )
+			{
+				checkref( token );
 
-            if (*token == '*')       /* Wildcard on right side?    */
-            {
-               printmsg(0, "loadhost: Wildcard \"%s\" not "
-                           "allowed for real name of host \"%s\"",
-                           token,
-                           hostp->hostname);
-               freeit = KWTrue;
+				if (*token == '*')		 /* Wildcard on right side?	 */
+				{
+					printmsg(0, "loadhost: Wildcard \"%s\" not "
+									"allowed for real name of host \"%s\"",
+									token,
+									hostp->hostname);
+					freeit = KWTrue;
 
-            } /* if (*token == '*') */
+				} /* if (*token == '*') */
 
-         } /* if ( ! freeit ) */
+			} /* if ( ! freeit ) */
 
-         if ( freeit )
-         {
-            if ( hostp->status.hstatus == HS_PHANTOM )
-               HostElements--;            /* Ignore the routing entry */
-         }
+			if ( freeit )
+			{
+				if ( hostp->status.hstatus == HS_PHANTOM )
+					HostElements--;				/* Ignore the routing entry */
+			}
 
-      }  /* end while */
+		}	/* end while */
 
-      fclose(ff);
+		fclose(ff);
 
-   } /* if ((E_mailserv != NULL ) && ... */
-   else {
+	} /* if ((E_mailserv != NULL ) && ... */
+	else {
 
-      if (( debuglevel > 2 ) && (E_mailserv != NULL ))
-         perror( s_hostable );
+		if (( debuglevel > 2 ) && (E_mailserv != NULL ))
+			perror( s_hostable );
 
-   } /* else */
+	} /* else */
 
 /*--------------------------------------------------------------------*/
-/*                   Provide default for fromdomain                   */
+/*                   Provide default for fromdomain						 */
 /*--------------------------------------------------------------------*/
 
-   if ( E_mailserv != NULL )
-   {
-      if (E_fdomain != NULL)     /* If fromdomain provided ...        */
-      {
-         hostp = inithost(E_fdomain);
+	if ( E_mailserv != NULL )
+	{
+		if (E_fdomain != NULL)		/* If fromdomain provided ...        */
+		{
+			hostp = inithost(E_fdomain);
 
-         if (hostp->via == NULL)    /* Uninitialized?                 */
-            hostp->via = E_mailserv;   /* Yes --> Use default route   */
-      }
-      else
-         E_fdomain = E_domain;   /* Use domain as fromdomain          */
-   }
+			if (hostp->via == NULL)    /* Uninitialized?                 */
+				hostp->via = E_mailserv;	/* Yes --> Use default route	 */
+		}
+		else
+			E_fdomain = E_domain;	/* Use domain as fromdomain			 */
+	}
 
 /*--------------------------------------------------------------------*/
 /*    Shrink the table to whatever we actually need, then sort it     */
 /*--------------------------------------------------------------------*/
 
-   hosts = realloc(hosts, HostElements *  sizeof(*hosts));
-   checkref(hosts);
+	hosts = realloc(hosts, HostElements *	sizeof(*hosts));
+	checkref(hosts);
 
-   qsort(hosts, HostElements ,sizeof(hosts[0]) , hostcmp);
+	qsort(hosts, HostElements ,sizeof(hosts[0]) , hostcmp);
 
 /*--------------------------------------------------------------------*/
 /*                      Display the final table                       */
 /*--------------------------------------------------------------------*/
 
-   for (hit = 0; hit < HostElements; hit++)
-   {
-      printmsg(8,"loadhost: entry[%02d:%02d] %-20s\tvia %s\talias %s",
-                  hit,
-                  hosts[hit].status.hstatus,
-                  hosts[hit].hostname,
-                  (hosts[hit].via == NULL) ? "(self)" : hosts[hit].via,
-                  (hosts[hit].realname == NULL)
-                                    ? "(self)" : hosts[hit].realname);
-   } /* for */
+	for (hit = 0; hit < HostElements; hit++)
+	{
+		printmsg(8,"loadhost: entry[%02d:%02d] %-20s\tvia %s\talias %s",
+						hit,
+						hosts[hit].status.hstatus,
+						hosts[hit].hostname,
+						(hosts[hit].via == NULL) ? "(self)" : hosts[hit].via,
+						(hosts[hit].realname == NULL)
+												? "(self)" : hosts[hit].realname);
+	} /* for */
 
 /*--------------------------------------------------------------------*/
-/*      If not processing domain/routing information, return now      */
+/*      If not processing domain/routing information, return now		 */
 /*--------------------------------------------------------------------*/
 
-   if ( E_mailserv == NULL )
-      return (HostElements) ;
+	if ( E_mailserv == NULL )
+		return (HostElements) ;
 
 /*--------------------------------------------------------------------*/
-/*    If the user did not define a local domain, then generate one    */
-/*    based on our own domain name; the generated name will either    */
+/*    If the user did not define a local domain, then generate one	 */
+/*    based on our own domain name; the generated name will either	 */
 /*    be of the format ".a.b.c" (incuding the trailing period) or     */
 /*    a null string.                                                  */
 /*--------------------------------------------------------------------*/
 
-   if ( E_localdomain == NULL )
-   {
-      E_localdomain = strchr(E_domain,'.');
+	if ( E_localdomain == NULL )
+	{
+		E_localdomain = strchr(E_domain,'.');
 
-      if (E_localdomain == NULL)
-         E_localdomain = "UUCP";
-      else {
+		if (E_localdomain == NULL)
+			E_localdomain = "UUCP";
+		else {
 
-         E_localdomain ++;    /* Step past the period                 */
+			E_localdomain ++;    /* Step past the period                 */
 
-         if ( !equali(E_localdomain, "UUCP" ) &&
-              (strchr( E_localdomain, '.' ) == NULL ))
-                              /* Implied single level domain name?    */
-            E_localdomain = E_domain;
-                              /* Impossible, use both parts of name   */
+			if ( !equali(E_localdomain, "UUCP" ) &&
+				  (strchr( E_localdomain, '.' ) == NULL ))
+										/* Implied single level domain name?	 */
+				E_localdomain = E_domain;
+										/* Impossible, use both parts of name	 */
 
-      } /* else */
+		} /* else */
 
-      printmsg(3,"loadhost: domain name is %s, "
-                 "domain in RFC-822 mail is %s, "
-                 "other systems assumed in %s domain",
-                 E_domain,
-                 E_fdomain,
-                 E_localdomain);
+		printmsg(3,"loadhost: domain name is %s, "
+					  "domain in RFC-822 mail is %s, "
+					  "other systems assumed in %s domain",
+					  E_domain,
+					  E_fdomain,
+					  E_localdomain);
 
-   } /* if */
+	} /* if */
 
-   localdomainl = strlen(E_localdomain);
+	localdomainl = strlen(E_localdomain);
 
 /*--------------------------------------------------------------------*/
-/*    Amend for the sin of typing the domain wrong in the sample      */
+/*    Amend for the sin of typing the domain wrong in the sample		 */
 /*    files for the old releases of UUPC/extended.                    */
 /*--------------------------------------------------------------------*/
 
-   if (equali(E_localdomain,"UUPC"))
-   {
-      printmsg(0,"inithost: UUPC is an invalid domain name! "
-                 "Change it to UUCP");
-      panic();
-   }
+	if (equali(E_localdomain,"UUPC"))
+	{
+		printmsg(0,"inithost: UUPC is an invalid domain name! "
+					  "Change it to UUCP");
+		panic();
+	}
 
 /*--------------------------------------------------------------------*/
 /*                          Return to caller                          */
 /*--------------------------------------------------------------------*/
 
-   return (HostElements) ;
+	return (HostElements) ;
 
 } /*loadhost*/
 
 /*--------------------------------------------------------------------*/
-/*    h o s t c m p                                                   */
+/*    h o s t c m p																	 */
 /*                                                                    */
 /*    Accepts indirect pointers to two strings and compares           */
-/*    them using stricmp (case insensitive string compare)            */
+/*    them using stricmp (case insensitive string compare)				 */
 /*--------------------------------------------------------------------*/
 
 int hostcmp( const void *a , const void *b )
 {
 
-   return stricmp(((struct HostTable*) a)->hostname,
-        ((struct HostTable*) b)->hostname);
+	return stricmp(((struct HostTable*) a)->hostname,
+		  ((struct HostTable*) b)->hostname);
 
-}  /*hostcmp*/
+}	/*hostcmp*/
--- e:\uupc1.12s\source\lib\IMPORT.C	Sun Mar 30 22:59:58 1997
+++ IMPORT.C	Thu Aug 21 19:57:36 1997
@@ -1,14 +1,14 @@
 /*--------------------------------------------------------------------*/
-/*    i m p o r t . c                                                 */
+/*    i m p o r t . c																 */
 /*                                                                    */
 /*    File name mapping routines for UUPC/extended                    */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*    Changes Copyright (c) 1989-1997 by Kendra Electronic            */
-/*    Wonderworks.                                                    */
+/*    Changes Copyright (c) 1989-1997 by Kendra Electronic				 */
+/*    Wonderworks.																	 */
 /*                                                                    */
-/*    All rights reserved except those explicitly granted by the      */
+/*    All rights reserved except those explicitly granted by the		 */
 /*    UUPC/extended license agreement.                                */
 /*--------------------------------------------------------------------*/
 
@@ -16,36 +16,36 @@
  *    $Id: import.c 1.35 1997/03/31 07:00:05 ahd Exp $
  *
  *    $Log: import.c $
- *    Revision 1.35  1997/03/31 07:00:05  ahd
+ *    Revision 1.35	1997/03/31 07:00:05	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.34  1996/11/18 04:46:49  ahd
+ *    Revision 1.34	1996/11/18 04:46:49	ahd
  *    Normalize arguments to bugout
  *    Reset title after exec of sub-modules
  *    Normalize host status names to use HS_ prefix
  *
- *    Revision 1.33  1996/01/01 20:55:48  ahd
+ *    Revision 1.33	1996/01/01 20:55:48	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.32  1995/12/12 13:48:54  ahd
+ *    Revision 1.32	1995/12/12 13:48:54	ahd
  *    restrict issuing importPath messages to higher verbosity levels
  *
- *    Revision 1.31  1995/09/24 19:07:05  ahd
+ *    Revision 1.31	1995/09/24 19:07:05	ahd
  *    Trap invalid input names with spaces
  *
- *    Revision 1.30  1995/01/29 16:43:03  ahd
+ *    Revision 1.30	1995/01/29 16:43:03	ahd
  *    IBM C/Set compiler warnings
  *
- *    Revision 1.29  1995/01/07 16:12:48  ahd
+ *    Revision 1.29	1995/01/07 16:12:48	ahd
  *    Change KWBoolean to KWBoolean to avoid VC++ 2.0 conflict
  *
- *    Revision 1.28  1995/01/03 05:32:26  ahd
+ *    Revision 1.28	1995/01/03 05:32:26	ahd
  *    Reduce, clarify logging in OS/2 Advanced FS function
  *
- *    Revision 1.27  1994/12/22 00:09:09  ahd
+ *    Revision 1.27	1994/12/22 00:09:09	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.26  1994/06/13 00:14:17  ahd
+ *    Revision 1.26	1994/06/13 00:14:17	ahd
  *    Use Kai Uwe Rommel's dummy file open to check valid file names
  *    rather than file system name under OS/2
  *
@@ -98,36 +98,36 @@
  *     Revision 1.10  1993/10/09  15:46:15  rhg
  *     ANSIify the source
  *
- *     Revision 1.9  1993/09/27  04:04:06  ahd
+ *     Revision 1.9	1993/09/27	04:04:06  ahd
  *     Correct creation of pointer to file system name
  *
- *     Revision 1.8  1993/09/26  03:32:27  dmwatt
+ *     Revision 1.8	1993/09/26	03:32:27  dmwatt
  *     Use Standard Windows NT error message module
  *
- *     Revision 1.7  1993/09/20  04:38:11  ahd
+ *     Revision 1.7	1993/09/20	04:38:11  ahd
  *     TCP/IP support from Dave Watt
  *     't' protocol support
  *     OS/2 2.x support
  *
- *     Revision 1.6  1993/09/03  12:54:55  ahd
+ *     Revision 1.6	1993/09/03	12:54:55  ahd
  *     Add missing endif
  *
- *     Revision 1.5  1993/09/03  12:18:55  dmwatt
+ *     Revision 1.5	1993/09/03	12:18:55  dmwatt
  *     Windows NT support for long names on file systems
  *
- *     Revision 1.4  1993/09/02  12:08:17  ahd
+ *     Revision 1.4	1993/09/02	12:08:17  ahd
  *     HPFS Support
  *
- *     Revision 1.3  1993/04/11  00:31:31  dmwatt
+ *     Revision 1.3	1993/04/11	00:31:31  dmwatt
  *     Global edits for year, TEXT, etc.
  *
- * Revision 1.2  1992/11/22  21:06:14  ahd
+ * Revision 1.2  1992/11/22  21:06:14	ahd
  * Correct mapping of dos paths with trailing slashes
  *
  */
 
 /*--------------------------------------------------------------------*/
-/*                        System include files                        */
+/*                        System include files								 */
 /*--------------------------------------------------------------------*/
 
 #include "uupcmoah.h"
@@ -146,7 +146,7 @@
 #endif
 
 /*--------------------------------------------------------------------*/
-/*                    UUPC/extended include files                     */
+/*                    UUPC/extended include files							 */
 /*--------------------------------------------------------------------*/
 
 #include "import.h"
@@ -159,7 +159,7 @@
 #include "pnterr.h"
 #endif
 
-#define MAX_DIGITS 20         /* Number of digits for arb math */
+#define MAX_DIGITS 20			/* Number of digits for arb math */
 
 /*--------------------------------------------------------------------*/
 /*                    Internal function prototypes                    */
@@ -169,59 +169,63 @@
 #define min(x,y) (((x) < (y)) ? (x) : (y))
 #endif
 
+#ifndef max
+#define max(x,y) (((x) > (y)) ? (x) : (y))
+#endif
+
 currentfile();
 
 /*--------------------------------------------------------------------*/
-/*                     Local function prototypes                      */
+/*                     Local function prototypes							 */
 /*--------------------------------------------------------------------*/
 
 static void ImportName( char *local,
-                        const char *canon,
-                        size_t charsetsize,
-                        const KWBoolean longname );
+								const char *canon,
+								size_t charsetsize,
+								const KWBoolean longname );
 
 static KWBoolean advancedFS( const char *path );
 
 /*--------------------------------------------------------------------*/
 /*                                                                    */
-/*   i m p o r t p a t h                                              */
+/*   i m p o r t p a t h															 */
 /*                                                                    */
-/*   Convert a canonical name to a format the host can handle         */
+/*   Convert a canonical name to a format the host can handle			 */
 /*                                                                    */
-/*   These routines convert file name between canonical form, which   */
+/*   These routines convert file name between canonical form, which	 */
 /*   is defined as a 'unix' style pathname, and the MS-DOS all        */
-/*   uppercase "xxxxxxxx.xxx" format.                                 */
+/*   uppercase "xxxxxxxx.xxx" format.											 */
 /*                                                                    */
 /*   If the canonical name does not have a path, that is the file is  */
-/*   destined for the local spool directory, we can assume the UNIX   */
-/*   name will normally be in a format like this:                     */
+/*   destined for the local spool directory, we can assume the UNIX	 */
+/*   name will normally be in a format like this:							 */
 /*                                                                    */
 /*                                                                    */
-/*       X.hostid#######            (Execute files)                   */
-/*       C.hostid#######            (Call files)                      */
-/*       D.hostid#######            (Data files)                      */
+/*       X.hostid#######				(Execute files)						 */
+/*       C.hostid#######				(Call files)							 */
+/*       D.hostid#######				(Data files)							 */
 /*                                                                    */
 /*   where "hostid" may be most, but not always all, of the local     */
-/*   host or remote host (the file came from or is going to) and      */
-/*   "######" can be any character valid for the UNIX file system.    */
-/*   Note, however, that the routine has to be generic to allow for   */
+/*   host or remote host (the file came from or is going to) and		 */
+/*   "######" can be any character valid for the UNIX file system.	 */
+/*   Note, however, that the routine has to be generic to allow for	 */
 /*   other file names to be placed in the spool directory without     */
-/*   collisions.                                                      */
+/*   collisions.																		 */
 /*                                                                    */
-/*   Avoiding collisions in the spool directory is important; when    */
-/*   receiving files with mixed case names longer than 11             */
-/*   characters, sooner or later a file name collision will occur.    */
-/*                                                                    */
-/*   We can also assume that only UUPC will see these names, which    */
-/*   means we can transform the name using any method we choose, so   */
-/*   long as the UUPC functions opening the file always call          */
-/*   importpath, and that importpath is reducible (that is, two       */
-/*   calls to importpath with the same argument always yield the      */
-/*   same result).  Note that if end user really wanted the file in   */
-/*   the spool directory, all he has to do is rename the file-- far   */
+/*   Avoiding collisions in the spool directory is important; when	 */
+/*   receiving files with mixed case names longer than 11				 */
+/*   characters, sooner or later a file name collision will occur.	 */
+/*                                                                    */
+/*   We can also assume that only UUPC will see these names, which	 */
+/*   means we can transform the name using any method we choose, so	 */
+/*   long as the UUPC functions opening the file always call			 */
+/*   importpath, and that importpath is reducible (that is, two		 */
+/*   calls to importpath with the same argument always yield the		 */
+/*   same result).  Note that if end user really wanted the file in	 */
+/*   the spool directory, all he has to do is rename the file-- far	 */
 /*   better than losing the data because duplicate file names.        */
 /*                                                                    */
-/*   For these files, we map the name as follows:                     */
+/*   For these files, we map the name as follows:							 */
 /*                                                                    */
 /*   0 - If the name is a valid MS-DOS name, use it without changing  */
 /*                                                                    */
@@ -230,571 +234,655 @@
 /*       a subdirectory name.                                         */
 /*                                                                    */
 /*   2 - If the input name begins with an uppercase alphabetic        */
-/*       character followed by a period, also insert the alphabetic   */
-/*       (followed by a slash) to make this a second subdirectory.    */
+/*       character followed by a period, also insert the alphabetic	 */
+/*       (followed by a slash) to make this a second subdirectory.	 */
 /*       Then, move the logical start of the input name past the two  */
 /*       characters.                                                  */
 /*                                                                    */
 /*   3 - Determine the number of characters the local host and        */
 /*       remote hosts have equal to the next characters of the input  */
-/*       name, up to a maximum of 8, and zero the lower of the two    */
-/*       counts.  Then, step past the number of characters of the     */
-/*       larger count.                                                */
+/*       name, up to a maximum of 8, and zero the lower of the two	 */
+/*       counts.	Then, step past the number of characters of the     */
+/*       larger count.																 */
 /*                                                                    */
 /*       For example, if the file name is X.keane22222 and the local  */
-/*       host name is kendra (2 characters match) and the remote      */
-/*       host is keane1 (5 characters match), zero the number of      */
+/*       host name is kendra (2 characters match) and the remote		 */
+/*       host is keane1 (5 characters match), zero the number of		 */
 /*       characters matched by kendra, and make the new start of the  */
 /*       file name five characters further (at the first "2").        */
 /*                                                                    */
-/*   4 - Convert the remaining string using a base conversion, with   */
-/*       the input character size being from ascii "#" to ascii "z"   */
-/*       (88 characters) to the allowed set of characters in MS-DOS   */
-/*       file names (charset, below, 52 characters).                  */
-/*                                                                    */
-/*   5 - Prepend to the string to be converted the length of the      */
-/*       remote host added to the length of the local host            */
-/*       multiplied by 8 (both lengths were computed in step 3,       */
-/*       above).  The base conversion is also applied to this         */
+/*   4 - Convert the remaining string using a base conversion, with	 */
+/*       the input character size being from ascii "#" to ascii "z"	 */
+/*       (88 characters) to the allowed set of characters in MS-DOS	 */
+/*       file names (charset, below, 52 characters).						 */
+/*                                                                    */
+/*   5 - Prepend to the string to be converted the length of the		 */
+/*       remote host added to the length of the local host				 */
+/*       multiplied by 8 (both lengths were computed in step 3,		 */
+/*       above).	The base conversion is also applied to this			 */
 /*       "character", we which know will be in the range 1-64.        */
 /*                                                                    */
-/*   6 - If the string created by steps 4 and 5 exceeds 8             */
-/*       characters, insert a period after the eighth character to    */
+/*   6 - If the string created by steps 4 and 5 exceeds 8				 */
+/*       characters, insert a period after the eighth character to	 */
 /*       make it a valid MS-DOS file name.  If the string created by  */
 /*       steps 4 and 5 exceeds 11 characters, truncate the string by  */
-/*       using the first eight and last three characters.             */
+/*       using the first eight and last three characters.				 */
 /*                                                                    */
-/*   7 - Append the string created in steps 4 through 6 to the path   */
-/*       name created in steps 1 and 2.                               */
+/*   7 - Append the string created in steps 4 through 6 to the path	 */
+/*       name created in steps 1 and 2.										 */
 /*                                                                    */
-/*   If the canonical name has a path, it is destined for an end      */
+/*   If the canonical name has a path, it is destined for an end		 */
 /*   user, so we should not radically transform it like we do for     */
-/*   files in the spool directory.  Thus, if the canonical name has   */
+/*   files in the spool directory.	Thus, if the canonical name has	 */
 /*   a path, mung the canonical file name as follows:                 */
 /*                                                                    */
-/*   1 - skip any path from the canonical name                        */
+/*   1 - skip any path from the canonical name								 */
 /*                                                                    */
 /*   2 - copy up to 8 character from the canonical name converting .  */
 /*       to _ and uppercase to lowercase.                             */
 /*                                                                    */
-/*   3 - if the name was longer than 8 character copy a . to the      */
-/*       host name and then copy the up to three characters from      */
-/*       the tail of the canonical name to the host name.             */
+/*   3 - if the name was longer than 8 character copy a . to the		 */
+/*       host name and then copy the up to three characters from		 */
+/*       the tail of the canonical name to the host name.				 */
 /*                                                                    */
-/*   Note that this set of rules will cause a collision with names    */
+/*   Note that this set of rules will cause a collision with names	 */
 /*   that only differ in case, but leaves the name in a recongizable  */
-/*   format for the user.                                             */
+/*   format for the user.															 */
 /*--------------------------------------------------------------------*/
 
 void importpath(char *local, const char *canon, const char *remote)
 {
-   char *s, *out;
-   size_t charsetsize;     /* Number of allowed characters in
-                              MS-DOS file names                   */
+	char *s, *out;
+	size_t charsetsize;		/* Number of allowed characters in
+										MS-DOS file names                   */
 
-   out = local;
+	out = local;
 
 /*--------------------------------------------------------------------*/
-/*                       Verify our parameters                        */
+/*                       Verify our parameters								 */
 /*--------------------------------------------------------------------*/
 
-   if ( local == NULL )
-      panic();
+	if ( local == NULL )
+		panic();
 
-   if ( canon == NULL )
-      panic();
+	if ( canon == NULL )
+		panic();
 
 /*--------------------------------------------------------------------*/
-/*                      Define our character set                      */
+/*                      Define our character set							 */
 /*--------------------------------------------------------------------*/
 
-    if ( E_charset == NULL )
-       E_charset = DOSCHARS;
+	 if ( E_charset == NULL )
+		 E_charset = DOSCHARS;
 
-    charsetsize = strlen( E_charset );
+	 charsetsize = strlen( E_charset );
 
 /*--------------------------------------------------------------------*/
-/*                 Determine if spool file directory                  */
+/*                 Determine if spool file directory						 */
 /*--------------------------------------------------------------------*/
 
-   if ((s = strrchr(canon, '/')) == NULL)
-   {                          /* File for spooling directory, use
-                                 internal character set to avoid
-                                 collisions                           */
-      static size_t range =  UNIX_END_C - UNIX_START_C + 1;
-                              /* Determine unique number characters in
-                                 the UNIX file names we are mapping   */
+	if ((s = strrchr(canon, '/')) == NULL)
+	{									/* File for spooling directory, use
+											internal character set to avoid
+											collisions									 */
+		static size_t range =  UNIX_END_C - UNIX_START_C + 1;
+										/* Determine unique number characters in
+											the UNIX file names we are mapping	 */
 
-      size_t remlen = min(HOSTLEN, strlen(remote));
-                              /* Length of the remote name passed
-                                 in, shortened below to number of
-                                 characters matched in name           */
-      size_t nodelen = min(HOSTLEN, strlen(E_nodename));
-                              /* Length of the local host name,
-                                 shortened below to number of
-                                 characters matched in name           */
-      size_t subscript = 0;   /* Value of UNIX character to be
-                                 converted to MS-DOS character set    */
-      char *next        = local + remlen;
-      char tempname[FILENAME_MAX];
-      unsigned char number[MAX_DIGITS];
-                              /* Arbitary length number, for base
-                                 conversions                        */
+		size_t remlen = min(HOSTLEN, strlen(remote));
+										/* Length of the remote name passed
+											in, shortened below to number of
+											characters matched in name           */
+		size_t nodelen = min(HOSTLEN, strlen(E_nodename));
+										/* Length of the local host name,
+											shortened below to number of
+											characters matched in name           */
+		size_t subscript = 0;	/* Value of UNIX character to be
+											converted to MS-DOS character set	 */
+		char *next			= local + remlen;
+		char tempname[FILENAME_MAX];
+		unsigned char number[MAX_DIGITS];
+										/* Arbitary length number, for base
+											conversions                        */
 
-      KWBoolean longname;
+		KWBoolean longname;
 
-      if ( bflag[F_LONGNAME] && advancedFS( E_spooldir ) )
-         longname = KWTrue;
-      else
-         longname = KWFalse;
+#ifdef DEBUG
+		printmsg(15, "File for spooling directory");
+#endif
+
+		if ( bflag[F_LONGNAME] && advancedFS( E_spooldir ) )
+			longname = KWTrue;
+		else
+			longname = KWFalse;
 
 /*--------------------------------------------------------------------*/
 /*                    Verify we have a remote name                    */
 /*--------------------------------------------------------------------*/
 
-      if ( remote == NULL )
-         panic();
+		if ( remote == NULL )
+			panic();
 
 /*--------------------------------------------------------------------*/
-/*    Put the host name (up to six characters) at the beginning of    */
-/*    the MS-DOS file name as a sub-directory name.                   */
+/*    Put the host name (up to six characters) at the beginning of	 */
+/*    the MS-DOS file name as a sub-directory name.						 */
 /*--------------------------------------------------------------------*/
 
-      strncpy(local, remote, remlen);
-      *next++ = '/';          /* Add in the sub-directory seperator   */
-      s = (char *) canon;     /* Get the beginnging of the UNIX name  */
-
-/*--------------------------------------------------------------------*/
-/*    Files in the spooling directory generally start with "D.",      */
-/*    "C.", or "X."; strip off any upper case letter followed by a    */
-/*    period into its own directory.                                  */
-/*--------------------------------------------------------------------*/
-
-      if ((s[0] >= 'A') && (s[0] <= 'Z') && (s[1] == '.'))
-      {
-         *next++ = *s;        /* Copy the input character             */
-         *next++ = '/';       /* Add the sub-directory indicator too  */
-         s += 2;              /* Step input string past the copied
-                                 data                                 */
-      }
-
-      while( remlen > 0 )
-      {
-         if (equaln(remote,s,remlen))
-            break;
-         remlen--;
-      }
-
-      while( nodelen > 0 )
-      {
-         if (equaln(E_nodename,s,nodelen))
-            break;
-         nodelen--;
-      }
-
-      if (nodelen > remlen )
-      {
-         remlen = 0;
-         s += nodelen;
-      }
-      else {
-         nodelen = 0;
-         s += remlen;
-      }
+		strncpy(local, remote, remlen);
+		*next++ = '/';          /* Add in the sub-directory seperator	 */
+		s = (char *) canon;		/* Get the beginnging of the UNIX name  */
+
+/*--------------------------------------------------------------------*/
+/*    Files in the spooling directory generally start with "D.",		 */
+/*    "C.", or "X."; strip off any upper case letter followed by a	 */
+/*    period into its own directory.											 */
+/*--------------------------------------------------------------------*/
+
+		if ((s[0] >= 'A') && (s[0] <= 'Z') && (s[1] == '.'))
+		{
+			*next++ = *s;			/* Copy the input character				 */
+			*next++ = '/';       /* Add the sub-directory indicator too  */
+			s += 2;					/* Step input string past the copied
+											data											 */
+		}
+
+		while( remlen > 0 )
+		{
+			if (equaln(remote,s,remlen))
+				break;
+			remlen--;
+		}
+
+		while( nodelen > 0 )
+		{
+			if (equaln(E_nodename,s,nodelen))
+				break;
+			nodelen--;
+		}
+
+		if (nodelen > remlen )
+		{
+			remlen = 0;
+			s += nodelen;
+		}
+		else
+		{
+			nodelen = 0;
+			s += remlen;
+		}
 
-      *next  = '\0';          /* Terminate first part of host string  */
+		*next  = '\0';          /* Terminate first part of host string  */
 
 /*--------------------------------------------------------------------*/
 /*       Create a binary number which represents our file name        */
 /*--------------------------------------------------------------------*/
 
-      for (subscript = 0; subscript < MAX_DIGITS; subscript++ )
-         number[subscript] = 0;  /* Initialize number to zero         */
+		for (subscript = 0; subscript < MAX_DIGITS; subscript++ )
+			number[subscript] = 0;	/* Initialize number to zero			 */
 
-      add(number, nodelen + remlen * HOSTLEN, MAX_DIGITS);
-                                 /* Append host name info to the
-                                    front of the converted string     */
-
-      while( (*s != '\0') && (*number == '\0'))
-      {
-         if ( isspace( *s ) )
-         {
-            printmsg(0,"importPath: Invalid file \"%s\" for %s, "
-                       "name contains whitespace",
-                       canon,
-                       remote );
-            panic();
-         }
-
-         mult(number, range, MAX_DIGITS); /* Shift the number over    */
-         add(number, (unsigned) (*s++  - UNIX_START_C) , MAX_DIGITS);
-                                          /* Add in new low order     */
-      } /* while */
+		add(number, nodelen + remlen * HOSTLEN, MAX_DIGITS);
+											/* Append host name info to the
+												front of the converted string     */
+
+		while( (*s != '\0') && (*number == '\0'))
+		{
+			if ( isspace( *s ) )
+			{
+				printmsg(0,"importPath: Invalid file \"%s\" for %s, "
+							  "name contains whitespace",
+							  canon,
+							  remote );
+				panic();
+			}
+
+			mult(number, range, MAX_DIGITS); /* Shift the number over	 */
+			add(number, (unsigned) (*s++	- UNIX_START_C) , MAX_DIGITS);
+														/* Add in new low order     */
+		} /* while */
 
 /*--------------------------------------------------------------------*/
-/*   We now have stripped off the leading x. and host name, if any;   */
+/*   We now have stripped off the leading x. and host name, if any;	 */
 /*   now, convert the remaining characters in the name by doing a     */
 /*   range to charset base conversion.                                */
 /*--------------------------------------------------------------------*/
 
-      out = &tempname[FILENAME_MAX];
-      *--out = '\0';          /* Terminate the string we will build   */
+		out = &tempname[FILENAME_MAX];
+		*--out = '\0';          /* Terminate the string we will build	 */
 
 /*--------------------------------------------------------------------*/
-/*         Here's the loop to actually do the base conversion         */
+/*         Here's the loop to actually do the base conversion			 */
 /*--------------------------------------------------------------------*/
 
-      while(adiv( number, charsetsize, &subscript, MAX_DIGITS))
-            *--out = E_charset[ subscript ];
+		while(adiv( number, charsetsize, &subscript, MAX_DIGITS))
+				*--out = E_charset[ subscript ];
 
 /*--------------------------------------------------------------------*/
 /*    The conversion is done; now squeeze it into an 11 character     */
-/*    MS-DOS name with period.                                        */
+/*    MS-DOS name with period.													 */
 /*--------------------------------------------------------------------*/
 
-      ImportName( next, out, charsetsize, longname );
+		ImportName( next, out, charsetsize, longname );
 
-   }
-   else {         /* Not file for spooling directory, convert it  */
+	}
+	else
+	{			 /* Not file for spooling directory, convert it  */
 
-      char *in = (char *) canon;
-      KWBoolean longname ;
+		char *in = (char *) canon;
+		KWBoolean longname ;
 
-      longname = advancedFS( canon );
+#ifdef DEBUG
+		printmsg(15, "Not file for spooling directory");
+#endif
 
-      if ( ValidDOSName( canon, longname ))
-      {
-         strcpy( local, canon );
-         return;
-      }
+		longname = advancedFS( canon );
+
+// The problem occurs somewhere after here
+#ifdef DEBUG
+		printmsg(10, "Returned from advancedFS()");
+		printmsg(10, "longname=%lu, canon: %s", longname, canon);
+		fflush(stderr);
+#endif
+
+		if ( ValidDOSName( canon, longname ))
+		{
+#ifdef DEBUG
+			printmsg(10, "name is valid: %s", canon);
+			fflush(stderr);
+#endif
+			strcpy( local, canon );
+#ifdef DEBUG
+			printmsg(10, "local is now %s", local);
+			fflush(stderr);
+#endif
+			return;
+		}
+#ifdef DEBUG
+		else
+		{
+			printmsg(10, "name is not valid: %s", canon);
+		}
+#endif
+
+#ifdef DEBUG
+		printmsg(10, "After ValidDOSName()");
+		printmsg(10, "Are we getting close yet?");
+		fflush(stderr);
+#endif
 
 /*--------------------------------------------------------------------*/
-/*      Handle leading drive letter (ignore it, assuming valid)       */
+/*      Handle leading drive letter (ignore it, assuming valid)		 */
 /*--------------------------------------------------------------------*/
 
-      if ( isalpha( *in ) && (in[1] == ':'))
-      {
-         *out++ = *in++;      /* The drive letter                     */
-         *out++ = *in++;      /* The colon making it a driver letter  */
-      } /* if */
+		if ( isalpha( *in ) && (in[1] == ':'))
+		{
+			*out++ = *in++;		/* The drive letter							 */
+			*out++ = *in++;		/* The colon making it a driver letter  */
+#ifdef DEBUG
+			printmsg(10, "There was a drive letter");
+#endif
+		} /* if */
+#ifdef DEBUG
+		else
+		{
+			printmsg(10, "There was no drive letter");
+		}
+		fflush(stderr);
+#endif
 
-      if ( *in == '/' )       /* Absolute path name?                  */
-         *out++ = *in++;      /* Yes, step past it                    */
+		if ( *in == '/' )       /* Absolute path name?						 */
+			*out++ = *in++;		/* Yes, step past it                    */
+
+#ifdef DEBUG
+		printmsg(10, "After Absolute path name");
+#endif
 
-      while( *in == '/')      /* Additional slashes?                  */
-         in++;                /* Skip them,  they mean nothing        */
+		while( *in == '/')		/* Additional slashes?						 */
+			in++;                /* Skip them,	they mean nothing        */
 
-      s = strchr( in, '/' );  /* Get end of next path segment         */
+		s = strchr( in, '/' );	/* Get end of next path segment			 */
+
+#ifdef DEBUG
+		printmsg(10, "next path segment, s: %s", s);
+#endif
 
 /*--------------------------------------------------------------------*/
 /*              Now convert each simple name in the path              */
 /*--------------------------------------------------------------------*/
 
-      while ( *in )
-      {
-         if ( s != NULL )
-            *s = '\0';        /* Truncate input string to simple name */
-
-         ImportName( out, in , charsetsize, longname );
-
-         if ( s == NULL )
-            break;
-         out = out + strlen( out );
-         *out++ = *s++ = '/'; /* Restore path to input and output     */
-         in = s;              /* Remember start of this simple name   */
-         while( *in == '/')   /* Additional slashes?                  */
-            in++;             /* Skip them,  they mean nothing        */
-         s = strchr( in , '/' );
-      }
+		while ( *in )
+		{
+			if ( s != NULL )
+				*s = '\0';			/* Truncate input string to simple name */
+
+			ImportName( out, in , charsetsize, longname );
+
+#ifdef DEBUG
+			printmsg(15, "Returned from ImportName()");
+			printmsg(15, "out: %s, in: %s", out, in);
+			fflush(stderr);
+#endif
+
+			if ( s == NULL )
+				break;
+			out = out + strlen( out );
+			*out++ = *s++ = '/'; /* Restore path to input and output     */
+			in = s;					/* Remember start of this simple name	 */
+			while( *in == '/')	/* Additional slashes?						 */
+				in++;             /* Skip them,	they mean nothing        */
+			s = strchr( in , '/' );
+		}
 
-   } /* else */
+	} /* else */
 
-   printmsg( equali(canon,local) ? 8 : 4,
-            "ImportPath: Mapped %s to %s", canon, local );
+	printmsg( equali(canon,local) ? 8 : 4,
+				"ImportPath: Mapped %s to %s", canon, local );
 
 } /*importpath*/
 
 /*--------------------------------------------------------------------*/
-/*    I m p o r t N a m e                                             */
+/*    I m p o r t N a m e															 */
 /*                                                                    */
 /*    Translate a simple DOS name without the path                    */
 /*--------------------------------------------------------------------*/
 
 static void ImportName( char *local,
-                        const char *canon,
-                        size_t charsetsize,
-                        const KWBoolean longname )
+								const char *canon,
+								size_t charsetsize,
+								const KWBoolean longname )
 {
 
-   char *in = (char *) canon;
-   char *out = local;
-   size_t len = strlen( canon );
-   size_t column;
-   char *best_period = NULL;     /* Assume no prince charming         */
-
-   if ( strchr(canon,'/') != NULL )
-   {
-      printmsg(0,"ImportName: Parameter error, not simple name: %s",
-            canon);
-      panic();
-   }
-
-   if ( len == 0 )
-   {
-      printmsg(0,"ImportName: Parameter error, zero length input");
-      panic();
-   }
-
-/*--------------------------------------------------------------------*/
-/*                 If a valid DOS name, use it as-is                  */
-/*--------------------------------------------------------------------*/
-
-   if (ValidDOSName( canon, longname ))
-   {
-      strcpy( local, canon );
-      return;
-   }
+	char *in = (char *) canon;
+	char *out = local;
+	size_t len = strlen( canon );
+	size_t column;
+	char *best_period = NULL;		/* Assume no prince charming			 */
+
+	if ( strchr(canon,'/') != NULL )
+	{
+		printmsg(0,"ImportName: Parameter error, not simple name: %s",
+				canon);
+		panic();
+	}
+
+	if ( len == 0 )
+	{
+		printmsg(0,"ImportName: Parameter error, zero length input");
+		panic();
+	}
+
+/*--------------------------------------------------------------------*/
+/*                 If a valid DOS name, use it as-is						 */
+/*--------------------------------------------------------------------*/
+
+	if (ValidDOSName( canon, longname ))
+	{
+		strcpy( local, canon );
+		return;
+	}
 
 /*--------------------------------------------------------------------*/
-/*    If the dataset name has a period, use it.  The rule we          */
-/*    follow is use the last period in the second through ninth       */
+/*    If the dataset name has a period, use it.  The rule we			 */
+/*    follow is use the last period in the second through ninth		 */
 /*    characters, otherwise use the last period in the dataset        */
-/*    name with the exception of leading period.                      */
+/*    name with the exception of leading period.							 */
 /*                                                                    */
 /*    In any case, we only copy up to eight characters for the        */
-/*    dataset name and up to three characters for the extension.      */
+/*    dataset name and up to three characters for the extension.		 */
 /*--------------------------------------------------------------------*/
 
-   for ( column = 1; (column < 9) && (in[column] != '\0') ; column++)
-   {
-      if ( in[column] == '.')
-      {
-         strncpy( out, in, column + 5 );
-                                    /* Period, 3 char extension,
-                                       and terminating \0             */
-         best_period = &out[column];/* Remember output location of
-                                       period in name                 */
-
-         if ( len > (column + 4) )  /* Need to trunc extension to 3?  */
-            strcpy( out + column + 1, in + len - 3 ); /* Yes          */
-
-         break;
-      } /*if */
-   }  /* if */
+	for ( column = 1; (column < 9) && (in[column] != '\0') ; column++)
+	{
+		if ( in[column] == '.')
+		{
+			strncpy( out, in, column + 5 );
+												/* Period, 3 char extension,
+													and terminating \0				 */
+			best_period = &out[column];/* Remember output location of
+													period in name                 */
+
+			if ( len > (column + 4) )	/* Need to trunc extension to 3?  */
+				strcpy( out + column + 1, in + len - 3 ); /* Yes			 */
+
+			break;
+		} /*if */
+	}	/* if */
 
 /*--------------------------------------------------------------------*/
 /*    No period in the first eight characters, search the rest of     */
 /*    the name for the last period (unless period is very last        */
-/*    character in the string).                                       */
+/*    character in the string).													 */
 /*--------------------------------------------------------------------*/
 
-   if ( best_period == NULL )
-   {
+	if ( best_period == NULL )
+	{
 
-      strncpy( out , in , 8);
-      best_period = strrchr( in+1 , '.');
+		strncpy( out , in , 8);
+		best_period = strrchr( in+1 , '.');
 
-      if ( (best_period != NULL) && (best_period[1] != '\0') )
-      {
-         strncpy( &out[8], best_period, 4 ); /* Plus period and 3
-                                                in extension          */
+		if ( (best_period != NULL) && (best_period[1] != '\0') )
+		{
+			strncpy( &out[8], best_period, 4 ); /* Plus period and 3
+																in extension			 */
 
-         if ( strlen( best_period) > 4 )     /* Long Extension?       */
-            out[12] = '\0';                  /* Yes --> Truncate      */
+			if ( strlen( best_period) > 4 )		/* Long Extension?		 */
+				out[12] = '\0';						/* Yes --> Truncate		 */
 
-      } /* if */
-      else {                  /* No periods at all, generate one
-                                 if needed for long name          */
+		} /* if */
+		else {						/* No periods at all, generate one
+											if needed for long name          */
 
-         if ( len > 8 )
-         {
-            out[8] = '.';
-            strcpy(&out[9], in + max(8,(len - 3))  );
-         } /* if ( len > 9 ) */
+			if ( len > 8 )
+			{
+				out[8] = '.';
+				strcpy(&out[9], in + max(8,(len - 3))	);
+			} /* if ( len > 9 ) */
 
-      } /* else */
+		} /* else */
 
-      best_period = &out[8];              /* Remember location of
-                                             period, okay if past
-                                             end of string            */
+		best_period = &out[8];					/* Remember location of
+															period, okay if past
+															end of string				 */
 
-   } /* if ( best_period == NULL ) */
+	} /* if ( best_period == NULL ) */
 
 /*--------------------------------------------------------------------*/
-/*                Now, clean up any invalid characters                */
+/*                Now, clean up any invalid characters					 */
 /*--------------------------------------------------------------------*/
 
-   if ( out[ strlen( out ) - 1 ] == '.' ) /* Trailing period?         */
-      out[ strlen( out ) - 1 ] = '\0';    /* Just truncate string     */
+	if ( out[ strlen( out ) - 1 ] == '.' ) /* Trailing period?			 */
+		out[ strlen( out ) - 1 ] = '\0';    /* Just truncate string     */
 
-   while( *out != '\0')
-   {
-      int c ;
-      if ( isupper( *out ))
-         c = tolower( *out );
-      else
-         c = *out;
+	while( *out != '\0')
+	{
+		int c ;
+		if ( isupper( *out ))
+			c = tolower( *out );
+		else
+			c = *out;
 
-      if ((out != best_period) && (strchr( E_charset, c ) == NULL ))
-      {
-         if ( c > 'z' )
-            c -= 62;
-         else if ( c > 'Z' )
-            c -= 36;
-         else if ( c > '9' )
-            c -= 10;
-         *out = E_charset[ (c - UNIX_START_C) % charsetsize ];
-      }
+		if ((out != best_period) && (strchr( E_charset, c ) == NULL ))
+		{
+			if ( c > 'z' )
+				c -= 62;
+			else if ( c > 'Z' )
+				c -= 36;
+			else if ( c > '9' )
+				c -= 10;
+			*out = E_charset[ (c - UNIX_START_C) % charsetsize ];
+		}
 
-      out++;                    /* Step to next character         */
-   } /* while( *out != '\0') */
+		out++;						  /* Step to next character			*/
+	} /* while( *out != '\0') */
 
 /*--------------------------------------------------------------------*/
 /*                   Report our results and return                    */
 /*--------------------------------------------------------------------*/
 
-   printmsg( 5,
-            "ImportName: Mapped %s to %s", canon, local );
+	printmsg( 5,
+				"ImportName: Mapped %s to %s", canon, local );
 
 } /* ImportName */
 
 /*--------------------------------------------------------------------*/
 /*    V a l i d D O S N a m e                                         */
 /*                                                                    */
-/*    Validate an MS-DOS file name                                    */
+/*    Validate an MS-DOS file name												 */
 /*--------------------------------------------------------------------*/
 
 KWBoolean ValidDOSName( const char *s,
-                      const KWBoolean longname )
+							 const KWBoolean longname )
 {
-   char *ptr;
-   size_t len = strlen ( s );
-   char tempname[FILENAME_MAX];
+	char *ptr;
+	size_t len = strlen ( s );
+	char tempname[FILENAME_MAX];
 
-   static char *longCharSet = NULL;
+	static char *longCharSet = NULL;
 
 /*--------------------------------------------------------------------*/
-/*                      Define our character set                      */
+/*                      Define our character set							 */
 /*--------------------------------------------------------------------*/
 
-   if ( E_charset == NULL )
-      E_charset = DOSCHARS;
+	if ( E_charset == NULL )
+		E_charset = DOSCHARS;
 
-   if ( longname )
-   {
+	if ( longname )
+	{
 
 #if defined(FAMILYAPI) || defined(__OS2__)
 
 /*--------------------------------------------------------------------*/
-/*       Ask OS/2 if the file name is okay.  Because the invoked      */
+/*       Ask OS/2 if the file name is okay.	Because the invoked		 */
 /*       function accepts wildcards, we pre-test for them and reject  */
-/*       them as needed.                                              */
+/*       them as needed.															 */
 /*--------------------------------------------------------------------*/
 
-      if ((strchr( s, '*') == NULL ) && (strchr( s, '?') == NULL))
-      {
+		if ((strchr( s, '*') == NULL ) && (strchr( s, '?') == NULL))
+		{
 
 #ifdef __OS2__
-         APIRET result = DosQPathInfo( (PSZ) s,
-                                       FIL_QUERYFULLNAME,
-                                       (PVOID) tempname,
-                                       sizeof tempname );
+			APIRET result = DosQueryPathInfo( (PSZ) s,
+													FIL_QUERYFULLNAME,
+													(PVOID) tempname,
+													sizeof(tempname) );
+#ifdef DEBUG
+			printmsg(15, "After DosQueryPathInfo()");
+			printmsg(15, "result=%lu", result);
+			printmsg(15, "tempname: %s", tempname);
+			fflush(stderr);
+#endif
 #else
-         USHORT result = DosQPathInfo( (PSZ) s,
-                                       FIL_NAMEISVALID,
-                                       (PBYTE) tempname,
-                                       sizeof tempname,
-                                       0 );
+			USHORT result = DosQPathInfo( (PSZ) s,
+													FIL_NAMEISVALID,
+													(PBYTE) tempname,
+													sizeof tempname,
+													0 );
 
 #endif
-         if ( result == 0 )
-            return KWTrue;
-
-         printmsg(2,
-                  "ValidDOSName: Invalid name %s, syntax error code %d",
-                   s,
-                   (int) result);
+			if ( result == 0 )
+			{
+#ifdef DEBUG
+				printmsg(10, "Returning KWTrue");
+				fflush(stderr);
+#endif
+				return KWTrue;
+			}
+#ifdef DEBUG
+			else
+			{
+				printmsg(10, "result non-zero, so not returning");
+				fflush(stderr);
+			}
+#endif
+			printmsg(2,
+						"ValidDOSName: Invalid name %s, syntax error code %d",
+						 s,
+						 (int) result);
 
-      } /* if */
+		} /* if */
 
 #endif
 
-      if ( longCharSet == NULL )
-      {
-         *tempname = '.';
-         longCharSet = newstr(strcpy( tempname + 1, E_charset ));
-      }
+		if ( longCharSet == NULL )
+		{
+			*tempname = '.';
+			longCharSet = newstr(strcpy( tempname + 1, E_charset ));
+		}
+
+		if (strspn(s, longCharSet) == len)
+		{
+			printmsg(9,"ValidDOSName: \"%s\" is valid long name", s);
+			return KWTrue;
+		}
 
-      if (strspn(s, longCharSet) == len)
-      {
-         printmsg(9,"ValidDOSName: \"%s\" is valid long name", s);
-         return KWTrue;
-      }
-
-   } /* if ( longname ) */
+	} /* if ( longname ) */
 
 /*--------------------------------------------------------------------*/
 /*                 Name must be 12 characters or less                 */
 /*--------------------------------------------------------------------*/
 
-   if (len > 12)
-      return KWFalse;
+	if (len > 12)
+		return KWFalse;
 
-   strcpy( tempname, s);      /* Make a temp copy we can alter        */
+	strcpy( tempname, s);		/* Make a temp copy we can alter        */
 
 /*--------------------------------------------------------------------*/
 /*    Simple file name without extension must be eight characters     */
-/*    or less                                                         */
+/*    or less																			 */
 /*--------------------------------------------------------------------*/
 
-   ptr = strrchr(tempname, '.');
-   if (ptr == NULL)
-   {
-      if (len > 8)
-         return KWFalse;
-   }
+	ptr = strrchr(tempname, '.');
+	if (ptr == NULL)
+	{
+		if (len > 8)
+			return KWFalse;
+	}
 
 /*--------------------------------------------------------------------*/
-/*          Period must be in second through ninth character          */
+/*          Period must be in second through ninth character			 */
 /*--------------------------------------------------------------------*/
 
-   else {
-      if ((ptr == tempname) || (ptr > &tempname[8]))
-         return KWFalse;
+	else {
+		if ((ptr == tempname) || (ptr > &tempname[8]))
+			return KWFalse;
 
 /*--------------------------------------------------------------------*/
-/*             Extension must be three characters or less             */
+/*             Extension must be three characters or less				 */
 /*--------------------------------------------------------------------*/
 
-      if ( strlen( ptr ) > 4) /* Three characters plus the period?    */
-         return KWFalse;       /* No --> Too much                      */
+		if ( strlen( ptr ) > 4) /* Three characters plus the period?	 */
+			return KWFalse;		 /* No --> Too much							  */
 
 /*--------------------------------------------------------------------*/
-/*                          Only one period                           */
+/*                          Only one period									 */
 /*--------------------------------------------------------------------*/
 
-      if (ptr != strchr(tempname, '.'))
-         return KWFalse;
-   } /* else */
+		if (ptr != strchr(tempname, '.'))
+			return KWFalse;
+	} /* else */
 
 /*--------------------------------------------------------------------*/
-/*                Must only be valid MS-DOS characters                */
+/*                Must only be valid MS-DOS characters					 */
 /*--------------------------------------------------------------------*/
 
-   strlwr( tempname );        /* Map into our desired character set   */
-   if ( ptr != NULL )
-      *ptr = 'x';             /* We've already accounted for the
-                                 period, don't let it ruin our day    */
+	strlwr( tempname );			/* Map into our desired character set	 */
+	if ( ptr != NULL )
+		*ptr = 'x';             /* We've already accounted for the
+											period, don't let it ruin our day	 */
 
-   if (strspn(tempname, E_charset ) == len)
-   {
+	if (strspn(tempname, E_charset ) == len)
+	{
+#ifdef UDEBUG2
+		printmsg(9,"ValidDOSName: \"%s\" is valid", s);
+#endif
+		return KWTrue;
+	}
+	else
+	{
 #ifdef UDEBUG2
-      printmsg(9,"ValidDOSName: \"%s\" is valid", s);
+		printmsg(9,"ValidDOSName: \"%s\" is not valid", s);
 #endif
-      return KWTrue;
-   }
-   else
-      return KWFalse;
+		return KWFalse;
+	}
 
 } /* ValidateDOSName */
 
@@ -803,7 +891,7 @@
 /*--------------------------------------------------------------------*/
 /*    I s F i l e N a m e V a l i d                                   */
 /*                                                                    */
-/*    Determine if file system supports non-8.3 format names          */
+/*    Determine if file system supports non-8.3 format names			 */
 /*--------------------------------------------------------------------*/
 
 static int IsFileNameValid(char *name)
@@ -818,44 +906,44 @@
 #endif
 
   result = DosOpen(name, &hf, &uAction, 0, 0, FILE_OPEN,
-                  OPEN_ACCESS_READONLY | OPEN_SHARE_DENYNONE, 0);
+						OPEN_ACCESS_READONLY | OPEN_SHARE_DENYNONE, 0);
 
   switch( result )
   {
-     case ERROR_INVALID_NAME:
-     case ERROR_FILENAME_EXCED_RANGE:
-        if ( debuglevel > 1 )
-            printOS2error( name, result );
-        return KWFalse;
-
-     case NO_ERROR:                 /* Hmmm, why does the file exist? */
-        DosClose(hf);
-        return KWTrue;               /* But worked, so we have answer */
-
-     default:
-        if ( debuglevel > 1 )
-            printOS2error( name, result );
-        return KWTrue;
+	  case ERROR_INVALID_NAME:
+	  case ERROR_FILENAME_EXCED_RANGE:
+		  if ( debuglevel > 1 )
+				printOS2error( name, result );
+		  return KWFalse;
+
+	  case NO_ERROR:						/* Hmmm, why does the file exist? */
+		  DosClose(hf);
+		  return KWTrue;					 /* But worked, so we have answer */
+
+	  default:
+		  if ( debuglevel > 1 )
+				printOS2error( name, result );
+		  return KWTrue;
 
   } /* switch */
 
 } /* IsFileNameValid */
 
 /*--------------------------------------------------------------------*/
-/*       a d v a n c e d F S                       (OS/2 version)     */
+/*       a d v a n c e d F S								(OS/2 version)     */
 /*                                                                    */
 /*       Determine if a file system is advanced (supports better than */
-/*       8.3 file names)                                              */
+/*       8.3 file names)															 */
 /*--------------------------------------------------------------------*/
 
 static KWBoolean advancedFS( const char *input )
 {
-   static char UUFAR cache[256] = "";  /* Initialize cache to zeroes  */
+	static char UUFAR cache[256] = "";	/* Initialize cache to zeroes  */
 
-   char fdrive[_MAX_DRIVE],
-        fpath[_MAX_DIR],
-        fname[_MAX_FNAME],
-        fdummy[_MAX_PATH];
+	char fdrive[_MAX_DRIVE],
+		  fpath[_MAX_DIR],
+		  fname[_MAX_FNAME],
+		  fdummy[_MAX_PATH];
 
   _splitpath((char *) input, fdrive, fpath, fdummy, fdummy);
 
@@ -863,131 +951,134 @@
 /*       Determine if our cache holds the answer for the drive        */
 /*--------------------------------------------------------------------*/
 
-   switch( cache[ (unsigned char) *fdrive ] )
-   {
-      case 'L':
-      case 'S':
-         break;                        /* Cached answer, report it   */
-
-      default:                         /* No cache, determine answer */
-         strcpy(fname, fdrive);
-         strcat(fname, fpath);
-         strcat(fname, ".DUMB.TEST.NAME");
-
-         cache[ (unsigned char) *fdrive ] =
-                     (char) (IsFileNameValid(fname) ? 'L' : 'S');
-
-         printmsg(4, "advancedFS: %s resides on file system supporting %s",
-                     input,
-                     (char *) (cache[ (unsigned char) *fdrive ] == 'S' ?
-                               "only 8.3 names" :
-                               "long file names" ) );
-         break;
-   }
-
-/*--------------------------------------------------------------------*/
-/*          Report our now cached results back to the caller          */
-/*--------------------------------------------------------------------*/
-
-   if (cache[ (unsigned char) *fdrive ] == 'L')
-      return KWTrue;
-   else
-      return KWFalse;
+	switch( cache[ (unsigned char) *fdrive ] )
+	{
+		case 'L':
+		case 'S':
+			break;								/* Cached answer, report it	*/
+
+		default:                         /* No cache, determine answer */
+			strcpy(fname, fdrive);
+			strcat(fname, fpath);
+			strcat(fname, ".DUMB.TEST.NAME");
+
+			cache[ (unsigned char) *fdrive ] =
+							(char) (IsFileNameValid(fname) ? 'L' : 'S');
+
+			printmsg(4, "advancedFS: %s resides on file system supporting %s",
+							input,
+							(char *) (cache[ (unsigned char) *fdrive ] == 'S' ?
+										 "only 8.3 names" :
+										 "long file names" ) );
+#ifdef DEBUG
+			fflush(stderr);
+#endif
+			break;
+	}
+
+/*--------------------------------------------------------------------*/
+/*          Report our now cached results back to the caller			 */
+/*--------------------------------------------------------------------*/
+
+	if (cache[ (unsigned char) *fdrive ] == 'L')
+		return KWTrue;
+	else
+		return KWFalse;
 
 } /* advancedFS */
 
 #elif WIN32
 
 /*--------------------------------------------------------------------*/
-/*       a d v a n c e d F S                    (Window NT version)   */
+/*       a d v a n c e d F S							(Window NT version)	 */
 /*                                                                    */
 /*       Determine if a file system is advanced (supports better than */
-/*       8.3 file names)                                              */
+/*       8.3 file names)															 */
 /*--------------------------------------------------------------------*/
 
 static KWBoolean advancedFS( const char *path )
 {
-   char driveInfo[128];
-   char fsType[128];
-   BOOL result;
-   char *shareNameEnd;
-   int len;
-
-   if ( !path || *path == '\0' ) {       /* use CWD                   */
-      strncpy( driveInfo, E_cwd, 3);
-      driveInfo[3] = '\0';
-   }
-   else if ( isalpha( *path ) && (path[1] == ':') )
-   {                                   /* It's a local drive          */
-
-      printmsg(5, "advancedFS: it's a drive letter");
-      strncpy( driveInfo, path, 3 );
-      driveInfo[3] = '\0';          /* Terminate drive string data    */
-
-   }
-   else /* It's a shared drive... parse out the share name and ask */
-   {
-      if (strncmp(path, "//", 2) != 0) /* Just double-checking */
-         return KWFalse;  /* Don't know what it is, don't want to know */
-
-      shareNameEnd = strchr(path + 2, '/');
-      if (!shareNameEnd)  /* Probably bad:  server name only */
-         return KWFalse;
-
-      shareNameEnd = strchr(shareNameEnd + 1, '/');
-      if (shareNameEnd)
-      {
-         /* Copy the server and share name, including the trailing slash */
-         len = shareNameEnd - path + 1;
-         memcpy(driveInfo, path, len);
-         driveInfo[len] = '\0';
-         shareNameEnd = driveInfo;
+	char driveInfo[128];
+	char fsType[128];
+	BOOL result;
+	char *shareNameEnd;
+	int len;
+
+	if ( !path || *path == '\0' ) {		  /* use CWD						 */
+		strncpy( driveInfo, E_cwd, 3);
+		driveInfo[3] = '\0';
+	}
+	else if ( isalpha( *path ) && (path[1] == ':') )
+	{												/* It's a local drive			 */
+
+		printmsg(5, "advancedFS: it's a drive letter");
+		strncpy( driveInfo, path, 3 );
+		driveInfo[3] = '\0';          /* Terminate drive string data	 */
+
+	}
+	else /* It's a shared drive... parse out the share name and ask */
+	{
+		if (strncmp(path, "//", 2) != 0) /* Just double-checking */
+			return KWFalse;  /* Don't know what it is, don't want to know */
+
+		shareNameEnd = strchr(path + 2, '/');
+		if (!shareNameEnd)  /* Probably bad:  server name only */
+			return KWFalse;
+
+		shareNameEnd = strchr(shareNameEnd + 1, '/');
+		if (shareNameEnd)
+		{
+			/* Copy the server and share name, including the trailing slash */
+			len = shareNameEnd - path + 1;
+			memcpy(driveInfo, path, len);
+			driveInfo[len] = '\0';
+			shareNameEnd = driveInfo;
 
 /*--------------------------------------------------------------------*/
-/* On network drives, the GetVolumeInformation call fails unless      */
+/* On network drives, the GetVolumeInformation call fails unless		 */
 /* we use back slashes.                                               */
 /*--------------------------------------------------------------------*/
 
-         while (*shareNameEnd != '\0')
-         {
-            if (*shareNameEnd == '/')
-               *shareNameEnd = '\\';
-            shareNameEnd++;
-         }
-      } else
-         return KWFalse;
-   }
-
-/*--------------------------------------------------------------------*/
-/*            We've got the drive letter, query its status            */
-/*--------------------------------------------------------------------*/
-
-   result = GetVolumeInformation(driveInfo, NULL, 0, NULL, NULL,
-         NULL, fsType, sizeof fsType);
-
-   if ( !result )
-   {
-      DWORD dwError = GetLastError();
-      printmsg(0, "advancedFS: Unable to query file system for %s", driveInfo);
-      printNTerror("GetVolumeInformation", dwError);
-      panic();
-   }
-
-   printmsg(4,"advancedFS: File system for \"%s\" has name \"%s\"",
-               driveInfo,
-               fsType );
+			while (*shareNameEnd != '\0')
+			{
+				if (*shareNameEnd == '/')
+					*shareNameEnd = '\\';
+				shareNameEnd++;
+			}
+		} else
+			return KWFalse;
+	}
+
+/*--------------------------------------------------------------------*/
+/*            We've got the drive letter, query its status				 */
+/*--------------------------------------------------------------------*/
+
+	result = GetVolumeInformation(driveInfo, NULL, 0, NULL, NULL,
+			NULL, fsType, sizeof fsType);
+
+	if ( !result )
+	{
+		DWORD dwError = GetLastError();
+		printmsg(0, "advancedFS: Unable to query file system for %s", driveInfo);
+		printNTerror("GetVolumeInformation", dwError);
+		panic();
+	}
+
+	printmsg(4,"advancedFS: File system for \"%s\" has name \"%s\"",
+					driveInfo,
+					fsType );
 
-   return strcmp( fsType, "FAT");
+	return strcmp( fsType, "FAT");
 
 } /* advancedFS for WIN32 */
 
 #else
 
 /*--------------------------------------------------------------------*/
-/*       a d v a n c e d F S                          (DOS version)   */
+/*       a d v a n c e d F S									(DOS version)	 */
 /*                                                                    */
 /*       Determine if a file system is advanced (supports better than */
-/*       8.3 file names)                                              */
+/*       8.3 file names)															 */
 /*--------------------------------------------------------------------*/
 
 #ifdef __TURBOC__
@@ -998,7 +1089,7 @@
 
 static KWBoolean advancedFS( const char *path )
 {
-   return KWFalse;                /* DOS is always dumb on file systems! */
+	return KWFalse;					 /* DOS is always dumb on file systems! */
 } /* advancedFS for MS-DOS */
 
 #if _MSC_VER >= 700
--- e:\uupc1.12s\source\lib\MKDIR.C	Sun Mar 30 23:04:46 1997
+++ MKDIR.C	Fri Jul 25 22:37:08 1997
@@ -1,21 +1,21 @@
 /*--------------------------------------------------------------------*/
-/*    m k d i r . c                                                   */
+/*    m k d i r . c																	 */
 /*                                                                    */
-/*    Support routines for UUPC/extended                              */
+/*    Support routines for UUPC/extended										 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*    Changes Copyright (c) 1989 by Andrew H. Derbyshire.             */
+/*    Changes Copyright (c) 1989 by Andrew H. Derbyshire.				 */
 /*                                                                    */
-/*    Changes Copyright (c) 1989-1997 by Kendra Electronic            */
-/*    Wonderworks.                                                    */
+/*    Changes Copyright (c) 1989-1997 by Kendra Electronic				 */
+/*    Wonderworks.																	 */
 /*                                                                    */
-/*    All rights reserved except those explicitly granted by the      */
+/*    All rights reserved except those explicitly granted by the		 */
 /*    UUPC/extended license agreement.                                */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                          RCS Information                           */
+/*                          RCS Information									 */
 /*--------------------------------------------------------------------*/
 
 /*
@@ -23,88 +23,100 @@
  *
  *    Revision history:
  *    $Log: mkdir.c $
- *    Revision 1.14  1997/03/31 07:04:53  ahd
+ *    Revision 1.14	1997/03/31 07:04:53	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.13  1996/01/01 20:53:43  ahd
+ *    Revision 1.13	1996/01/01 20:53:43	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.12  1994/12/22 00:09:24  ahd
+ *    Revision 1.12	1994/12/22 00:09:24	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.11  1994/02/20 19:07:38  ahd
+ *    Revision 1.11	1994/02/20 19:07:38	ahd
  *    IBM C/Set 2 Conversion, memory leak cleanup
  *
  *     Revision 1.10  1994/02/19  04:43:39  ahd
  *     Use standard first header
  *
- *     Revision 1.9  1994/02/19  03:53:30  ahd
+ *     Revision 1.9	1994/02/19	03:53:30  ahd
  *     Use standard first header
  *
- *     Revision 1.9  1994/02/19  03:53:30  ahd
+ *     Revision 1.9	1994/02/19	03:53:30  ahd
  *     Use standard first header
  *
- *     Revision 1.8  1994/02/18  23:11:20  ahd
+ *     Revision 1.8	1994/02/18	23:11:20  ahd
  *     Use standard first header
  *
- *     Revision 1.7  1994/01/24  03:08:38  ahd
+ *     Revision 1.7	1994/01/24	03:08:38  ahd
  *     Annual Copyright Update
  *
- *     Revision 1.6  1994/01/01  19:03:02  ahd
+ *     Revision 1.6	1994/01/01	19:03:02  ahd
  *     Annual Copyright Update
  *
- *     Revision 1.5  1993/12/23  03:11:17  rommel
+ *     Revision 1.5	1993/12/23	03:11:17  rommel
  *     OS/2 32 bit support for additional compilers
  *
- *     Revision 1.4  1993/04/11  00:31:31  dmwatt
+ *     Revision 1.4	1993/04/11	00:31:31  dmwatt
  *     Global edits for year, TEXT, etc.
  *
- *     Revision 1.3  1993/03/24  01:57:30  ahd
+ *     Revision 1.3	1993/03/24	01:57:30  ahd
  *     Delete unneeded currentfile()
  *
  */
 
 #include "uupcmoah.h"
 
+#ifdef __GCC__
+#include <stdio.h>
+#else
 #include <direct.h>
+#endif
 
 /*--------------------------------------------------------------------*/
-/*                    UUPC/extended include files                     */
+/*                    UUPC/extended include files							 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*    M K D I R                                                       */
+/*    M K D I R																		 */
 /*                                                                    */
 /*    Like mkdir() but create intermediate directories as well        */
 /*--------------------------------------------------------------------*/
 
 int MKDIR(const char *inpath)
 {
-   char *cp;
-   char *path;
+	char *cp;
+	char *path;
 
-   if (*inpath == '\0')
-      return 0;
+	if (*inpath == '\0')
+		return 0;
 
-   cp = path = normalize(inpath );
+	cp = path = normalize(inpath );
 
 /*--------------------------------------------------------------------*/
-/*        See if we need to make any intermediate directories         */
+/*        See if we need to make any intermediate directories			 */
 /*--------------------------------------------------------------------*/
 
-   cp = path ;
-   while ((cp = strchr(cp, '/')) != nil(char)) {
-      *cp = '\0';
+	cp = path ;
+	while ((cp = strchr(cp, '/')) != nil(char)) {
+		*cp = '\0';
 
-      mkdir(path);
-      *cp = '/';
-      cp++;
-   }
+#ifdef __GCC__
+		mkdir(path, 0);
+#else
+		mkdir(path);
+#endif
+		*cp = '/';
+		cp++;
+	}
 
 /*--------------------------------------------------------------------*/
-/*                           Make last dir                            */
+/*                           Make last dir									 */
 /*--------------------------------------------------------------------*/
 
-   return mkdir((char *) inpath);
+#ifdef __GCC__
+	return mkdir((char *)inpath, 0);
+#else
+	return mkdir((char *) inpath);
+#endif
 
 } /*MKDIR*/
--- e:\uupc1.12s\source\lib\NORMALIZ.C	Sun Mar 30 23:05:12 1997
+++ NORMALIZ.C	Fri Jul 25 22:24:48 1997
@@ -1,19 +1,19 @@
 /*--------------------------------------------------------------------*/
-/*    n o r m a l i z . c                                             */
+/*    n o r m a l i z . c															 */
 /*                                                                    */
-/*    Normalize a path for UUPC/extended                              */
+/*    Normalize a path for UUPC/extended										 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*       Changes Copyright (c) 1989-1997 by Kendra Electronic         */
-/*       Wonderworks.                                                 */
+/*       Changes Copyright (c) 1989-1997 by Kendra Electronic			 */
+/*       Wonderworks.																 */
 /*                                                                    */
-/*       All rights reserved except those explicitly granted by       */
-/*       the UUPC/extended license agreement.                         */
+/*       All rights reserved except those explicitly granted by		 */
+/*       the UUPC/extended license agreement.								 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                          RCS Information                           */
+/*                          RCS Information									 */
 /*--------------------------------------------------------------------*/
 
 /*
@@ -21,22 +21,22 @@
  *
  *    Revision history:
  *    $Log: normaliz.c $
- *    Revision 1.18  1997/03/31 07:05:20  ahd
+ *    Revision 1.18	1997/03/31 07:05:20	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.17  1996/01/01 20:54:25  ahd
+ *    Revision 1.17	1996/01/01 20:54:25	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.16  1995/02/12 23:37:04  ahd
+ *    Revision 1.16	1995/02/12 23:37:04	ahd
  *    compiler cleanup, NNS C/news support, optimize dir processing
  *
- *    Revision 1.15  1995/01/30 04:05:08  ahd
+ *    Revision 1.15	1995/01/30 04:05:08	ahd
  *    Additional compiler warning fixes, optimize path normalizing
  *
- *    Revision 1.14  1994/12/22 00:10:03  ahd
+ *    Revision 1.14	1994/12/22 00:10:03	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.13  1994/02/19 04:44:48  ahd
+ *    Revision 1.13	1994/02/19 04:44:48	ahd
  *    Use standard first header
  *
  *     Revision 1.12  1994/02/19  03:55:32  ahd
@@ -51,49 +51,53 @@
  *     Revision 1.10  1994/01/01  19:03:52  ahd
  *     Annual Copyright Update
  *
- *     Revision 1.9  1993/10/12  00:46:16  ahd
+ *     Revision 1.9	1993/10/12	00:46:16  ahd
  *     Normalize comments
  *
- *     Revision 1.8  1993/09/20  04:38:11  ahd
+ *     Revision 1.8	1993/09/20	04:38:11  ahd
  *     TCP/IP support from Dave Watt
  *     't' protocol support
  *     OS/2 2.x support
  *
- *     Revision 1.7  1993/08/08  17:39:09  ahd
+ *     Revision 1.7	1993/08/08	17:39:09  ahd
  *     Denormalize path for opening on selected networks
  *
- *     Revision 1.6  1993/07/06  10:55:20  ahd
+ *     Revision 1.6	1993/07/06	10:55:20  ahd
  *     Drop doubled path delimiters before calling _fullpath
  *     Abort, not return NULL, if _fullpath fails
  *
- *     Revision 1.5  1993/06/16  04:19:31  ahd
+ *     Revision 1.5	1993/06/16	04:19:31  ahd
  *     Copy trailing null when copying slashes
  *
- *     Revision 1.4  1993/06/16  04:03:25  ahd
+ *     Revision 1.4	1993/06/16	04:03:25  ahd
  *     drop duplicated slashes (caused by root directory support *sigh*)
  *
- *     Revision 1.3  1993/06/15  12:18:06  ahd
+ *     Revision 1.3	1993/06/15	12:18:06  ahd
  *     Display last known directory name for debugging
  *
- *     Revision 1.2  1993/04/11  00:32:05  ahd
+ *     Revision 1.2	1993/04/11	00:32:05  ahd
  *     Global edits for year, TEXT, etc.
  *
- * Revision 1.1  1992/11/22  21:06:14  ahd
+ * Revision 1.1  1992/11/22  21:06:14	ahd
  * Initial revision
  *
  */
 
 /*--------------------------------------------------------------------*/
-/*                        System include files                        */
+/*                        System include files								 */
 /*--------------------------------------------------------------------*/
 
 #include "uupcmoah.h"
 
 #include <ctype.h>
+#ifdef __GCC__
+#include <stdlib.h>
+#else
 #include <direct.h>
+#endif
 
 /*--------------------------------------------------------------------*/
-/*                    UUPC/extended include files                     */
+/*                    UUPC/extended include files							 */
 /*--------------------------------------------------------------------*/
 
 currentfile();
@@ -106,110 +110,116 @@
 
 char *normalize( const char *pathx )
 {
-   static char save[FILENAME_MAX];
-   char path[FILENAME_MAX];
-   size_t column;
-   char *p;
+	static char save[FILENAME_MAX];
+	char path[FILENAME_MAX];
+	size_t column;
+	char *p;
+	int fullP;
 
-   if ( pathx == NULL )
-      panic();
+	if ( pathx == NULL )
+		panic();
 
-   if ( *pathx == '\0' )
-   {
-      printmsg(0,"Empty path passed to normalize");
-      panic();
-   }
+	if ( *pathx == '\0' )
+	{
+		printmsg(0,"Empty path passed to normalize");
+		panic();
+	}
 
 /*--------------------------------------------------------------------*/
-/*                      Normalize the seperators                      */
+/*                      Normalize the seperators							 */
 /*--------------------------------------------------------------------*/
 
-   strcpy( path, pathx );
-   denormalize( path );
+	strcpy( path, pathx );
+	denormalize( path );
 
 /*--------------------------------------------------------------------*/
-/*                    Add leading path, if needed                     */
+/*                    Add leading path, if needed							 */
 /*--------------------------------------------------------------------*/
 
-   if (  ( E_cwd != NULL ) &&
-         equaln( E_cwd, "//", 2 ) &&               /* Network CWD drive */
-       ! (isalpha( *path ) && (path[1] == ':')) && /* Not explicit drive */
-         (*path != '\\'))                          /* Not explicit path */
-   {
-      column = strlen( E_cwd );
-      memmove( path + column + 1, path, strlen(path) + 1 );
-                                          /* Make room for path       */
-      memcpy( path, E_cwd, column );      /* Insert path              */
-      path[column] = '\\';                /* Add directory sep        */
-   }
+	if (	( E_cwd != NULL ) &&
+			equaln( E_cwd, "//", 2 ) &&					/* Network CWD drive */
+		 ! (isalpha( *path ) && (path[1] == ':')) && /* Not explicit drive */
+			(*path != '\\'))									/* Not explicit path */
+	{
+		column = strlen( E_cwd );
+		memmove( path + column + 1, path, strlen(path) + 1 );
+														/* Make room for path		 */
+		memcpy( path, E_cwd, column );		/* Insert path              */
+		path[column] = '\\';                /* Add directory sep        */
+	}
 
-   p = path + 1;                 /* Allow leading double slash for    */
-                                 /* Network drives                    */
+	p = path + 1;						/* Allow leading double slash for	 */
+											/* Network drives                    */
 
-   while ((p = strstr(p,"\\\\")) != NULL)  /* Drop all double slashes */
-      memmove(p, p+1, strlen(p));          /* Includes trailing NULL  */
+	while ((p = strstr(p,"\\\\")) != NULL)  /* Drop all double slashes */
+		memmove(p, p+1, strlen(p));			 /* Includes trailing NULL  */
 
 /*--------------------------------------------------------------------*/
-/*           Drop trailing slashes, OS/2 doesn't like them            */
+/*           Drop trailing slashes, OS/2 doesn't like them				 */
 /*--------------------------------------------------------------------*/
 
-   column = strlen( path ) - 1;
+	column = strlen( path ) - 1;
 
-   if ( (column > 2) && (path[column] == '\\') )
-      path[column] = '\0';
+	if ( (column > 2) && (path[column] == '\\') )
+		path[column] = '\0';
 
 /*--------------------------------------------------------------------*/
-/*       Now actually expand the path if needed because it's not      */
+/*       Now actually expand the path if needed because it's not		 */
 /*       absolute or refers to parent directories.  We take           */
 /*       special care to insert the drive letter if needed for an     */
-/*       absolute path which does not have a drive letter and is      */
-/*       not a UNC (network) drive reference.                         */
+/*       absolute path which does not have a drive letter and is		 */
+/*       not a UNC (network) drive reference.								 */
 /*--------------------------------------------------------------------*/
 
-   if (isAbsolutePath(path) && (strstr( path, ".." ) == NULL ))
-   {
-      p = save;
+	if (isAbsolutePath(path) && (strstr( path, ".." ) == NULL ))
+	{
+		p = save;
 
-      if (( path[0] == '\\' ) && ( path[1] != '\\' ))
-      {
-         *p++ = getDrive( NULL );
-         *p++ = ':';
-      }
+		if (( path[0] == '\\' ) && ( path[1] != '\\' ))
+		{
+			*p++ = getDrive( NULL );
+			*p++ = ':';
+		}
 
-      strcpy( p, path );
+		strcpy( p, path );
 
-   } /* if (isAbsolutePath(path) && (strstr( path, ".." ) == NULL )) */
-   else {
-      p = _fullpath( save, path, sizeof save );
+	} /* if (isAbsolutePath(path) && (strstr( path, ".." ) == NULL )) */
+	else
+	{
+#ifdef __GCC__
+		fullP = _fullpath(save, path, sizeof save);
+		if (fullP < 0)
+#else
+		p = _fullpath( save, path, sizeof save );
+		if ( p == NULL )
+#endif
+		{
+			printerr( path );
+			panic();
+		}
+	}
 
-      if ( p == NULL )
-      {
-         printerr( path );
-         panic();
-      }
-   }
+	renormalize( save );             /* Revert backslashes to slashes */
 
-   renormalize( save );             /* Revert backslashes to slashes */
+	p = save;
 
-   p = save;
+	if ( equaln( p + 1, "://", 3))
+		p = p + 2;							/* Drop drive if really network	*/
 
-   if ( equaln( p + 1, "://", 3))
-      p = p + 2;                    /* Drop drive if really network  */
+	column = strlen( p ) - 1;
 
-   column = strlen( p ) - 1;
-
-   if ((column > 2) && ( p[column] == '/' )) /* Zap all but root trailing */
-       p[column] = '\0';
+	if ((column > 2) && ( p[column] == '/' )) /* Zap all but root trailing */
+		 p[column] = '\0';
 
 /*--------------------------------------------------------------------*/
-/*               Print the results and return to caller               */
+/*               Print the results and return to caller					 */
 /*--------------------------------------------------------------------*/
 
-   printmsg(5,"Normalize: cwd = %s, input = %s, output = %s",
-               (E_cwd == NULL) ? "?" : E_cwd,
-               pathx,
-               p );
+	printmsg(5,"Normalize: cwd = %s, input = %s, output = %s",
+					(E_cwd == NULL) ? "?" : E_cwd,
+					pathx,
+					p );
 
-   return p;
+	return p;
 
 } /* normalize */
--- e:\uupc1.12s\source\lib\POS2ERR.C	Sun Mar 30 23:05:22 1997
+++ POS2ERR.C	Sun Aug 17 22:12:38 1997
@@ -1,19 +1,19 @@
 /*--------------------------------------------------------------------*/
-/*       p o s 2 e r r  . c                                           */
+/*       p o s 2 e r r	. c														 */
 /*                                                                    */
 /*       Report error message from OS/2 error library                 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*       Changes Copyright (c) 1989-1997 by Kendra Electronic         */
-/*       Wonderworks.                                                 */
+/*       Changes Copyright (c) 1989-1997 by Kendra Electronic			 */
+/*       Wonderworks.																 */
 /*                                                                    */
-/*       All rights reserved except those explicitly granted by       */
-/*       the UUPC/extended license agreement.                         */
+/*       All rights reserved except those explicitly granted by		 */
+/*       the UUPC/extended license agreement.								 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                          RCS Information                           */
+/*                          RCS Information									 */
 /*--------------------------------------------------------------------*/
 
 /*
@@ -21,19 +21,19 @@
  *
  *    Revision history:
  *    $Log: pos2err.c $
- *    Revision 1.14  1997/03/31 07:05:29  ahd
+ *    Revision 1.14	1997/03/31 07:05:29	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.13  1996/01/01 20:54:55  ahd
+ *    Revision 1.13	1996/01/01 20:54:55	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.12  1995/07/21 13:23:19  ahd
+ *    Revision 1.12	1995/07/21 13:23:19	ahd
  *    Clean up OS/2 compiler warnings
  *
- *    Revision 1.11  1995/01/29 16:43:03  ahd
+ *    Revision 1.11	1995/01/29 16:43:03	ahd
  *    IBM C/Set compiler warnings
  *
- *    Revision 1.10  1995/01/07 16:13:42  ahd
+ *    Revision 1.10	1995/01/07 16:13:42	ahd
  *    Change KWBoolean to KWBoolean to avoid VC++ 2.0 conflict
  *
  *    Revision 1.9  1994/12/22 00:10:14  ahd
@@ -42,32 +42,32 @@
  *    Revision 1.8  1994/03/09 04:53:53  ahd
  *    Add missing <ctype.h> header
  *
- * Revision 1.7  1994/03/09  04:17:41  ahd
+ * Revision 1.7  1994/03/09  04:17:41	ahd
  * Suppress all control characters in OS/2 message text
  *
- * Revision 1.6  1994/02/20  19:05:02  ahd
+ * Revision 1.6  1994/02/20  19:05:02	ahd
  * IBM C/Set 2 Conversion, memory leak cleanup
  *
- * Revision 1.5  1994/01/01  19:04:03  ahd
+ * Revision 1.5  1994/01/01  19:04:03	ahd
  * Annual Copyright Update
  *
- * Revision 1.4  1993/12/23  03:11:17  rommel
+ * Revision 1.4  1993/12/23  03:11:17	rommel
  * OS/2 32 bit support for additional compilers
  *
- * Revision 1.3  1993/10/12  00:47:04  ahd
+ * Revision 1.3  1993/10/12  00:47:04	ahd
  * Normalize comments
  *
- * Revision 1.2  1993/09/30  03:06:28  ahd
+ * Revision 1.2  1993/09/30  03:06:28	ahd
  * Handle selected errors with special messages
  *
- * Revision 1.1  1993/09/24  03:43:27  ahd
+ * Revision 1.1  1993/09/24  03:43:27	ahd
  * Initial revision
  *
  *
  */
 
 /*--------------------------------------------------------------------*/
-/*                        System include files                        */
+/*                        System include files								 */
 /*--------------------------------------------------------------------*/
 
 #define INCL_DOSMISC
@@ -81,11 +81,11 @@
 #include <ctype.h>
 
 #ifndef ERROR_TIMEOUT
-#define ERROR_TIMEOUT   640     /* MSG%none */
+#define ERROR_TIMEOUT	640	  /* MSG%none */
 #endif
 
 /*--------------------------------------------------------------------*/
-/*                    UUPC/extended include files                     */
+/*                    UUPC/extended include files							 */
 /*--------------------------------------------------------------------*/
 
 #include "pos2err.h"
@@ -93,119 +93,119 @@
 currentfile();
 
 /*--------------------------------------------------------------------*/
-/*    p O S 2 e r r                                                   */
+/*    p O S 2 e r r																	 */
 /*                                                                    */
-/*    Perform a perror() with logging                                 */
+/*    Perform a perror() with logging											 */
 /*--------------------------------------------------------------------*/
 
 void pOS2Err(const size_t lineno,
-             const char *fname,
-             const char *prefix,
-             unsigned int rc)
+				 const char *fname,
+				 const char *prefix,
+				 unsigned int rc)
 {
-   char buf[BUFSIZ];
-   static KWBoolean recursion  = KWFalse;
-   size_t l;
-   static char sysMsgs[] = "oso001.msg";
+	char buf[BUFSIZ];
+	static KWBoolean recursion  = KWFalse;
+	size_t l;
+	static char sysMsgs[] = "oso001.msg";
 
-   KWBoolean redirect;
+	KWBoolean redirect;
 
 #ifdef __OS2__
-   ULONG len, xrc;
+	ULONG len, xrc;
 #else
-   USHORT len, xrc;
+	USHORT len, xrc;
 #endif
 
 /*--------------------------------------------------------------------*/
-/*       Determine if we need to echo the error an extra time to      */
-/*       the console.                                                 */
+/*       Determine if we need to echo the error an extra time to		 */
+/*       the console.																 */
 /*--------------------------------------------------------------------*/
 
-   if ((logfile != stdout) && !isatty(fileno(stdout)))
-      redirect = KWTrue;
-   else
-      redirect = KWFalse;
+	if ((logfile != stdout) && !isatty(fileno(stdout)))
+		redirect = KWTrue;
+	else
+		redirect = KWFalse;
 
 /*--------------------------------------------------------------------*/
 /*             Override the text for selected error numbers           */
 /*--------------------------------------------------------------------*/
 
-   switch( rc )
-   {
-      case ERROR_TS_WAKEUP:
-         strcpy( buf, "Interrupted System Call");
-         break;
-
-      case ERROR_GEN_FAILURE:
-         strcpy( buf, "Invalid parameter, Port IRQ conflict, or device failure");
-         break;
-
-      case ERROR_TIMEOUT:
-         strcpy( buf, "Error timeout");   /* DosWaitEventSem reports
-                                             this                    */
-         break;
-
-      default:
-         xrc = DosGetMessage( NULL,
-                              0,
-                              (PCHAR) buf,
-                              sizeof buf,
-                              rc,
-                              (PSZ) sysMsgs,
-                              &len );
-
-         if ( xrc != 0 )
-         {
-
-            if ( ! recursion )
-            {
-               recursion = KWTrue;
-               printOS2error( "DosGetMessage", xrc );
-               recursion = KWFalse;
-            } /* recursion */
-
-            sprintf(buf, "OS/2 API error %d in %s at line %d,"
-                         " cannot find message",
-                         (int) rc,
-                         fname,
-                         lineno );
-
-         } /* if ( xrc != 0 ) */
-         else {
-            size_t column = 0;
-
-            for ( column = 0; column < len; column++ )
-            {
-               if (iscntrl( buf[ column ] ))
-                  buf[column] = ' ';      /* Zap control chars    */
-            }
-
-            buf[ len ] = '\0';
-         }
-         break;
+	switch( rc )
+	{
+		case ERROR_TS_WAKEUP:
+			strcpy( buf, "Interrupted System Call");
+			break;
+
+		case ERROR_GEN_FAILURE:
+			strcpy( buf, "Invalid parameter, Port IRQ conflict, or device failure");
+			break;
+
+		case ERROR_TIMEOUT:
+			strcpy( buf, "Error timeout");	/* DosWaitEventSem reports
+															this							*/
+			break;
+
+		default:
+			xrc = DosGetMessage( NULL,
+										0,
+										(PCHAR) buf,
+										sizeof buf,
+										rc,
+										(PSZ) sysMsgs,
+										&len );
+
+			if ( xrc != 0 )
+			{
+
+				if ( ! recursion )
+				{
+					recursion = KWTrue;
+					printOS2error( "DosGetMessage", xrc );
+					recursion = KWFalse;
+				} /* recursion */
+
+				sprintf(buf, "OS/2 API error %d in %s at line %d,"
+								 " cannot find message",
+								 (int) rc,
+								 fname,
+								 lineno );
+
+			} /* if ( xrc != 0 ) */
+			else {
+				size_t column = 0;
+
+				for ( column = 0; column < len; column++ )
+				{
+					if (iscntrl( buf[ column ] ))
+						buf[column] = ' ';		/* Zap control chars    */
+				}
+
+				buf[ len ] = '\0';
+			}
+			break;
 
-   } /* switch */
+	} /* switch */
 
 /*--------------------------------------------------------------------*/
 /*    Drop extra new from error message if we have room in our        */
-/*    small buffer                                                    */
+/*    small buffer																	 */
 /*--------------------------------------------------------------------*/
 
-   l = strlen( buf );
+	l = strlen( buf );
 
-   if (( buf[l-1] == '\n') && (l < sizeof buf ))
-      buf[l-1] = '\0';          /* Drop extra newline from string     */
+	if (( buf[l-1] == '\n') && (l < sizeof buf ))
+		buf[l-1] = '\0';			  /* Drop extra newline from string     */
 
 /*--------------------------------------------------------------------*/
-/*           Display the message with option file location            */
+/*           Display the message with option file location				 */
 /*--------------------------------------------------------------------*/
 
-   printmsg(2,"OS/2 API error %d in %s at line %d ...",
-            (int) rc, fname, lineno );
+	printmsg(3,"OS/2 API error %d in %s at line %d ...",
+				(int) rc, fname, lineno );
 
-   printmsg(0,"%s: %s", prefix, buf);
+	printmsg(0,"%s: %s", prefix, buf);
 
-   if ( redirect )
-      fprintf(stdout,"%s: %s\n", prefix, buf);
+	if ( redirect )
+		fprintf(stdout,"%s: %s\n", prefix, buf);
 
 } /* pOS2Err */
--- e:\uupc1.12s\source\lib\PUSHPOP.C	Sun Mar 30 23:05:36 1997
+++ PUSHPOP.C	Fri Jul 25 21:32:20 1997
@@ -5,37 +5,37 @@
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*       Changes Copyright (c) 1989-1997 by Kendra Electronic         */
-/*       Wonderworks.                                                 */
+/*       Changes Copyright (c) 1989-1997 by Kendra Electronic			 */
+/*       Wonderworks.																 */
 /*                                                                    */
-/*       All rights reserved except those explicitly granted by       */
-/*       the UUPC/extended license agreement.                         */
+/*       All rights reserved except those explicitly granted by		 */
+/*       the UUPC/extended license agreement.								 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                          RCS Information                           */
+/*                          RCS Information									 */
 /*--------------------------------------------------------------------*/
 
 /*
  *    $Id: pushpop.c 1.19 1997/03/31 07:05:43 ahd Exp $
  *
  *    $Log: pushpop.c $
- *    Revision 1.19  1997/03/31 07:05:43  ahd
+ *    Revision 1.19	1997/03/31 07:05:43	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.18  1996/01/01 20:52:53  ahd
+ *    Revision 1.18	1996/01/01 20:52:53	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.17  1995/02/14 04:38:42  ahd
+ *    Revision 1.17	1995/02/14 04:38:42	ahd
  *    Correct problems with directory processing under NT
  *
- *    Revision 1.16  1995/02/12 23:37:04  ahd
+ *    Revision 1.16	1995/02/12 23:37:04	ahd
  *    compiler cleanup, NNS C/news support, optimize dir processing
  *
- *    Revision 1.15  1994/12/22 00:10:26  ahd
+ *    Revision 1.15	1994/12/22 00:10:26	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.14  1994/03/15 03:02:26  ahd
+ *    Revision 1.14	1994/03/15 03:02:26	ahd
  *    Correct spelling error
  *
  *     Revision 1.13  1994/02/20  19:07:38  ahd
@@ -53,39 +53,43 @@
  *     Revision 1.10  1994/02/18  23:13:26  ahd
  *     Use standard first header
  *
- *     Revision 1.9  1994/01/01  19:04:18  ahd
+ *     Revision 1.9	1994/01/01	19:04:18  ahd
  *     Annual Copyright Update
  *
- *     Revision 1.8  1993/12/23  03:11:17  rommel
+ *     Revision 1.8	1993/12/23	03:11:17  rommel
  *     OS/2 32 bit support for additional compilers
  *
- *     Revision 1.7  1993/11/06  17:54:55  rhg
+ *     Revision 1.7	1993/11/06	17:54:55  rhg
  *     Drive Drew nuts by submitting cosmetic changes mixed in with bug fixes
  *
- *     Revision 1.6  1993/10/24  21:45:49  rhg
+ *     Revision 1.6	1993/10/24	21:45:49  rhg
  *     Save the changed directory of the correct drive!
  *
- *     Revision 1.5  1993/06/15  12:37:16  ahd
+ *     Revision 1.5	1993/06/15	12:37:16  ahd
  *     Correct compile warning message about const assignment
  *
- *     Revision 1.4  1993/06/15  12:18:06  ahd
+ *     Revision 1.4	1993/06/15	12:18:06  ahd
  *     Save pushed directory name for debugging
  *
- *     Revision 1.3  1993/06/13  14:06:00  ahd
+ *     Revision 1.3	1993/06/13	14:06:00  ahd
  *     Insure directories PUSHED are POPPED
  *
- * Revision 1.2  1992/11/22  21:06:14  ahd
+ * Revision 1.2  1992/11/22  21:06:14	ahd
  * Use strpool for memory allocation
  *
  */
 
 /*--------------------------------------------------------------------*/
-/*                        System include files                        */
+/*                        System include files								 */
 /*--------------------------------------------------------------------*/
 
 #include "uupcmoah.h"
 
+#ifdef __GCC__
+#include <stdlib.h>
+#else
 #include <direct.h>
+#endif
 #include <ctype.h>
 
 #ifdef __TURBOC__
@@ -93,7 +97,7 @@
 #endif
 
 /*--------------------------------------------------------------------*/
-/*                    UUPC/extended include files                     */
+/*                    UUPC/extended include files							 */
 /*--------------------------------------------------------------------*/
 
 #include "pushpop.h"
@@ -105,78 +109,98 @@
 /*--------------------------------------------------------------------*/
 
 static char *dirstack[MAXDEPTH];
+#ifdef __GCC__
+static char drivestack[MAXDEPTH];
+#else
 static int drivestack[MAXDEPTH];
+#endif
 static depth = 0;
 
 currentfile();
 
 /*--------------------------------------------------------------------*/
-/*       P u s h D i r                                                */
+/*       P u s h D i r																 */
 /*                                                                    */
-/*       Change to a directory and push old one on our stack          */
+/*       Change to a directory and push old one on our stack			 */
 /*--------------------------------------------------------------------*/
 
 void PushDir( const char *directory )
 {
-   char cwd[FILENAME_MAX];
+	char cwd[FILENAME_MAX];
 
-   if ( depth >= MAXDEPTH )
-      panic();
+	if ( depth >= MAXDEPTH )
+		panic();
 
 /*--------------------------------------------------------------------*/
-/*       Unlike Unix, DOS has a CWD per drive.  We must,              */
+/*       Unlike Unix, DOS has a CWD per drive.	We must,              */
 /*       therefore, change to the new drive before we save the        */
-/*       CWD.  Otherwise we will lose the old CWD for the new         */
+/*       CWD.	Otherwise we will lose the old CWD for the new			 */
 /*       drive.  For straight PushDir/PopDir pairing, we need not     */
-/*       save the CWD on the old drive because we won't be changing   */
-/*       it.  Note, however, that the sequence PushDir/CHDIR/         */
-/*       PopDir (as opposed to just PushDir/PopDir pairs) could       */
-/*       lose information if the CHDIR changes back to the drive      */
-/*       from which PushDir changed away.  If any UUPC/extended       */
-/*       code really did this, then drivestack would have to be       */
+/*       save the CWD on the old drive because we won't be changing	 */
+/*       it.  Note, however, that the sequence PushDir/CHDIR/			 */
+/*       PopDir (as opposed to just PushDir/PopDir pairs) could		 */
+/*       lose information if the CHDIR changes back to the drive		 */
+/*       from which PushDir changed away.  If any UUPC/extended		 */
+/*       code really did this, then drivestack would have to be		 */
 /*       changed to a full pathname like dirstack.  Lucky for us,     */
-/*       it doesn't do so in any known sequences.  --RHG/AHD          */
-/*--------------------------------------------------------------------*/
-
-   drivestack[depth] = getDrive( NULL ) - 'A' + 1;
-
-   if (isalpha(*directory) && (directory[1] == ':'))
-   {
-      if (_chdrive( toupper(*directory) - 'A' + 1))
-      {
-         printerr("chdrive");
-         panic();
-      }
-   }
-
+/*       it doesn't do so in any known sequences.	--RHG/AHD			 */
 /*--------------------------------------------------------------------*/
-/*       We retrieve the current directory by drive letter because    */
-/*       the IBM OS/2 C compiler 2.01 returns @ for the drive         */
-/*       letter of the 0 (current) drive.  Windows NT is even more    */
-/*       evil, because it returns information for the wrong drive.    */
-/*--------------------------------------------------------------------*/
-
-   dirstack[depth] = _getdcwd(drivestack[depth], cwd, FILENAME_MAX);
 
-   if (dirstack[depth] == NULL )
-   {
-      printerr("PushDir");
-      panic();
-   }
+#ifdef __GCC__
+	drivestack[depth] = getDrive(NULL);
+#else
+	drivestack[depth] = getDrive(NULL) - 'A' + 1;
+#endif
 
-   dirstack[depth] = newstr( cwd );
+	if (isalpha(*directory) && (directory[1] == ':'))
+	{
+#ifdef __GCC__
+		if(_chdrive(toupper(*directory)))
+#else
+		if (_chdrive( toupper(*directory) - 'A' + 1))
+#endif
+		{
+			printerr("chdrive");
+			panic();
+		}
+	}
+
+/*--------------------------------------------------------------------*/
+/*       We retrieve the current directory by drive letter because	 */
+/*       the IBM OS/2 C compiler 2.01 returns @ for the drive			 */
+/*       letter of the 0 (current) drive.  Windows NT is even more	 */
+/*       evil, because it returns information for the wrong drive.	 */
+/*--------------------------------------------------------------------*/
+
+#ifdef __GCC__
+	dirstack[depth] = getcwd(cwd, FILENAME_MAX);
+#else
+	dirstack[depth] = _getdcwd(drivestack[depth], cwd, FILENAME_MAX);
+#endif
 
-   if (equal(directory,"."))
-      E_cwd = dirstack[depth];
-   else
-      CHDIR( directory );        /* CHDIR sets E_cwd                 */
+	if (dirstack[depth] == NULL )
+	{
+		printerr("PushDir");
+		panic();
+	}
+
+	dirstack[depth] = newstr( cwd );
+
+	if (equal(directory,"."))
+		E_cwd = dirstack[depth];
+	else
+		CHDIR( directory );			/* CHDIR sets E_cwd						*/
 
 #ifdef UDEBUG
-   printmsg(5,"PushDir: pushed from %c %s (depth %d) to %s",
-               drivestack[depth] + 'A' - 1,
-               dirstack[depth],
-               depth,
-               E_cwd );
+	printmsg(5,"PushDir: pushed from %c %s (depth %d) to %s",
+#ifdef __GCC__
+					drivestack[depth],
+#else
+					drivestack[depth] + 'A' - 1,
+#endif
+					dirstack[depth],
+					depth,
+					E_cwd );
 #endif
 
   depth++;
@@ -191,34 +215,43 @@
 
 void PopDir( void )
 {
-   char cwd[FILENAME_MAX];
+	char cwd[FILENAME_MAX];
 
 #ifdef UDEBUG
-   char *oldCWD = E_cwd;
+	char *oldCWD = E_cwd;
 #endif
 
-   if ( depth-- == 0 )
-      panic();
+	if ( depth-- == 0 )
+		panic();
 
-   if (chdir( dirstack[depth] ))
-      panic();
+	if (chdir( dirstack[depth] ))
+		panic();
 
-   if ( _chdrive(drivestack[depth]) )
-   {
-      printerr("chdrive");
-      panic();
-   }
-
-   E_cwd = _getdcwd(drivestack[depth], cwd, FILENAME_MAX);
-   E_cwd = newstr( E_cwd );
+	if ( _chdrive(drivestack[depth]) )
+	{
+		printerr("chdrive");
+		panic();
+	}
+
+#ifdef __GCC__
+	E_cwd = _getcwd2(cwd, FILENAME_MAX);
+	E_cwd = newstr(cwd);
+#else
+	E_cwd = _getdcwd(drivestack[depth], cwd, FILENAME_MAX);
+	E_cwd = newstr( E_cwd );
+#endif
 
 #ifdef UDEBUG
-   printmsg(5,"PopDir: popped from %s to %c %s (depth %d) %s",
-               oldCWD,
-               drivestack[depth] + 'A' - 1,
-               dirstack[depth],
-               depth,
-               E_cwd );
+	printmsg(5,"PopDir: popped from %s to %c %s (depth %d) %s",
+					oldCWD,
+#ifdef __GCC__
+					drivestack[depth],
+#else
+					drivestack[depth] + 'A' - 1,
+#endif
+					dirstack[depth],
+					depth,
+					E_cwd );
 #endif
 
 } /* PopDir */
--- e:\uupc1.12s\source\lib\REMOVE2.C	Sun Mar 30 23:05:54 1997
+++ REMOVE2.C	Thu Aug 21 19:57:34 1997
@@ -1,19 +1,19 @@
 /*--------------------------------------------------------------------*/
 /*       r e m o v e 2 . c                                            */
 /*                                                                    */
-/*       OS/2 specific delete processing                              */
+/*       OS/2 specific delete processing										 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*       Changes Copyright (c) 1989-1997 by Kendra Electronic         */
-/*       Wonderworks.                                                 */
+/*       Changes Copyright (c) 1989-1997 by Kendra Electronic			 */
+/*       Wonderworks.																 */
 /*                                                                    */
-/*       All rights reserved except those explicitly granted by       */
-/*       the UUPC/extended license agreement.                         */
+/*       All rights reserved except those explicitly granted by		 */
+/*       the UUPC/extended license agreement.								 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                          RCS Information                           */
+/*                          RCS Information									 */
 /*--------------------------------------------------------------------*/
 
 /*
@@ -48,60 +48,67 @@
 #define INCL_ERRORS
 #include <os2.h>
 
+#ifdef __GCC__
+#define ENOTEXIST ENOENT
+#define EACCESS EACCES
+#define EOS2ERR EIO
+#endif
+
+
 /*--------------------------------------------------------------------*/
-/*       r e m o v e O S 2 F i l e                                    */
+/*       r e m o v e O S 2 F i l e												 */
 /*                                                                    */
-/*       Perform special delete processing under OS/2, if so          */
+/*       Perform special delete processing under OS/2, if so			 */
 /*       configured.                                                  */
 /*--------------------------------------------------------------------*/
 
 int removeOS2File( const char *fname, const char *file, const size_t line )
 {
 
-   APIRET rc;
+	APIRET rc;
 
 /*--------------------------------------------------------------------*/
 /*       If the user wants normal UNDELETE processing to proceed,     */
-/*       we just use the regular UNIX system call                     */
+/*       we just use the regular UNIX system call							 */
 /*--------------------------------------------------------------------*/
 
-   if ( bflag[F_UNDELETE] )
-      return unlink( fname );
+	if ( bflag[F_UNDELETE] )
+		return unlink( fname );
 
-   if ( fname == NULL )
-   {
-      errno = EINVAL;
-      return -1;
-   }
+	if ( fname == NULL )
+	{
+		errno = EINVAL;
+		return -1;
+	}
 
-   rc = DosForceDelete( (PSZ) fname );
+	rc = DosForceDelete( (PSZ) fname );
 
-   if ( rc == 0 )
-      return 0;
+	if ( rc == 0 )
+		return 0;
 
 /*--------------------------------------------------------------------*/
-/*       We had a problem.  Report the OS/2 error if unique,          */
+/*       We had a problem.  Report the OS/2 error if unique,			 */
 /*       otherwise just translate the return code and pray.           */
 /*--------------------------------------------------------------------*/
 
-   switch( rc )
-   {
-      case ERROR_FILE_NOT_FOUND:
-      case ERROR_PATH_NOT_FOUND:
-         errno = ENOTEXIST;
-         break;
-
-      case ERROR_ACCESS_DENIED:
-         errno = EACCESS;
-         break;
-
-      default:
-         pOS2Err( line, file, fname, rc);
-         errno = EOS2ERR;
-         break;
+	switch( rc )
+	{
+		case ERROR_FILE_NOT_FOUND:
+		case ERROR_PATH_NOT_FOUND:
+			errno = ENOTEXIST;
+			break;
+
+		case ERROR_ACCESS_DENIED:
+			errno = EACCESS;
+			break;
+
+		default:
+			pOS2Err( line, file, fname, rc);
+			errno = EOS2ERR;
+			break;
 
-   } /* switch */
+	} /* switch */
 
-   return (int) rc;
+	return (int) rc;
 
 } /* removeOS2File */
--- e:\uupc1.12s\source\lib\SECURITY.C	Sun Mar 30 23:06:26 1997
+++ SECURITY.C	Fri Jul 25 22:04:18 1997
@@ -1,19 +1,19 @@
 /*--------------------------------------------------------------------*/
-/*    s e c u r i t y . c                                             */
+/*    s e c u r i t y . c															 */
 /*                                                                    */
 /*    Security routines for UUPC/extended                             */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*       Changes Copyright (c) 1989-1997 by Kendra Electronic         */
-/*       Wonderworks.                                                 */
+/*       Changes Copyright (c) 1989-1997 by Kendra Electronic			 */
+/*       Wonderworks.																 */
 /*                                                                    */
-/*       All rights reserved except those explicitly granted by       */
-/*       the UUPC/extended license agreement.                         */
+/*       All rights reserved except those explicitly granted by		 */
+/*       the UUPC/extended license agreement.								 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                          RCS Information                           */
+/*                          RCS Information									 */
 /*--------------------------------------------------------------------*/
 
 /*
@@ -21,39 +21,39 @@
  *
  *    Revision history:
  *    $Log: security.c $
- *    Revision 1.30  1997/03/31 07:06:33  ahd
+ *    Revision 1.30	1997/03/31 07:06:33	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.29  1996/01/04 04:00:46  ahd
+ *    Revision 1.29	1996/01/04 04:00:46	ahd
  *    Use sorted list of boolean options with binary search and computed
  *    table size.
  *
- *    Revision 1.28  1996/01/02 02:51:53  ahd
+ *    Revision 1.28	1996/01/02 02:51:53	ahd
  *    Sort security, modem confifuration tables
  *
- *    Revision 1.27  1996/01/02 00:00:24  ahd
+ *    Revision 1.27	1996/01/02 00:00:24	ahd
  *    Break out search loop for configuration file keywords from
  *    processing of them.
  *    Use proper binary search for configuration file keywords rather
  *    than lineaer search.  Also includes pre-computing size of configuration
  *    tables.
  *
- *    Revision 1.26  1995/02/12 23:37:04  ahd
+ *    Revision 1.26	1995/02/12 23:37:04	ahd
  *    compiler cleanup, NNS C/news support, optimize dir processing
  *
- *    Revision 1.25  1995/01/29 16:43:03  ahd
+ *    Revision 1.25	1995/01/29 16:43:03	ahd
  *    IBM C/Set compiler warnings
  *
- *    Revision 1.24  1995/01/29 14:07:59  ahd
+ *    Revision 1.24	1995/01/29 14:07:59	ahd
  *    Clean up most IBM C/Set Compiler Warnings
  *
- *    Revision 1.23  1995/01/07 16:14:36  ahd
+ *    Revision 1.23	1995/01/07 16:14:36	ahd
  *    Change KWBoolean to KWBoolean to avoid VC++ 2.0 conflict
  *
- *    Revision 1.22  1994/12/22 00:11:05  ahd
+ *    Revision 1.22	1994/12/22 00:11:05	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.21  1994/02/21 16:38:58  ahd
+ *    Revision 1.21	1994/02/21 16:38:58	ahd
  *    Delete public directory debugging message
  *
  *     Revision 1.20  1994/02/20  19:07:38  ahd
@@ -92,40 +92,40 @@
  *     Revision 1.10  1993/10/12  00:46:16  ahd
  *     Normalize comments
  *
- *     Revision 1.9  1993/10/03  20:37:34  ahd
+ *     Revision 1.9	1993/10/03	20:37:34  ahd
  *     Lower case all strings loaded into directory array
  *
- *     Revision 1.8  1993/09/20  04:38:11  ahd
+ *     Revision 1.8	1993/09/20	04:38:11  ahd
  *     TCP/IP support from Dave Watt
  *     't' protocol support
  *     OS/2 2.x support
  *
- *     Revision 1.7  1993/08/03  03:11:49  ahd
+ *     Revision 1.7	1993/08/03	03:11:49  ahd
  *     Make missing directories non-fatal
  *
- *     Revision 1.6  1993/05/06  03:41:48  ahd
+ *     Revision 1.6	1993/05/06	03:41:48  ahd
  *     Use NULL to denote current directory, not "."
  *
- *     Revision 1.5  1993/04/11  00:31:04  ahd
+ *     Revision 1.5	1993/04/11	00:31:04  ahd
  *     Global edits for year, TEXT, etc.
  *
- *     Revision 1.4  1993/03/06  22:48:23  ahd
+ *     Revision 1.4	1993/03/06	22:48:23  ahd
  *     Re-do compare of sort to void bug in some qsort() functions
  *
- * Revision 1.3  1992/11/22  20:58:55  ahd
+ * Revision 1.3  1992/11/22  20:58:55	ahd
  * Normalize directories as read
  * Use strpool to allocate const strings
  *
- * Revision 1.2  1992/11/19  02:57:31  ahd
+ * Revision 1.2  1992/11/19  02:57:31	ahd
  * drop rcsid
  *
- * Revision 1.1  1992/11/16  05:00:26  ahd
+ * Revision 1.1  1992/11/16  05:00:26	ahd
  * Initial revision
  *
  */
 
 /*--------------------------------------------------------------------*/
-/*                        System include files                        */
+/*                        System include files								 */
 /*--------------------------------------------------------------------*/
 
 #include "uupcmoah.h"
@@ -133,10 +133,14 @@
 #include <ctype.h>
 
 #include <sys/stat.h>
+#ifdef __GCC__
+#include <stdlib.h>
+#else
 #include <direct.h>
+#endif
 
 /*--------------------------------------------------------------------*/
-/*                    UUPC/extended include files                     */
+/*                    UUPC/extended include files							 */
 /*--------------------------------------------------------------------*/
 
 #include "hostable.h"
@@ -145,21 +149,21 @@
 #include "expath.h"
 
 /*--------------------------------------------------------------------*/
-/*                           Local defines                            */
+/*                           Local defines									 */
 /*--------------------------------------------------------------------*/
 
 static KWBoolean InitEntry( char *buf, const char *fname);
 
 static size_t InitDir( char *directories,
-         const REMOTE_ACCESS access,
-         const KWBoolean grant,
-         struct HostSecurity *anchor,
-         size_t max_elements );
+			const REMOTE_ACCESS access,
+			const KWBoolean grant,
+			struct HostSecurity *anchor,
+			size_t max_elements );
 
 int dircmp( const void *a , const void *b );
 
 /*--------------------------------------------------------------------*/
-/*                          Global varables                           */
+/*                          Global varables									 */
 /*--------------------------------------------------------------------*/
 
 struct HostSecurity *securep = NULL;
@@ -167,137 +171,137 @@
 static char drive[] = "C:";
 
 static struct HostSecurity localSecurity = { 0, 0, 0, 0 };
-                              /* We always need it, so statically
-                                 allocate it                         */
+										/* We always need it, so statically
+											allocate it                         */
 
 currentfile();
 
 /*--------------------------------------------------------------------*/
 /*    L o a d S e c u r i t y                                         */
 /*                                                                    */
-/*    Initialize security processing; returns KWTrue if security       */
-/*    initialized, otherewise KWFalse                                  */
+/*    Initialize security processing; returns KWTrue if security		  */
+/*    initialized, otherewise KWFalse											  */
 /*--------------------------------------------------------------------*/
 
 KWBoolean LoadSecurity( void )
 {
-   char buffer[BUFSIZ*4];     /* Allows around 2K for the data        */
-   struct HostTable *hostp;
-   FILE *stream;
+	char buffer[BUFSIZ*4];		/* Allows around 2K for the data        */
+	struct HostTable *hostp;
+	FILE *stream;
 
 /*--------------------------------------------------------------------*/
-/*                    Initialize local host entry                     */
+/*                    Initialize local host entry							 */
 /*--------------------------------------------------------------------*/
 
-   hostp = checkname( E_nodename );
-   if ( hostp == NULL )
-      panic();
-   hostp->hsecure = &localSecurity;
-   hostp->hsecure->local = KWTrue;
+	hostp = checkname( E_nodename );
+	if ( hostp == NULL )
+		panic();
+	hostp->hsecure = &localSecurity;
+	hostp->hsecure->local = KWTrue;
 
 /*--------------------------------------------------------------------*/
-/*      Generate a filename for the permissions file and open it      */
+/*      Generate a filename for the permissions file and open it		 */
 /*--------------------------------------------------------------------*/
 
-   stream  = FOPEN( E_permissions, "r",TEXT_MODE);
+	stream  = FOPEN( E_permissions, "r",TEXT_MODE);
 
-   if ( stream == NULL )      /* Did the file open?                   */
-   {                          /* No --> Report failure to caller      */
-      printerr( E_permissions );
-      return KWFalse;
-   } /* ( stream == NULL ) */
+	if ( stream == NULL )		/* Did the file open?						 */
+	{									/* No --> Report failure to caller		 */
+		printerr( E_permissions );
+		return KWFalse;
+	} /* ( stream == NULL ) */
 
 /*--------------------------------------------------------------------*/
-/*              Get current drive for normalizing names               */
+/*              Get current drive for normalizing names					 */
 /*--------------------------------------------------------------------*/
 
-   *drive = getDrive( NULL );
+	*drive = getDrive( NULL );
 
 /*--------------------------------------------------------------------*/
-/*               Begin processing the PERMISSIONS file                */
+/*               Begin processing the PERMISSIONS file					 */
 /*--------------------------------------------------------------------*/
 
-   while ( !feof( stream ) )
-   {
-      char *next = buffer;
+	while ( !feof( stream ) )
+	{
+		char *next = buffer;
 
 /*--------------------------------------------------------------------*/
 /*                Build up the buffer to be processed                 */
 /*--------------------------------------------------------------------*/
 
-      *next = '\0';
-      while( fgets( next,
-                   (int) (sizeof buffer - strlen(next)),
-                   stream ) != NULL)
-      {
-         if ((*next == '#') || (*next == '\n'))
-         {
-            *next = '\0';
-            continue;
-         }
-
-         next = next + strlen( next ) - 1;
-
-         if (*next == '\n')
-            *next-- = '\0';
-         else if (!feof( stream ))  /* Did we hit EOF?                */
-         {                    /* No --> Presume the buffer overflowed*/
-            printmsg(0,"LoadSecurity: buffer overflow while reading %s",
-                       E_permissions );
-            fclose( stream );
-            return KWFalse;
-         }
-
-         while( isspace( *next ))   /* Dump trailing white space      */
-            *next-- = '\0';
-
-         if (*next == '\\')
-            *next = '\0';
-         else
-            break;
-
-      } /* while( fgets( next, sizeof available, stream )) != NULL))  */
-
-/*--------------------------------------------------------------------*/
-/*            Done read the data; verify we had no errors             */
-/*--------------------------------------------------------------------*/
-
-      if (ferror( stream ))
-      {
-         printerr( E_permissions );
-         clearerr( stream );
-         return KWFalse;
-      } /* if */
+		*next = '\0';
+		while( fgets( next,
+						 (int) (sizeof buffer - strlen(next)),
+						 stream ) != NULL)
+		{
+			if ((*next == '#') || (*next == '\n'))
+			{
+				*next = '\0';
+				continue;
+			}
+
+			next = next + strlen( next ) - 1;
+
+			if (*next == '\n')
+				*next-- = '\0';
+			else if (!feof( stream ))	/* Did we hit EOF?					 */
+			{							/* No --> Presume the buffer overflowed*/
+				printmsg(0,"LoadSecurity: buffer overflow while reading %s",
+							  E_permissions );
+				fclose( stream );
+				return KWFalse;
+			}
+
+			while( isspace( *next ))	/* Dump trailing white space		 */
+				*next-- = '\0';
+
+			if (*next == '\\')
+				*next = '\0';
+			else
+				break;
+
+		} /* while( fgets( next, sizeof available, stream )) != NULL))  */
+
+/*--------------------------------------------------------------------*/
+/*            Done read the data; verify we had no errors				 */
+/*--------------------------------------------------------------------*/
+
+		if (ferror( stream ))
+		{
+			printerr( E_permissions );
+			clearerr( stream );
+			return KWFalse;
+		} /* if */
 
 /*--------------------------------------------------------------------*/
-/*              Build entries for one permissions entry               */
+/*              Build entries for one permissions entry					 */
 /*--------------------------------------------------------------------*/
 
 #ifdef UDEBUG
-      printmsg(10,"Buffer is \"%s\"", buffer );
+		printmsg(10,"Buffer is \"%s\"", buffer );
 #endif
 
-      if ((*next != '\0') && !InitEntry( buffer , E_permissions))
-      {
-         fclose( stream );
-         return KWFalse;
-      }
+		if ((*next != '\0') && !InitEntry( buffer , E_permissions))
+		{
+			fclose( stream );
+			return KWFalse;
+		}
 
-   } /* while ( !feof( stream ) ) */
+	} /* while ( !feof( stream ) ) */
 
 /*--------------------------------------------------------------------*/
 /*                          Return to caller                          */
 /*--------------------------------------------------------------------*/
 
-   fclose( stream );
-   return KWTrue;
+	fclose( stream );
+	return KWTrue;
 
 } /* LoadSecurity */
 
 /*--------------------------------------------------------------------*/
 /*    I n i t i a l i z e E n t r y                                   */
 /*                                                                    */
-/*    Initialize a single permissions file entry                      */
+/*    Initialize a single permissions file entry							 */
 /*--------------------------------------------------------------------*/
 
 static KWBoolean InitEntry( char *buf, const char *fname)
@@ -314,543 +318,543 @@
 
   static CONFIGTABLE secureTable[] =
   {
-     { "callback",      &callback,     0, B_TOKEN  } ,
-     { "commands",      &commands,     0, B_CLIST  } ,
-     { "logname",       &logname,      0, B_TOKEN  } ,
-     { "machine",       &machine,      0, B_TOKEN  | B_MALLOC } ,
-     { "myname",        &myname,       0, B_TOKEN  } ,
-     { "noread",        &noread,       0, B_TOKEN  | B_MALLOC } ,
-     { "nowrite",       &nowrite,      0, B_TOKEN  | B_MALLOC } ,
-     { "pubdir",        &xpubdir,      0, B_TOKEN  } ,
-     { "read",          &read,         0, B_TOKEN  | B_MALLOC} ,
-     { "request",       &request,      0, B_TOKEN  } ,
-     { "sendfiles",     &sendfiles,    0, B_TOKEN  } ,
-     { "validate",      &validate,     0, B_CLIST  } ,
-     { "write",         &write,        0, B_TOKEN  | B_MALLOC }
-   }; /* secureTable */
+	  { "callback",		&callback,		0, B_TOKEN	} ,
+	  { "commands",		&commands,		0, B_CLIST	} ,
+	  { "logname",       &logname,		0, B_TOKEN	} ,
+	  { "machine",       &machine,		0, B_TOKEN	| B_MALLOC } ,
+	  { "myname",			&myname,       0, B_TOKEN	} ,
+	  { "noread",			&noread,       0, B_TOKEN	| B_MALLOC } ,
+	  { "nowrite",       &nowrite,		0, B_TOKEN	| B_MALLOC } ,
+	  { "pubdir",			&xpubdir,		0, B_TOKEN	} ,
+	  { "read",          &read,			0, B_TOKEN	| B_MALLOC} ,
+	  { "request",       &request,		0, B_TOKEN	} ,
+	  { "sendfiles",		&sendfiles,    0, B_TOKEN	} ,
+	  { "validate",		&validate,		0, B_CLIST	} ,
+	  { "write",			&write,			0, B_TOKEN	| B_MALLOC }
+	}; /* secureTable */
 
-   static size_t secureTableSize =
-                           (sizeof secureTable) / (sizeof (CONFIGTABLE));
+	static size_t secureTableSize =
+									(sizeof secureTable) / (sizeof (CONFIGTABLE));
 
-   struct HostSecurity *anchor = malloc( sizeof *anchor );
+	struct HostSecurity *anchor = malloc( sizeof *anchor );
 
 /*--------------------------------------------------------------------*/
-/*                  Default list of allowed commands                  */
+/*                  Default list of allowed commands						 */
 /*--------------------------------------------------------------------*/
 
-   static char *command_list[] = { "rmail", "rnews" , NULL } ;
+	static char *command_list[] = { "rmail", "rnews" , NULL } ;
 
 /*--------------------------------------------------------------------*/
-/*                          Other variables                           */
+/*                          Other variables									 */
 /*--------------------------------------------------------------------*/
 
-   KWBoolean success = KWTrue;
-   size_t subscript;
-   char *token = buf;
-   char *parameter;
-   struct UserTable *userp;
-   struct HostTable *hostp;
-   size_t max_elements = 16;
+	KWBoolean success = KWTrue;
+	size_t subscript;
+	char *token = buf;
+	char *parameter;
+	struct UserTable *userp;
+	struct HostTable *hostp;
+	size_t max_elements = 16;
 
 /*--------------------------------------------------------------------*/
-/*                 Initialize the security structure                  */
+/*                 Initialize the security structure						 */
 /*--------------------------------------------------------------------*/
 
-   checkref( anchor );
-   memset( anchor , '\0', sizeof *anchor); /* Clear pointers          */
+	checkref( anchor );
+	memset( anchor , '\0', sizeof *anchor); /* Clear pointers			 */
 
 /*--------------------------------------------------------------------*/
-/*                        Initialize the table                        */
+/*                        Initialize the table								 */
 /*--------------------------------------------------------------------*/
 
-   for (subscript = 0; subscript < secureTableSize; subscript++ )
-      if (secureTable[subscript].flag & (B_TOKEN | B_STRING | B_LIST| B_CLIST))
-         *((char **) secureTable[subscript].loc) = nil(char);
+	for (subscript = 0; subscript < secureTableSize; subscript++ )
+		if (secureTable[subscript].flag & (B_TOKEN | B_STRING | B_LIST| B_CLIST))
+			*((char **) secureTable[subscript].loc) = nil(char);
 
 /*--------------------------------------------------------------------*/
 /*                 Parse the information in the table                 */
 /*--------------------------------------------------------------------*/
 
-   while ( (parameter = strtok( token, WHITESPACE )) != NULL)
-   {
-      token = strtok( NULL, ""); /* Save for next pass                */
+	while ( (parameter = strtok( token, WHITESPACE )) != NULL)
+	{
+		token = strtok( NULL, ""); /* Save for next pass					 */
 
 #ifdef _DEBUG
 
-      printmsg(8,"InitEntry: Parameter is \"%s\"", parameter);
+		printmsg(8,"InitEntry: Parameter is \"%s\"", parameter);
 
-      if ( token != NULL )
-         printmsg(10,"InitEntry: Buffer remaining is \"%s\"", token);
+		if ( token != NULL )
+			printmsg(10,"InitEntry: Buffer remaining is \"%s\"", token);
 
 #endif
 
-      if (!processconfig(parameter,
-                         SYSTEM_CONFIG,
-                         0,
-                         secureTable,
-                         secureTableSize,
-                         NULL,
-                         0 ))
-      {
-         printmsg(0, "Unknown keyword \"%s\" in %s ignored",
-                    parameter,
-                    fname);
-         success = KWFalse;
+		if (!processconfig(parameter,
+								 SYSTEM_CONFIG,
+								 0,
+								 secureTable,
+								 secureTableSize,
+								 NULL,
+								 0 ))
+		{
+			printmsg(0, "Unknown keyword \"%s\" in %s ignored",
+						  parameter,
+						  fname);
+			success = KWFalse;
 
-      } /* if */
+		} /* if */
 
-   } /* while ( (parameter = strtok( token, WHITESPACE )) != NULL) */
+	} /* while ( (parameter = strtok( token, WHITESPACE )) != NULL) */
 
-   anchor->commands = (char **) commands;
-   anchor->validate = (char **) validate;
+	anchor->commands = (char **) commands;
+	anchor->validate = (char **) validate;
 
 /*--------------------------------------------------------------------*/
-/*    Now we have the data procesed by keyword, break it down more    */
+/*    Now we have the data procesed by keyword, break it down more	 */
 /*--------------------------------------------------------------------*/
 
-   if ((logname == NULL) && (machine == NULL))
-   {
+	if ((logname == NULL) && (machine == NULL))
+	{
 
-      printmsg(0,"InitEntry: No machine or logname given in %s",
-                  fname );
-      success = KWFalse;
+		printmsg(0,"InitEntry: No machine or logname given in %s",
+						fname );
+		success = KWFalse;
 
-   } /* if ((logname == NULL) && (machine == NULL)) */
+	} /* if ((logname == NULL) && (machine == NULL)) */
 
 /*--------------------------------------------------------------------*/
-/*                        Handle a login name                         */
+/*                        Handle a login name								 */
 /*--------------------------------------------------------------------*/
 
-   if (logname != NULL)
-   {
-      printmsg(10,"InitEntry: Processing logname=%s",logname );
+	if (logname != NULL)
+	{
+		printmsg(10,"InitEntry: Processing logname=%s",logname );
 
-      userp = checkuser( logname );
+		userp = checkuser( logname );
 
-      if ( userp == BADUSER )
-      {
+		if ( userp == BADUSER )
+		{
 
-         printmsg(0,"InitEntry: Invalid user id in %s, LOGNAME=%s",
-                     fname, logname );
-         success = KWFalse;
+			printmsg(0,"InitEntry: Invalid user id in %s, LOGNAME=%s",
+							fname, logname );
+			success = KWFalse;
 
-      } /* if ( userp == BADUSER ) */
-      else if (userp->hsecure == NULL)
-         userp->hsecure = anchor;
-      else {
+		} /* if ( userp == BADUSER ) */
+		else if (userp->hsecure == NULL)
+			userp->hsecure = anchor;
+		else {
 
-         printmsg(0,"InitEntry: Duplicate user id in %s, LOGNAME=%s",
-                     fname, logname );
-         success = KWFalse;
+			printmsg(0,"InitEntry: Duplicate user id in %s, LOGNAME=%s",
+							fname, logname );
+			success = KWFalse;
 
-      } /* else */
+		} /* else */
 
-   } /* if (logname != NULL) */
+	} /* if (logname != NULL) */
 
 /*--------------------------------------------------------------------*/
-/*                        Handle machine names                        */
+/*                        Handle machine names								 */
 /*--------------------------------------------------------------------*/
 
-   token = machine;
+	token = machine;
 
-   while( token != NULL )
-   {
-      char *host = strtok( token, ":");
+	while( token != NULL )
+	{
+		char *host = strtok( token, ":");
 
-      printmsg(10,"InitEntry: Processing machine=%s", host );
+		printmsg(10,"InitEntry: Processing machine=%s", host );
 
-      token = strtok( NULL, "");
-      if ( equal( host , ANY_HOST ) )
-      {
-         if ( default_security == NULL )
-            default_security = anchor;
-         else {
-            printmsg(0,"InitEntry: "
-                       "Multiple MACHINE entries in %s which specify OTHER",
-                       fname);
-            success = KWFalse;
-         } /* else */
+		token = strtok( NULL, "");
+		if ( equal( host , ANY_HOST ) )
+		{
+			if ( default_security == NULL )
+				default_security = anchor;
+			else {
+				printmsg(0,"InitEntry: "
+							  "Multiple MACHINE entries in %s which specify OTHER",
+							  fname);
+				success = KWFalse;
+			} /* else */
 
-      } /* if ( equal( host , ANY_HOST ) ) */
-      else {
+		} /* if ( equal( host , ANY_HOST ) ) */
+		else {
 
-         hostp = checkreal( host );
+			hostp = checkreal( host );
 
-         if ( hostp == BADUSER )
-         {
+			if ( hostp == BADUSER )
+			{
 
-            printmsg(0,"InitEntry: Invalid host id in %s, MACHINE=%s",
-                        fname, host );
-            success = KWFalse;
+				printmsg(0,"InitEntry: Invalid host id in %s, MACHINE=%s",
+								fname, host );
+				success = KWFalse;
 
-         } /* if ( hostp == BADUSER ) */
-         else if (hostp->hsecure == NULL)
-            hostp->hsecure = anchor;
-         else {
+			} /* if ( hostp == BADUSER ) */
+			else if (hostp->hsecure == NULL)
+				hostp->hsecure = anchor;
+			else {
 
-            printmsg(0,"InitEntry: Duplicate host id in %s, MACHINE=%s",
-                        fname, token );
-            success = KWFalse;
+				printmsg(0,"InitEntry: Duplicate host id in %s, MACHINE=%s",
+								fname, token );
+				success = KWFalse;
 
-         } /* else */
+			} /* else */
 
-      } /* else */
+		} /* else */
 
-   } /* while( token != NULL ) */
+	} /* while( token != NULL ) */
 
-   if ( machine != NULL )
-      free( machine );
+	if ( machine != NULL )
+		free( machine );
 
 /*--------------------------------------------------------------------*/
 /*                       Handle validated names                       */
 /*--------------------------------------------------------------------*/
 
-   if ( anchor->validate != NULL )
-   {
-      char **plist = anchor->validate;
+	if ( anchor->validate != NULL )
+	{
+		char **plist = anchor->validate;
 
-      while ( *plist != NULL )
-      {
-         hostp = checkreal( *plist );
+		while ( *plist != NULL )
+		{
+			hostp = checkreal( *plist );
 
-         if ( hostp == BADUSER )
-         {
+			if ( hostp == BADUSER )
+			{
 
-            printmsg(0,"InitEntry: Invalid host id in %s, VALIDATE=%s",
-                        fname, *plist);
-            success = KWFalse;
+				printmsg(0,"InitEntry: Invalid host id in %s, VALIDATE=%s",
+								fname, *plist);
+				success = KWFalse;
 
-         } /* if ( hostp == BADUSER ) */
-         else
-            hostp->anylogin = KWFalse;  /* Flag we must use specific
-                                          login                       */
+			} /* if ( hostp == BADUSER ) */
+			else
+				hostp->anylogin = KWFalse;  /* Flag we must use specific
+														login                       */
 
-         plist++;             /* Step to next hostname in list        */
+			plist++;             /* Step to next hostname in list        */
 
-      } /* while ( *plist != NULL ) */
+		} /* while ( *plist != NULL ) */
 
-   } /* if ( anchor->validate != NULL ) */
+	} /* if ( anchor->validate != NULL ) */
 
 /*--------------------------------------------------------------------*/
-/*                          Handle CALLBACK                           */
+/*                          Handle CALLBACK									 */
 /*--------------------------------------------------------------------*/
 
-   if ( callback != NULL )
-   {
+	if ( callback != NULL )
+	{
 
-      if (equal(strlwr(callback),"no"))
-         anchor->callback = KWFalse;
-      else if (equal(callback,"yes"))
-         anchor->callback = KWTrue;
-      else {
-         printmsg(0,"InitEntry: Invalid value in %s, CALLBACK=%s",
-                     fname, callback );
-         success = KWFalse;
-      } /* else */
+		if (equal(strlwr(callback),"no"))
+			anchor->callback = KWFalse;
+		else if (equal(callback,"yes"))
+			anchor->callback = KWTrue;
+		else {
+			printmsg(0,"InitEntry: Invalid value in %s, CALLBACK=%s",
+							fname, callback );
+			success = KWFalse;
+		} /* else */
 
-   } /* if ( callback != NULL ) */
+	} /* if ( callback != NULL ) */
 
 /*--------------------------------------------------------------------*/
-/*                          Handle REQUEST                            */
+/*                          Handle REQUEST									 */
 /*--------------------------------------------------------------------*/
 
-   if ( request != NULL )
-   {
+	if ( request != NULL )
+	{
 
-      if (equal(strlwr(request),"no"))
-         anchor->request = KWFalse;
-      else if (equal(request,"yes"))
-         anchor->request = KWTrue;
-      else {
-         printmsg(0,"InitEntry: Invalid value in %s, REQUEST=%s",
-                     fname, request );
-         success = KWFalse;
-      } /* else */
+		if (equal(strlwr(request),"no"))
+			anchor->request = KWFalse;
+		else if (equal(request,"yes"))
+			anchor->request = KWTrue;
+		else {
+			printmsg(0,"InitEntry: Invalid value in %s, REQUEST=%s",
+							fname, request );
+			success = KWFalse;
+		} /* else */
 
-   } /* if ( request != NULL ) */
+	} /* if ( request != NULL ) */
 
 /*--------------------------------------------------------------------*/
 /*                          Handle SENDFILES                          */
 /*--------------------------------------------------------------------*/
 
-   if ( sendfiles != NULL)
-   {
+	if ( sendfiles != NULL)
+	{
 
-      if (equal(strlwr(sendfiles),"call"))
-         anchor->sendfiles = KWFalse;
-      else if (equal(sendfiles,"yes"))
-         anchor->sendfiles = KWTrue;
-      else {
+		if (equal(strlwr(sendfiles),"call"))
+			anchor->sendfiles = KWFalse;
+		else if (equal(sendfiles,"yes"))
+			anchor->sendfiles = KWTrue;
+		else {
 
-         printmsg(0,"InitEntry: Invalid value in %s, SENDFILES=%s",
-                     fname, sendfiles );
-         success = KWFalse;
+			printmsg(0,"InitEntry: Invalid value in %s, SENDFILES=%s",
+							fname, sendfiles );
+			success = KWFalse;
 
-      } /* else */
+		} /* else */
 
-   } /* if */
+	} /* if */
 
 /*--------------------------------------------------------------------*/
-/*                          handle commands                           */
+/*                          handle commands									 */
 /*--------------------------------------------------------------------*/
 
-   if ( anchor->commands == NULL )
-      anchor->commands = command_list;
+	if ( anchor->commands == NULL )
+		anchor->commands = command_list;
 
 /*--------------------------------------------------------------------*/
-/*                 Handle local system name aliasing                  */
+/*                 Handle local system name aliasing						 */
 /*--------------------------------------------------------------------*/
 
-   if (myname == NULL)
-      anchor->myname = E_nodename;
-   else
-      anchor->myname = myname;
+	if (myname == NULL)
+		anchor->myname = E_nodename;
+	else
+		anchor->myname = myname;
 
 /*--------------------------------------------------------------------*/
 /*                 Provide a default public directory                 */
 /*--------------------------------------------------------------------*/
 
-   if (xpubdir == NULL)
-       anchor->pubdir = E_pubdir;
-   else {
-
-      char path[FILENAME_MAX];
-      strcpy( path, xpubdir );
-
-      if ( expand_path( path, E_pubdir, E_pubdir , NULL) == NULL )
-      {
-         printmsg(0, "Unable to expand path \"%s\"",path );
-         anchor->pubdir = E_pubdir;
-         success = KWFalse;
-      } /* else */
-      else
-         anchor->pubdir = newstr(path );
+	if (xpubdir == NULL)
+		 anchor->pubdir = E_pubdir;
+	else {
+
+		char path[FILENAME_MAX];
+		strcpy( path, xpubdir );
+
+		if ( expand_path( path, E_pubdir, E_pubdir , NULL) == NULL )
+		{
+			printmsg(0, "Unable to expand path \"%s\"",path );
+			anchor->pubdir = E_pubdir;
+			success = KWFalse;
+		} /* else */
+		else
+			anchor->pubdir = newstr(path );
 
-   } /* else */
+	} /* else */
 
 /*--------------------------------------------------------------------*/
 /*                      Directory processing                          */
 /*--------------------------------------------------------------------*/
 
-   anchor->dirlist = malloc( sizeof anchor->dirlist[0] * max_elements );
-   checkref( anchor->dirlist );
+	anchor->dirlist = malloc( sizeof anchor->dirlist[0] * max_elements );
+	checkref( anchor->dirlist );
 
-   max_elements = InitDir( read,    ALLOW_READ,  KWTrue,  anchor,
-            max_elements );
-   free( read );
-
-   max_elements = InitDir( noread,  ALLOW_READ,  KWFalse, anchor,
-            max_elements );
-   free( noread );
-
-   max_elements = InitDir( write,   ALLOW_WRITE, KWTrue,  anchor,
-            max_elements );
-   free( write );
-
-   max_elements = InitDir( nowrite, ALLOW_WRITE, KWFalse, anchor,
-                           max_elements );
-   free( nowrite );
-
-/*--------------------------------------------------------------------*/
-/*    If no explicit directories given, give them access to pubdir    */
-/*--------------------------------------------------------------------*/
-
-   if ( anchor->dirsize == 0)
-   {
-      max_elements = InitDir( anchor->pubdir, ALLOW_READ, KWTrue,
-                              anchor, max_elements );
-      max_elements = InitDir( anchor->pubdir, ALLOW_WRITE, KWTrue,
-                              anchor, max_elements );
-   }
-
-   if ( max_elements == 0 )
-      success = KWFalse;
-   else {
-      size_t subscript;
-
-      anchor->dirlist = realloc( anchor->dirlist,
-                                 anchor->dirsize * sizeof anchor->dirlist[0]);
-      checkref( anchor->dirlist );
-
-      qsort(anchor->dirlist,
-            anchor->dirsize,
-            sizeof(anchor->dirlist[0]),
-            dircmp);
-
-      if ( debuglevel > 4 )
-      for ( subscript = 0; subscript < anchor->dirsize; subscript++ )
-      {
-         printmsg(4, "InitEntry: dirlist[%d] %s\t%s\t%s",
-                  subscript,
-                  anchor->dirlist[subscript].grant ? "grant" : "deny" ,
-                  anchor->dirlist[subscript].priv == ALLOW_WRITE ?
-                           "WRITE" : "READ" ,
-                  anchor->dirlist[subscript].path );
-      }
-   } /* else */
+	max_elements = InitDir( read,    ALLOW_READ,  KWTrue,  anchor,
+				max_elements );
+	free( read );
+
+	max_elements = InitDir( noread,	ALLOW_READ,  KWFalse, anchor,
+				max_elements );
+	free( noread );
+
+	max_elements = InitDir( write,	ALLOW_WRITE, KWTrue,  anchor,
+				max_elements );
+	free( write );
+
+	max_elements = InitDir( nowrite, ALLOW_WRITE, KWFalse, anchor,
+									max_elements );
+	free( nowrite );
+
+/*--------------------------------------------------------------------*/
+/*    If no explicit directories given, give them access to pubdir	 */
+/*--------------------------------------------------------------------*/
+
+	if ( anchor->dirsize == 0)
+	{
+		max_elements = InitDir( anchor->pubdir, ALLOW_READ, KWTrue,
+										anchor, max_elements );
+		max_elements = InitDir( anchor->pubdir, ALLOW_WRITE, KWTrue,
+										anchor, max_elements );
+	}
+
+	if ( max_elements == 0 )
+		success = KWFalse;
+	else {
+		size_t subscript;
+
+		anchor->dirlist = realloc( anchor->dirlist,
+											anchor->dirsize * sizeof anchor->dirlist[0]);
+		checkref( anchor->dirlist );
+
+		qsort(anchor->dirlist,
+				anchor->dirsize,
+				sizeof(anchor->dirlist[0]),
+				dircmp);
+
+		if ( debuglevel > 4 )
+		for ( subscript = 0; subscript < anchor->dirsize; subscript++ )
+		{
+			printmsg(4, "InitEntry: dirlist[%d] %s\t%s\t%s",
+						subscript,
+						anchor->dirlist[subscript].grant ? "grant" : "deny" ,
+						anchor->dirlist[subscript].priv == ALLOW_WRITE ?
+									"WRITE" : "READ" ,
+						anchor->dirlist[subscript].path );
+		}
+	} /* else */
 
 /*--------------------------------------------------------------------*/
 /*                          Return to caller                          */
 /*--------------------------------------------------------------------*/
 
-   return success;
+	return success;
 
 } /* InitEntry */
 
 /*--------------------------------------------------------------------*/
-/*    I n i t D i r                                                   */
+/*    I n i t D i r																	 */
 /*                                                                    */
-/*    Initialize security table directory entries                     */
+/*    Initialize security table directory entries							 */
 /*--------------------------------------------------------------------*/
 
 static size_t InitDir( char *directories,
-         const REMOTE_ACCESS access,
-         const KWBoolean grant,
-         struct HostSecurity *anchor,
-         size_t max_elements )
+			const REMOTE_ACCESS access,
+			const KWBoolean grant,
+			struct HostSecurity *anchor,
+			size_t max_elements )
 {
-   char *field = directories;
-   char *token = directories;
-   struct  stat    statbuf;
-   size_t subscript;
+	char *field = directories;
+	char *token = directories;
+	struct  stat	 statbuf;
+	size_t subscript;
 
 /*--------------------------------------------------------------------*/
-/*    Don't process data if no input or we previously had an error    */
+/*    Don't process data if no input or we previously had an error	 */
 /*--------------------------------------------------------------------*/
 
-   if ( (directories == NULL ) || ( max_elements == 0) )
-      return max_elements;
+	if ( (directories == NULL ) || ( max_elements == 0) )
+		return max_elements;
 
 /*--------------------------------------------------------------------*/
-/*              Begin loop to process names in the path               */
+/*              Begin loop to process names in the path					 */
 /*--------------------------------------------------------------------*/
 
-   while ( (token = NextField( field )) != NULL)
-   {
-      char path[FILENAME_MAX];
+	while ( (token = NextField( field )) != NULL)
+	{
+		char path[FILENAME_MAX];
 
-      if ( anchor->dirsize == max_elements )
-      {
-         max_elements = max_elements * 2;
-         anchor->dirlist = realloc( anchor->dirlist,
-                sizeof anchor->dirlist[0] * max_elements );
-         checkref( anchor->dirlist );
-      }
+		if ( anchor->dirsize == max_elements )
+		{
+			max_elements = max_elements * 2;
+			anchor->dirlist = realloc( anchor->dirlist,
+					 sizeof anchor->dirlist[0] * max_elements );
+			checkref( anchor->dirlist );
+		}
 
 /*--------------------------------------------------------------------*/
-/*                      Normalize directory name                      */
+/*                      Normalize directory name							 */
 /*--------------------------------------------------------------------*/
 
-      strcpy( path, token);
+		strcpy( path, token);
 
-      if (isalpha(path[0]) && (path[1] != ':') && (strlen(path) == 2))
-         ;                 /* Yup, do nothing for root drive names  */
-      else if ( expand_path( path,
-                             anchor->pubdir,
-                             anchor->pubdir,
-                             NULL) == NULL )
-      {
-         printmsg(0, "Unable to expand path \"%s\"",path );
-         return 0;
-      } /* else */
+		if (isalpha(path[0]) && (path[1] != ':') && (strlen(path) == 2))
+			;						/* Yup, do nothing for root drive names  */
+		else if ( expand_path( path,
+									  anchor->pubdir,
+									  anchor->pubdir,
+									  NULL) == NULL )
+		{
+			printmsg(0, "Unable to expand path \"%s\"",path );
+			return 0;
+		} /* else */
 
-      field = normalize( path );
+		field = normalize( path );
 
 /*--------------------------------------------------------------------*/
-/*       Normalize leaves a slash on root directories, which we       */
-/*       don't want in our table, so delete if it exists.             */
+/*       Normalize leaves a slash on root directories, which we		 */
+/*       don't want in our table, so delete if it exists.				 */
 /*--------------------------------------------------------------------*/
 
-      if (( strlen( field ) == 3 ) &&
-          isalpha( *field ) && equal( field + 1 , ":/"))
-         field[2] = '\0';
+		if (( strlen( field ) == 3 ) &&
+			 isalpha( *field ) && equal( field + 1 , ":/"))
+			field[2] = '\0';
 
-      strlwr( field );           /* Lower case for compares           */
-      field = newstr( field );   /* Save the path for insert in table */
+		strlwr( field );				/* Lower case for compares           */
+		field = newstr( field );	/* Save the path for insert in table */
 
 /*--------------------------------------------------------------------*/
-/*               Verify it really is a valid directory                */
+/*               Verify it really is a valid directory					 */
 /*--------------------------------------------------------------------*/
 
-      if ( strlen( field ) > 2 ) /* More than just drive/colon? (x:)  */
-      {                       /* Yes --> Go check disk for path       */
+		if ( strlen( field ) > 2 ) /* More than just drive/colon? (x:)  */
+		{								/* Yes --> Go check disk for path		 */
 
-         if (stat(field , &statbuf) != 0)
-         {
-            printmsg(2,"Warning ... invalid (non-existent) "
-                       "PERMISSIONS file entry %s:",
-                       token );
+			if (stat(field , &statbuf) != 0)
+			{
+				printmsg(2,"Warning ... invalid (non-existent) "
+							  "PERMISSIONS file entry %s:",
+							  token );
 
-            if ( debuglevel > 1 )
-               printerr(field);
+				if ( debuglevel > 1 )
+					printerr(field);
 
-         }
-         else if ((statbuf.st_mode & S_IFDIR) == 0)
-         {
-            printmsg(0,"InitDir: \"%s\" is a file, not a directory",
-                        field);
-            return 0;
-         }
+			}
+			else if ((statbuf.st_mode & S_IFDIR) == 0)
+			{
+				printmsg(0,"InitDir: \"%s\" is a file, not a directory",
+								field);
+				return 0;
+			}
 
-      } /* if ( strlen( field ) > 2 ) */
+		} /* if ( strlen( field ) > 2 ) */
 
 /*--------------------------------------------------------------------*/
-/*           Verify this directory not already in the list            */
+/*           Verify this directory not already in the list				 */
 /*--------------------------------------------------------------------*/
 
-      for (subscript = 0; subscript < anchor->dirsize ; subscript++)
-      {
+		for (subscript = 0; subscript < anchor->dirsize ; subscript++)
+		{
 
-         if ( (access == anchor->dirlist[subscript].priv) &&
-              equal( field, anchor->dirlist[subscript].path))
-         {
-            printmsg(0,"InitDir: Duplicate directory %s/", field);
-            return 0;
-         } /* if */
+			if ( (access == anchor->dirlist[subscript].priv) &&
+				  equal( field, anchor->dirlist[subscript].path))
+			{
+				printmsg(0,"InitDir: Duplicate directory %s/", field);
+				return 0;
+			} /* if */
 
-      } /* for */
+		} /* for */
 
 /*--------------------------------------------------------------------*/
-/*            No conflict, add this directory to the list             */
+/*            No conflict, add this directory to the list				 */
 /*--------------------------------------------------------------------*/
 
-      printmsg(10,"InitDir: Adding \"%s\" as \"%s\"", token , field);
-      anchor->dirlist[subscript].path  = field;
-      anchor->dirlist[subscript].priv  = access;
-      anchor->dirlist[subscript].grant = grant;
-      anchor->dirsize++;
+		printmsg(10,"InitDir: Adding \"%s\" as \"%s\"", token , field);
+		anchor->dirlist[subscript].path	= field;
+		anchor->dirlist[subscript].priv	= access;
+		anchor->dirlist[subscript].grant = grant;
+		anchor->dirsize++;
 
-      field = NULL;           /* Look at next field next pass         */
+		field = NULL;				/* Look at next field next pass			 */
 
-   } /* while ( (field = NextField( field )) != NULL) */
+	} /* while ( (field = NextField( field )) != NULL) */
 
 /*--------------------------------------------------------------------*/
 /*                          Return to caller                          */
 /*--------------------------------------------------------------------*/
 
-   return max_elements;
+	return max_elements;
 
 } /* InitDir */
 
 /*--------------------------------------------------------------------*/
 /*    d i r c m p                                                     */
 /*                                                                    */
-/*    Compares two directory structures for sorting                   */
+/*    Compares two directory structures for sorting						 */
 /*--------------------------------------------------------------------*/
 
 int dircmp( const void *a , const void *b )
 {
-   struct DIRLIST *x = (struct DIRLIST*) a;
-   struct DIRLIST *y = (struct DIRLIST*) b;
+	struct DIRLIST *x = (struct DIRLIST*) a;
+	struct DIRLIST *y = (struct DIRLIST*) b;
 
-   int result = strcmp(x->path, y->path);
+	int result = strcmp(x->path, y->path);
 
-   if (result == 0 && (x->priv != y->priv))
-      result = ( x->priv < y->priv ) ? -1 : 1;
+	if (result == 0 && (x->priv != y->priv))
+		result = ( x->priv < y->priv ) ? -1 : 1;
 
-   return result;
+	return result;
 
-}  /*dircmp*/
+}	/*dircmp*/
 
 /*--------------------------------------------------------------------*/
 /*    V a l i d a t e H o s t                                         */
@@ -860,179 +864,179 @@
 
 KWBoolean ValidateHost( const char *host )
 {
-   char **target;
+	char **target;
 
 /*--------------------------------------------------------------------*/
-/*      If this host has no security profile, reject the access       */
+/*      If this host has no security profile, reject the access		 */
 /*--------------------------------------------------------------------*/
 
-   if ( securep == NULL )
-      return KWFalse;
+	if ( securep == NULL )
+		return KWFalse;
 
 /*--------------------------------------------------------------------*/
 /*    If we allow any host on this user id, use it if the calling     */
-/*    host is not supported any other profile                         */
+/*    host is not supported any other profile								 */
 /*--------------------------------------------------------------------*/
 
-   target = securep->validate;
-   if ( target == NULL )      /* No validate list for this user?      */
-   {                          /* Correct --> Use if none for host     */
-      struct HostTable *hostp = checkreal( host );
-      if ( hostp == BADHOST ) /* Host exist?                          */
-         panic();             /* No --> Internal error, abort         */
+	target = securep->validate;
+	if ( target == NULL )		/* No validate list for this user?		 */
+	{									/* Correct --> Use if none for host     */
+		struct HostTable *hostp = checkreal( host );
+		if ( hostp == BADHOST ) /* Host exist?                          */
+			panic();             /* No --> Internal error, abort			 */
 
-      return hostp->anylogin; /* Allow action if generic access
-                                 allowed for host                     */
-   }  /* if ( target == NULL ) */
+		return hostp->anylogin; /* Allow action if generic access
+											allowed for host							 */
+	}	/* if ( target == NULL ) */
 
 /*--------------------------------------------------------------------*/
-/*          Determine if this host is allowed for this login          */
+/*          Determine if this host is allowed for this login			 */
 /*--------------------------------------------------------------------*/
 
-   while (*target != NULL)
-   {
-      if ( equal(*target++, host ))
-         return KWTrue;
-   } /* (*target != NULL) */
+	while (*target != NULL)
+	{
+		if ( equal(*target++, host ))
+			return KWTrue;
+	} /* (*target != NULL) */
 
 /*--------------------------------------------------------------------*/
 /*                 We didn't find the host; reject it                 */
 /*--------------------------------------------------------------------*/
 
-   return KWFalse;
+	return KWFalse;
 
 } /* ValidateHost */
 
 /*--------------------------------------------------------------------*/
 /*    V a l i d a t e F i l e                                         */
 /*                                                                    */
-/*    Allow or reject access to a file by name                        */
+/*    Allow or reject access to a file by name								 */
 /*--------------------------------------------------------------------*/
 
-KWBoolean ValidateFile( const char *input,  /* Full path name          */
-                      const REMOTE_ACCESS needed )
+KWBoolean ValidateFile( const char *input,  /* Full path name			  */
+							 const REMOTE_ACCESS needed )
 {
-   char path[FILENAME_MAX];
-   char *column;
+	char path[FILENAME_MAX];
+	char *column;
 
 /*--------------------------------------------------------------------*/
-/*                  Validate the length of the name                   */
+/*                  Validate the length of the name						 */
 /*--------------------------------------------------------------------*/
 
-   printmsg(5,"ValidateFile: Checking %s access for file \"%s\"",
-            (needed == ALLOW_WRITE) ? "WRITE" : "READ" , input);
+	printmsg(5,"ValidateFile: Checking %s access for file \"%s\"",
+				(needed == ALLOW_WRITE) ? "WRITE" : "READ" , input);
 
-   if ( strlen( input ) >= sizeof path)   /* Reject all invalid names*/
-   {
-      printmsg(0,"ValidateFile: Access rejected, name too long: %s",
-                 input);
-      return KWFalse;
-   }
+	if ( strlen( input ) >= sizeof path)	/* Reject all invalid names*/
+	{
+		printmsg(0,"ValidateFile: Access rejected, name too long: %s",
+					  input);
+		return KWFalse;
+	}
 
 /*--------------------------------------------------------------------*/
 /*     Validate format of name; we don't allow parent directories     */
 /*--------------------------------------------------------------------*/
 
-   if ( strstr( input, "..") )            /* Games with parent dir?   */
-   {
-      printmsg(0,"ValidateFile: Access rejected, name not normalized: %s",
-                 input);
-      return KWFalse;
-   }
+	if ( strstr( input, "..") )				/* Games with parent dir?	 */
+	{
+		printmsg(0,"ValidateFile: Access rejected, name not normalized: %s",
+					  input);
+		return KWFalse;
+	}
 
 /*--------------------------------------------------------------------*/
 /*                Validate the security table is okay                 */
 /*--------------------------------------------------------------------*/
 
-   if ( securep == NULL )
-   {
-      printmsg(0,"Security not initialized for host");
-      panic();
-   }
+	if ( securep == NULL )
+	{
+		printmsg(0,"Security not initialized for host");
+		panic();
+	}
 
 /*--------------------------------------------------------------------*/
-/*                        Handle local system                         */
+/*                        Handle local system								 */
 /*--------------------------------------------------------------------*/
 
-   if ( securep->local )      /* Local system?                        */
-      return KWTrue;           /* Yes --> Bless the request            */
+	if ( securep->local )		/* Local system?								 */
+		return KWTrue;           /* Yes --> Bless the request            */
 
 /*--------------------------------------------------------------------*/
-/*       Determine if the user is allowed to request files            */
+/*       Determine if the user is allowed to request files				 */
 /*--------------------------------------------------------------------*/
 
-   if ((needed == ALLOW_READ) && !securep->request)
-   {
-      printmsg(0,"ValidateFile: access rejected, "
-                 "REQUEST not enabled in permissions file");
-      return KWFalse;
-   }
+	if ((needed == ALLOW_READ) && !securep->request)
+	{
+		printmsg(0,"ValidateFile: access rejected, "
+					  "REQUEST not enabled in permissions file");
+		return KWFalse;
+	}
 
 /*--------------------------------------------------------------------*/
-/*                           Copy path name                           */
+/*                           Copy path name									 */
 /*--------------------------------------------------------------------*/
 
-   if ( input[1] == ':' )
-      strcpy( path, input );
-   else
-      strcat( strcpy( path , drive ), input );
+	if ( input[1] == ':' )
+		strcpy( path, input );
+	else
+		strcat( strcpy( path , drive ), input );
 
-   strlwr( path );
+	strlwr( path );
 
 /*--------------------------------------------------------------------*/
-/*              Locate the best file match for the path               */
+/*              Locate the best file match for the path					 */
 /*--------------------------------------------------------------------*/
 
-   while( (column = strrchr( path, '/')) != NULL )
-   {
-      int lower = 0;
-      int upper = (int) securep->dirsize - 1;
+	while( (column = strrchr( path, '/')) != NULL )
+	{
+		int lower = 0;
+		int upper = (int) securep->dirsize - 1;
 
-      *column = '\0';
-      printmsg(10,"ValidateFile: Searching for %s", path);
+		*column = '\0';
+		printmsg(10,"ValidateFile: Searching for %s", path);
 
-      while( lower <= upper )
-      {
-         int midpoint = (lower + upper) / 2;
-         int hit = strcmp(path, securep->dirlist[midpoint].path);
+		while( lower <= upper )
+		{
+			int midpoint = (lower + upper) / 2;
+			int hit = strcmp(path, securep->dirlist[midpoint].path);
 
-         printmsg(10,"ValidateFile: Comparing %s and %s",
-                        path, securep->dirlist[midpoint].path);
+			printmsg(10,"ValidateFile: Comparing %s and %s",
+								path, securep->dirlist[midpoint].path);
 
-         if ( hit == 0 )
-            hit = (int) needed - (int) securep->dirlist[midpoint].priv;
+			if ( hit == 0 )
+				hit = (int) needed - (int) securep->dirlist[midpoint].priv;
 
-         if (hit > 0)
-            lower = midpoint + 1;
-         else if (hit < 0)
-            upper = midpoint - 1;
-         else {
-            printmsg( securep->dirlist[midpoint].grant ? 5 : 0 ,
-                     "ValidateFile: Found path \"%s\", access %s to \"%s\"",
-                     securep->dirlist[midpoint].path,
-                     securep->dirlist[midpoint].grant ?
-                                    "granted" : "denied", input);
-            return securep->dirlist[midpoint].grant;
-         }
+			if (hit > 0)
+				lower = midpoint + 1;
+			else if (hit < 0)
+				upper = midpoint - 1;
+			else {
+				printmsg( securep->dirlist[midpoint].grant ? 5 : 0 ,
+							"ValidateFile: Found path \"%s\", access %s to \"%s\"",
+							securep->dirlist[midpoint].path,
+							securep->dirlist[midpoint].grant ?
+												"granted" : "denied", input);
+				return securep->dirlist[midpoint].grant;
+			}
 
-      } /* while( lower <= upper ) */
+		} /* while( lower <= upper ) */
 
-   } /* while( (column = strrchr( path, '/')) != NULL ) */
+	} /* while( (column = strrchr( path, '/')) != NULL ) */
 
 /*--------------------------------------------------------------------*/
-/*          We didn't find the file; reject all access to it          */
+/*          We didn't find the file; reject all access to it			 */
 /*--------------------------------------------------------------------*/
 
-   printmsg(0,"ValidateFile: No %s access definition found for "
-              "\"%s\", access denied",
-            needed == ALLOW_READ ? "read" : "write" ,
-            input);
-   return KWFalse;
+	printmsg(0,"ValidateFile: No %s access definition found for "
+				  "\"%s\", access denied",
+				needed == ALLOW_READ ? "read" : "write" ,
+				input);
+	return KWFalse;
 
 } /* ValidateFile */
 
 /*--------------------------------------------------------------------*/
-/*    G e t S e c u r i t y                                           */
+/*    G e t S e c u r i t y														 */
 /*                                                                    */
 /*    Return security structure for to use when calling out to        */
 /*    another system                                                  */
@@ -1040,16 +1044,16 @@
 
 struct HostSecurity *GetSecurity( struct HostTable *hostp)
 {
-   if ((hostp->hsecure == NULL) && (default_security != NULL ))
-   {
+	if ((hostp->hsecure == NULL) && (default_security != NULL ))
+	{
 
-      printmsg(2,"GetSecurity: Using security for MACHINE=OTHER for "
-                 "system \"%s\"", hostp->hostname );
+		printmsg(2,"GetSecurity: Using security for MACHINE=OTHER for "
+					  "system \"%s\"", hostp->hostname );
 
-      hostp->hsecure = default_security;
+		hostp->hsecure = default_security;
 
-   } /* if  */
+	} /* if	*/
 
-   return hostp->hsecure;
+	return hostp->hsecure;
 
 } /* GetSecurity */
--- e:\uupc1.12s\source\lib\TIMESTMP.C	Sun Mar 30 23:06:58 1997
+++ TIMESTMP.C	Fri Jul 25 21:42:44 1997
@@ -1,19 +1,19 @@
 /*--------------------------------------------------------------------*/
-/*    t i m e s t m p . c                                             */
+/*    t i m e s t m p . c															 */
 /*                                                                    */
-/*    Compiler timestamps for display at program start-up             */
+/*    Compiler timestamps for display at program start-up				 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*       Changes Copyright (c) 1989-1997 by Kendra Electronic         */
-/*       Wonderworks.                                                 */
+/*       Changes Copyright (c) 1989-1997 by Kendra Electronic			 */
+/*       Wonderworks.																 */
 /*                                                                    */
-/*       All rights reserved except those explicitly granted by       */
-/*       the UUPC/extended license agreement.                         */
+/*       All rights reserved except those explicitly granted by		 */
+/*       the UUPC/extended license agreement.								 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                          RCS Information                           */
+/*                          RCS Information									 */
 /*--------------------------------------------------------------------*/
 
 /*
@@ -21,19 +21,19 @@
  *
  *    Revision history:
  *    $Log: timestmp.c $
- *    Revision 1.18  1997/03/31 07:07:06  ahd
+ *    Revision 1.18	1997/03/31 07:07:06	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.17  1996/01/01 20:52:35  ahd
+ *    Revision 1.17	1996/01/01 20:52:35	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.16  1995/08/27 23:30:21  ahd
+ *    Revision 1.16	1995/08/27 23:30:21	ahd
  *    Add debugging info to hello message
  *
- *    Revision 1.15  1994/12/22 00:11:37  ahd
+ *    Revision 1.15	1994/12/22 00:11:37	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.14  1994/04/24 20:35:08  ahd
+ *    Revision 1.14	1994/04/24 20:35:08	ahd
  *    Add title setting
  *
  *     Revision 1.13  1994/02/20  19:07:38  ahd
@@ -48,30 +48,34 @@
  *     Revision 1.10  1993/10/31  11:58:18  ahd
  *     Don't include version header if version already defined (for BC++)
  *
- *     Revision 1.9  1993/10/12  00:47:57  ahd
+ *     Revision 1.9	1993/10/12	00:47:57  ahd
  *     Normalize comments
  *
- *     Revision 1.8  1993/08/11  02:31:12  ahd
+ *     Revision 1.8	1993/08/11	02:31:12  ahd
  *     Always display the banner
  *
- *     Revision 1.7  1993/08/03  03:11:49  ahd
+ *     Revision 1.7	1993/08/03	03:11:49  ahd
  *     Drop _EasyWinInit
  *
- *     Revision 1.6  1993/08/02  03:24:59  ahd
+ *     Revision 1.6	1993/08/02	03:24:59  ahd
  *     Further changes in support of Robert Denny's Windows 3.x support
  *
- *     Revision 1.5  1993/07/31  16:22:16  ahd
+ *     Revision 1.5	1993/07/31	16:22:16  ahd
  *     Changes in support of Robert Denny's Windows 3.x support
  *
  */
 
 /*--------------------------------------------------------------------*/
-/*                        System include files                        */
+/*                        System include files								 */
 /*--------------------------------------------------------------------*/
 
 #include "uupcmoah.h"
 
+#ifdef __GCC__
+#include <stdio.h>
+#else
 #include <direct.h>
+#endif
 #include <io.h>
 
 #ifdef _Windows
@@ -81,7 +85,7 @@
 #endif
 
 /*--------------------------------------------------------------------*/
-/*                    UUPC/extended include files                     */
+/*                    UUPC/extended include files							 */
 /*--------------------------------------------------------------------*/
 
 #include "timestmp.h"
@@ -119,135 +123,135 @@
 /*--------------------------------------------------------------------*/
 /*       b a n n e r                                                  */
 /*                                                                    */
-/*       Report program name and version at startup                   */
+/*       Report program name and version at startup						 */
 /*--------------------------------------------------------------------*/
 
 void banner (char **argv)
 {
-      char dummy[FILENAME_MAX];
-      char program[FILENAME_MAX];
+		char dummy[FILENAME_MAX];
+		char program[FILENAME_MAX];
 
 #if defined(_Windows)
-   WORD wVersion;
-   WORD wMode;
-   char *szMode;
+	WORD wVersion;
+	WORD wMode;
+	char *szMode;
 
 /*--------------------------------------------------------------------*/
-/*                     Determine Windows version                      */
+/*                     Determine Windows version							 */
 /*--------------------------------------------------------------------*/
 
-   wVersion = LOWORD(GetVersion());
-   asm {
-         MOV      AX,0x400   /* DPMI Get Version call                 */
-         INT      0x31       /* ax=ver,bx=win286/386...               */
-         AND      BX,3       /* win386=1,win286=2                     */
-         MOV      wMode,BX   /* Put in local                          */
-   }
+	wVersion = LOWORD(GetVersion());
+	asm {
+			MOV		AX,0x400   /* DPMI Get Version call                 */
+			INT		0x31		  /* ax=ver,bx=win286/386...					 */
+			AND		BX,3		  /* win386=1,win286=2							 */
+			MOV		wMode,BX   /* Put in local                          */
+	}
 
-   switch(wMode)
-   {
-      case 1:
-         szMode = "386 Enhanced";
-         break;
+	switch(wMode)
+	{
+		case 1:
+			szMode = "386 Enhanced";
+			break;
 
-      case 2:
-         szMode = "Standard (286)";
-         break;
+		case 2:
+			szMode = "Standard (286)";
+			break;
 
-      default:
-         szMode = "Unknown";
-         break;
-   }
+		default:
+			szMode = "Unknown";
+			break;
+	}
 
-   if ( wVersion < 0x301 )
-   {
-      printmsg(0,"This program requires Windows 3.1, running %u.%u",
-                  (WORD)(LOBYTE(wVersion)),
-                  (WORD)(HIBYTE(wVersion)));
-      panic();
-   }
+	if ( wVersion < 0x301 )
+	{
+		printmsg(0,"This program requires Windows 3.1, running %u.%u",
+						(WORD)(LOBYTE(wVersion)),
+						(WORD)(HIBYTE(wVersion)));
+		panic();
+	}
 
-   sprintf(dummy, "Windows %u.%u %s",
-                  (WORD)(LOBYTE(wVersion)),
-                  (WORD)(HIBYTE(wVersion)),
-                  szMode );
-   compilew = newstr( dummy );
+	sprintf(dummy, "Windows %u.%u %s",
+						(WORD)(LOBYTE(wVersion)),
+						(WORD)(HIBYTE(wVersion)),
+						szMode );
+	compilew = newstr( dummy );
 
 #endif
 
 /*--------------------------------------------------------------------*/
-/*                     Deterine the program name                      */
+/*                     Deterine the program name							 */
 /*--------------------------------------------------------------------*/
 
 #ifdef __TURBOC__
-      if (  fnsplit(argv[0],dummy,dummy, program,dummy) && FILENAME )
-      {
+		if (	fnsplit(argv[0],dummy,dummy, program,dummy) && FILENAME )
+		{
 #else
-      if (!equal(argv[0],"C"))    /* Microsoft C for no prog name? */
-      {
-         _splitpath( argv[0], dummy , dummy , program , dummy );
+		if (!equal(argv[0],"C"))	 /* Microsoft C for no prog name? */
+		{
+			_splitpath( argv[0], dummy , dummy , program , dummy );
 #endif /* __TURBOC__ */
 
-         strcpy(argv[0], program);  /* Reset original program name    */
-         compilen = argv[0];
+			strcpy(argv[0], program);	/* Reset original program name	 */
+			compilen = argv[0];
 
 /*--------------------------------------------------------------------*/
 /*                 Return if input is not the console                 */
 /*--------------------------------------------------------------------*/
 
 #ifndef _Windows
-      if (!isatty(fileno(stdout))) /* Is the console I/O redirected?  */
-         return;                 /* Yes --> Run quietly               */
+		if (!isatty(fileno(stdout))) /* Is the console I/O redirected?  */
+			return;						/* Yes --> Run quietly					 */
 #endif
 
 /*--------------------------------------------------------------------*/
 /*                       Print the program name                       */
 /*--------------------------------------------------------------------*/
 
-         fprintf(stderr,"%s: ",program);
-      } /* if */
+			fprintf(stderr,"%s: ",program);
+		} /* if */
 
 /*--------------------------------------------------------------------*/
-/*    Now print out the version, operating system and time stamp      */
+/*    Now print out the version, operating system and time stamp		 */
 /*--------------------------------------------------------------------*/
 
-      fprintf(stderr,"%s %s (%s mode, %2.2s%3.3s%2.2s %5.5s)"
+		fprintf(stderr,"%s %s (%s mode, %2.2s%3.3s%2.2s %5.5s)"
 #ifdef UDEBUG
-                  " [debug enabled]"
+						" [debug enabled]"
 #endif /* UDEBUG */
 
-                  "\n",
-                  compilep,
-                  compilev,
+						"\n",
+						compilep,
+						compilev,
 
 #ifdef WIN32
-                  "Windows 32 bit",
+						"Windows 32 bit",
 #elif defined(_Windows)
-                  /* "Windows 16 bit", */ compilew,
+						/* "Windows 16 bit", */ compilew,
 #elif defined(__OS2__)
-                  "OS/2 32 bit",
+						"OS/2 32 bit",
 #elif defined(__TURBOC__)
-                  "DOS",
+						"DOS",
 #else
-                  (_osmode == DOS_MODE) ? "DOS" : "OS/2 16 bit",
+						(_osmode == DOS_MODE) ? "DOS" : "OS/2 16 bit",
 #endif
 
-                  &compiled[4],
-                  &compiled[0],
-                  &compiled[9],
-                  compilet);
+						&compiled[4],
+						&compiled[0],
+						&compiled[9],
+						compilet);
 
 #ifdef _Windows
-   hOurTask = GetCurrentTask();
-   if ( hOurTask == NULL )
-      panic();
-   hOurWindow = FindTaskWindow(hOurTask, "BCEasyWin");
+	hOurTask = GetCurrentTask();
+	if ( hOurTask == NULL )
+		panic();
+	hOurWindow = FindTaskWindow(hOurTask, "BCEasyWin");
 
 
-   ddelay(0);           /* To insure we yield control at least once;  */
-                        /* see comments in winutil.c.                 */
+	ddelay(0);				/* To insure we yield control at least once;  */
+								/* see comments in winutil.c.                 */
 #endif
 
-   setTitle("%s %s", compilep, compilev );
+	setTitle("%s %s", compilep, compilev );
 
 } /* banner */
--- e:\uupc1.12s\source\lib\USRCATCH.C	Sun Mar 30 23:07:32 1997
+++ USRCATCH.C	Sat Jul 26 20:08:34 1997
@@ -1,19 +1,19 @@
 /*--------------------------------------------------------------------*/
 /*       u s r c a t c h e r . c                                      */
 /*                                                                    */
-/*       Ctrl-Break handler for UUPC/extended                         */
+/*       Ctrl-Break handler for UUPC/extended								 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*       Changes Copyright (c) 1989-1997 by Kendra Electronic         */
-/*       Wonderworks.                                                 */
+/*       Changes Copyright (c) 1989-1997 by Kendra Electronic			 */
+/*       Wonderworks.																 */
 /*                                                                    */
-/*       All rights reserved except those explicitly granted by       */
-/*       the UUPC/extended license agreement.                         */
+/*       All rights reserved except those explicitly granted by		 */
+/*       the UUPC/extended license agreement.								 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                          RCS Information                           */
+/*                          RCS Information									 */
 /*--------------------------------------------------------------------*/
 
 /*
@@ -21,13 +21,13 @@
  *
  *    Revision history:
  *    $Log: usrcatch.c $
- *    Revision 1.12  1997/03/31 07:07:38  ahd
+ *    Revision 1.12	1997/03/31 07:07:38	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.11  1996/01/01 20:53:22  ahd
+ *    Revision 1.11	1996/01/01 20:53:22	ahd
  *    Annual Copyright Update
  *
- *    Revision 1.10  1995/01/29 16:43:03  ahd
+ *    Revision 1.10	1995/01/29 16:43:03	ahd
  *    IBM C/Set compiler warnings
  *
  *    Revision 1.9  1994/12/22 00:12:05  ahd
@@ -36,34 +36,34 @@
  *    Revision 1.8  1994/02/19 04:47:36  ahd
  *    Use standard first header
  *
- * Revision 1.7  1994/02/19  04:12:49  ahd
+ * Revision 1.7  1994/02/19  04:12:49	ahd
  * Use standard first header
  *
- * Revision 1.6  1994/02/19  04:00:20  ahd
+ * Revision 1.6  1994/02/19  04:00:20	ahd
  * Use standard first header
  *
- * Revision 1.5  1994/02/18  23:16:09  ahd
+ * Revision 1.5  1994/02/18  23:16:09	ahd
  * Use standard first header
  *
- * Revision 1.4  1994/01/01  19:06:51  ahd
+ * Revision 1.4  1994/01/01  19:06:51	ahd
  * Annual Copyright Update
  *
- * Revision 1.3  1993/09/30  03:06:28  ahd
+ * Revision 1.3  1993/09/30  03:06:28	ahd
  * Use straight signal value as flag
  *
- * Revision 1.3  1993/09/30  03:06:28  ahd
+ * Revision 1.3  1993/09/30  03:06:28	ahd
  * Use straight signal value as flag
  *
- * Revision 1.2  1993/09/29  13:18:06  ahd
+ * Revision 1.2  1993/09/29  13:18:06	ahd
  * Drop unneeded OS/2 ifdef
  *
- * Revision 1.1  1993/09/29  04:49:20  ahd
+ * Revision 1.1  1993/09/29  04:49:20	ahd
  * Initial revision
  *
  */
 
 /*--------------------------------------------------------------------*/
-/*                        System include files                        */
+/*                        System include files								 */
 /*--------------------------------------------------------------------*/
 
 #include "uupcmoah.h"
@@ -73,7 +73,7 @@
 #include <process.h>
 
 /*--------------------------------------------------------------------*/
-/*                    UUPC/extended include files                     */
+/*                    UUPC/extended include files							 */
 /*--------------------------------------------------------------------*/
 
 #include "timestmp.h"
@@ -83,13 +83,13 @@
 /*                          Global variables                          */
 /*--------------------------------------------------------------------*/
 
-extern unsigned long raised = 0;
+unsigned long raised = 0;
 
 /*--------------------------------------------------------------------*/
-/*    u s r 1 h a n d l e r                                           */
+/*    u s r 1 h a n d l e r														 */
 /*                                                                    */
 /*    Handles SIGUSR interrupt; from MicroSoft Programmer's           */
-/*    Workbench QuickHelp samples                                     */
+/*    Workbench QuickHelp samples												 */
 /*--------------------------------------------------------------------*/
 
 void
@@ -98,16 +98,16 @@
 #endif
 usrhandler( int sig )
 {
-   raised = (unsigned long) sig;
+	raised = (unsigned long) sig;
 
-   if ( raised == 0 )
-      abort();
+	if ( raised == 0 )
+		abort();
 
 /*--------------------------------------------------------------------*/
-/*    The handler pointer must be reset to our handler since by       */
-/*    default it is reset to the system handler.                      */
+/*    The handler pointer must be reset to our handler since by		 */
+/*    default it is reset to the system handler.							 */
 /*--------------------------------------------------------------------*/
 
-   signal( sig , usrhandler );
+	signal( sig , usrhandler );
 
 } /* usrhandler */
--- e:\uupc1.12s\source\lib\VALIDCMD.C	Sat Jan  7 11:15:04 1995
+++ VALIDCMD.C	Sun Jul 27 15:04:30 1997
@@ -1,22 +1,22 @@
 /*--------------------------------------------------------------------*/
-/*    v a l i d c m d . c                                             */
+/*    v a l i d c m d . c															 */
 /*                                                                    */
 /*    Security routines for UUPC/extended                             */
 /*                                                                    */
-/*    Copyright (c) 1991, Andrew H. Derbyshire                        */
-/*    See README.PRN for additional copyrights and restrictions       */
+/*    Copyright (c) 1991, Andrew H. Derbyshire								 */
+/*    See README.PRN for additional copyrights and restrictions		 */
 /*--------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------*/
-/*                        System include files                        */
+/*                        System include files								 */
 /*--------------------------------------------------------------------*/
 
 #include "uupcmoah.h"
-
+#include <ctype.h>
 #include <sys/stat.h>
 
 /*--------------------------------------------------------------------*/
-/*                    UUPC/extended include files                     */
+/*                    UUPC/extended include files							 */
 /*--------------------------------------------------------------------*/
 
 #include "hostable.h"
@@ -33,64 +33,64 @@
 
 KWBoolean ValidateCommand( const char *command)
 {
-   char **p;
+	char **p;
 
 /*--------------------------------------------------------------------*/
 /*                Validate the security table is okay                 */
 /*--------------------------------------------------------------------*/
 
-   if ( securep == NULL )
-      panic();
+	if ( securep == NULL )
+		panic();
 
 /*--------------------------------------------------------------------*/
-/*                        Handle local system                         */
+/*                        Handle local system								 */
 /*--------------------------------------------------------------------*/
 
-   if ( securep->local )      /* Local system?                        */
-   {
+	if ( securep->local )		/* Local system?								 */
+	{
 
 #ifdef UDEBUG
-      printmsg( 5, "ValidateCommand: Local system, command \"%s\" allowed",
-            command );
+		printmsg( 5, "ValidateCommand: Local system, command \"%s\" allowed",
+				command );
 #endif
 
-      return KWTrue;           /* Yes --> Bless the request            */
-   }
+		return KWTrue;           /* Yes --> Bless the request            */
+	}
 
 /*--------------------------------------------------------------------*/
 /*     Loop through security command table looking for the target     */
 /*--------------------------------------------------------------------*/
 
-   p = securep->commands;
-   while (*p != NULL)
-   {
-      KWBoolean global;
+	p = securep->commands;
+	while (*p != NULL)
+	{
+		KWBoolean global;
 
 #ifdef UDEBUG
-      printmsg(10,"ValidateCommand: Comparing \"%s\" to \"%s\"",
-               *p, command );
+		printmsg(10,"ValidateCommand: Comparing \"%s\" to \"%s\"",
+					*p, command );
 #endif
 
-      if equal(*p, ANY_COMMAND )
-         global = KWTrue;
-      else
-         global = KWFalse;
-
-      if (global || equali(*p, command ))
-      {
-         printmsg(5,"ValidateCommand: Command \"%s\" %splicitly allowed",
-                  command, global ? "im" : "ex" );
-         return KWTrue;
-      }
-      p++ ;
-   } /* while */
-
-/*--------------------------------------------------------------------*/
-/*               We didn't find the command; reject it                */
-/*--------------------------------------------------------------------*/
-
-   printmsg(5,"ValidateCommand: Command \"%s\" not allowed",
-            command );
-   return KWFalse;
+		if equal(*p, ANY_COMMAND )
+			global = KWTrue;
+		else
+			global = KWFalse;
+
+		if (global || equali(*p, command ))
+		{
+			printmsg(5,"ValidateCommand: Command \"%s\" %splicitly allowed",
+						command, global ? "im" : "ex" );
+			return KWTrue;
+		}
+		p++ ;
+	} /* while */
+
+/*--------------------------------------------------------------------*/
+/*               We didn't find the command; reject it					 */
+/*--------------------------------------------------------------------*/
+
+	printmsg(5,"ValidateCommand: Command \"%s\" not allowed",
+				command );
+	return KWFalse;
 
 } /* ValidateCommand */
